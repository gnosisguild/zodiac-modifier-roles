enum ParameterType {
  None
  Static
  Dynamic
  Tuple
  Array
  AbiEncoded
}

enum Operator {
  # 00:    EMPTY EXPRESSION (default, always passes)
  #          paramType: Static / Dynamic
  #          ðŸš« children
  #          ðŸš« compValue
  Pass # 0
  # ------------------------------------------------------------
  # 01-04: BOOLEAN EXPRESSIONS
  #          paramType: None
  #          âœ… children
  #          ðŸš« compValue
  And # 1
  Or # 2
  Xor # 3
  Not # 4
  # ------------------------------------------------------------
  # 05-16: COMPLEX EXPRESSIONS
  #          paramType: AbiEncoded / Tuple / Array,
  #          âœ… children
  #          ðŸš« compValue
  Matches # 5
  ArraySome # 6
  ArrayEvery # 7
  ArraySubset # 8
  _ComplexPlaceholder09
  _ComplexPlaceholder10
  _ComplexPlaceholder11
  _ComplexPlaceholder12
  _ComplexPlaceholder13
  _ComplexPlaceholder14
  _ComplexPlaceholder15
  _ComplexPlaceholder16
  # ------------------------------------------------------------
  # 17-31: COMPARISON EXPRESSIONS
  #          paramType: Static / Dynamic / Tuple / Array / AbiEncoded
  #          ðŸš« children
  #          âœ… compValue
  EqualTo # 17
  GreaterThan # 18
  LessThan # 19
  Bitmask # 20
  _ComparisonPlaceholder21
  _ComparisonPlaceholder22
  _ComparisonPlaceholder23
  _ComparisonPlaceholder24
  _ComparisonPlaceholder25
  _ComparisonPlaceholder26
  _ComparisonPlaceholder27
  _ComparisonPlaceholder28
  WithinAllowance # 29
  EtherWithinAllowance # 30
  CallWithinAllowance # 31
}

enum ExecutionOptions {
  None
  Send
  DelegateCall
  Both
}

enum Clearance {
  None
  Target
  Function
}

type Role @entity {
  id: ID! # Global unique id for role in subgraph
  key: String! # Unique within the Roles modifier instance
  rolesModifier: RolesModifier!
  targets: [Target!] @derivedFrom(field: "role")
  members: [RoleAssignment!] @derivedFrom(field: "role")
}

type Target @entity {
  id: ID!
  role: Role!
  address: Bytes!
  clearance: Clearance!
  executionOptions: ExecutionOptions!
  functions: [Function!] @derivedFrom(field: "target")
}

type Function @entity {
  id: ID!
  target: Target!
  selector: Bytes!
  executionOptions: ExecutionOptions!
  wildcarded: Boolean!
  condition: Condition
}

type Condition @entity {
  id: ID! # Derived from hash of the condition, matches the storage address (for conditions without parent)
  index: Int!
  paramType: ParameterType!
  operator: Operator!
  compValue: Bytes!
  parent: Condition
  children: [Condition!] @derivedFrom(field: "parent")
}

type Member @entity {
  id: ID!
  address: Bytes!
  enabledAsModule: Boolean!
  roles: [RoleAssignment!] @derivedFrom(field: "member")
}

type RoleAssignment @entity {
  id: ID!
  member: Member!
  role: Role!
}

type RolesModifier @entity {
  id: ID!
  address: Bytes!
  owner: Bytes!
  avatar: Bytes!
  target: Bytes!
  roles: [Role!] @derivedFrom(field: "rolesModifier")
}

type Allowance @entity {
  id: ID! # Global unique id for role in subgraph
  key: String! # Unique within the Roles modifier instance
  rolesModifier: RolesModifier!
  refillInterval: Int! # duration of the period in seconds, 0 for one-time allowance
  refillAmount: BigInt! # amount that will be replenished "at the start of every period" (replace with: per period)
  refillTimestamp: Int! # timestamp of the last interval refilled for;
  maxBalance: BigInt! # max accrual amount, replenishing stops once the unused allowance hits this value
  balance: BigInt! # unused allowance;
}
