{
  "AvatarIsOwnerOfERC721": {
    "2.1.0": {
      "contractName": "AvatarIsOwnerOfERC721",
      "sourceName": "contracts/adapters/AvatarIsOwnerOfERC721.sol",
      "contractVersion": "2.1.0",
      "compilerVersion": "v0.8.21+commit.d9974bed",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x91B1bd7BCC5E623d5CE76b0152253499a9C819d1",
      "bytecode": "0x608060405234801561000f575f80fd5b5061032b8061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063b0acb9801461002d575b5f80fd5b61004061003b3660046101b0565b61005b565b60408051921515835260208301919091520160405180910390f35b5f805f336001600160a01b0316635aef7de66040518163ffffffff1660e01b8152600401602060405180830381865afa15801561009a573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100be919061026a565b90505f89878a6100ce898361028c565b926100db939291906102b1565b6100e4916102d8565b6040516331a9108f60e11b8152600481018290529091506001600160a01b0383811691908e1690636352211e90602401602060405180830381865afa15801561012f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610153919061026a565b6001600160a01b0316149c5f9c509a5050505050505050505050565b6001600160a01b0381168114610183575f80fd5b50565b803560028110610194575f80fd5b919050565b80356001600160a01b031981168114610194575f80fd5b5f805f805f805f8060e0898b0312156101c7575f80fd5b88356101d28161016f565b975060208901359650604089013567ffffffffffffffff808211156101f5575f80fd5b818b0191508b601f830112610208575f80fd5b813581811115610216575f80fd5b8c6020828501011115610227575f80fd5b60208301985080975050505061023f60608a01610186565b93506080890135925060a0890135915061025b60c08a01610199565b90509295985092959890939650565b5f6020828403121561027a575f80fd5b81516102858161016f565b9392505050565b808201808211156102ab57634e487b7160e01b5f52601160045260245ffd5b92915050565b5f80858511156102bf575f80fd5b838611156102cb575f80fd5b5050820193919092039150565b803560208310156102ab575f19602084900360031b1b169291505056fea26469706673582212207733f53fcf22d3e1f256b11dae338bd38c971e16faf47ddcbb4c91d6cbf7bff664736f6c63430008150033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Enum.Operation",
              "name": "",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "location",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "size",
              "type": "uint256"
            },
            {
              "internalType": "bytes12",
              "name": "",
              "type": "bytes12"
            }
          ],
          "name": "check",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes32",
              "name": "reason",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
          },
          "@openzeppelin/contracts/interfaces/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
          },
          "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
          },
          "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
          },
          "contracts/adapters/AvatarIsOwnerOfERC721.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"./Types.sol\";\n\ninterface IModifier {\n    function avatar() external view returns (address);\n\n    function target() external view returns (address);\n}\n\ncontract AvatarIsOwnerOfERC721 is ICustomCondition {\n    function check(\n        address to,\n        uint256 /* value */,\n        bytes calldata data,\n        Enum.Operation /* operation */,\n        uint256 location,\n        uint256 size,\n        bytes12 /* extra */\n    ) public view returns (bool success, bytes32 reason) {\n        address avatar = IModifier(msg.sender).avatar();\n        uint256 tokenId = uint256(bytes32(data[location:location + size]));\n        return (IERC721(to).ownerOf(tokenId) == avatar, 0);\n    }\n}\n"
          },
          "contracts/adapters/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IMultiSend {\n    function multiSend(bytes memory transactions) external payable;\n}\n\nstruct UnwrappedTransaction {\n    Enum.Operation operation;\n    address to;\n    uint256 value;\n    // We wanna deal in calldata slices. We return location, let invoker slice\n    uint256 dataLocation;\n    uint256 dataSize;\n}\n\ninterface ITransactionUnwrapper {\n    function unwrap(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external view returns (UnwrappedTransaction[] memory result);\n}\n\ninterface ICustomCondition {\n    function check(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 location,\n        uint256 size,\n        bytes12 extra\n    ) external view returns (bool success, bytes32 reason);\n}\n"
          }
        },
        "settings": {
          "evmVersion": "shanghai",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "evm.bytecode",
                "evm.deployedBytecode",
                "devdoc",
                "userdoc",
                "metadata",
                "abi"
              ]
            }
          },
          "libraries": {}
        }
      }
    },
    "3.0.0": {
      "contractName": "AvatarIsOwnerOfERC721",
      "sourceName": "contracts/periphery/AvatarIsOwnerOfERC721.sol",
      "contractVersion": "3.0.0",
      "compilerVersion": "v0.8.30+commit.73712a01",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0xa3D8410fC00c11bd4DE91e2e0e177D181A36975f",
      "bytecode": "0x6080604052348015600e575f5ffd5b506104278061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610029575f3560e01c80634668d9c71461002d575b5f5ffd5b61004061003b366004610290565b610054565b604051901515815260200160405180910390f35b5f5f336001600160a01b0316635aef7de66040518163ffffffff1660e01b8152600401602060405180830381865afa158015610092573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100b69190610366565b90505f8a888b6100c68a83610388565b926100d3939291906103ad565b6100dc916103d4565b6040516331a9108f60e11b8152600481018290529091506001600160a01b0383811691908f1690636352211e90602401602060405180830381865afa158015610127573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061014b9190610366565b6001600160a01b0316149d9c50505050505050505050505050565b6001600160a01b038116811461017a575f5ffd5b50565b803561018881610166565b919050565b5f5f83601f84011261019d575f5ffd5b50813567ffffffffffffffff8111156101b4575f5ffd5b6020830191508360208285010111156101cb575f5ffd5b9250929050565b803560028110610188575f5ffd5b634e487b7160e01b5f52604160045260245ffd5b5f82601f830112610203575f5ffd5b813567ffffffffffffffff81111561021d5761021d6101e0565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561024a5761024a6101e0565b604052918252602081850181019290810186841115610267575f5ffd5b6020860192505b8383101561028657823581526020928301920161026e565b5095945050505050565b5f5f5f5f5f5f5f5f5f5f6101008b8d0312156102aa575f5ffd5b6102b38b61017d565b995060208b0135985060408b013567ffffffffffffffff8111156102d5575f5ffd5b6102e18d828e0161018d565b90995097506102f4905060608c016101d2565b955060808b0135945060a08b0135935060c08b013567ffffffffffffffff81111561031d575f5ffd5b6103298d828e0161018d565b90945092505060e08b013567ffffffffffffffff811115610348575f5ffd5b6103548d828e016101f4565b9150509295989b9194979a5092959850565b5f60208284031215610376575f5ffd5b815161038181610166565b9392505050565b808201808211156103a757634e487b7160e01b5f52601160045260245ffd5b92915050565b5f5f858511156103bb575f5ffd5b838611156103c7575f5ffd5b5050820193919092039150565b803560208310156103a7575f19602084900360031b1b169291505056fea2646970667358221220b6a4a64c91597e75b8c0f775fff634a122127beb36e79c46d0ad7df27f8b712e64736f6c634300081e0033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Operation",
              "name": "",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "location",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "size",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "",
              "type": "bytes"
            },
            {
              "internalType": "bytes32[]",
              "name": "",
              "type": "bytes32[]"
            }
          ],
          "name": "check",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis-guild/zodiac-core/contracts/core/Operation.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nenum Operation {\n  Call,\n  DelegateCall\n}\n"
          },
          "@openzeppelin/contracts/interfaces/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
          },
          "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
          },
          "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
          },
          "contracts/periphery/AvatarIsOwnerOfERC721.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"./interfaces/ICustomCondition.sol\";\n\ninterface IModifier {\n    function avatar() external view returns (address);\n\n    function target() external view returns (address);\n}\n\ncontract AvatarIsOwnerOfERC721 is ICustomCondition {\n    function check(\n        address to,\n        uint256 /* value */,\n        bytes calldata data,\n        Operation /* operation */,\n        uint256 location,\n        uint256 size,\n        bytes calldata /* extra */,\n        bytes32[] memory /* pluckedValues */\n    ) public view returns (bool success) {\n        address avatar = IModifier(msg.sender).avatar();\n        uint256 tokenId = uint256(bytes32(data[location:location + size]));\n        return IERC721(to).ownerOf(tokenId) == avatar;\n    }\n}\n"
          },
          "contracts/periphery/interfaces/ICustomCondition.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Operation.sol\";\n\ninterface ICustomCondition {\n    function check(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 location,\n        uint256 size,\n        bytes calldata extra,\n        bytes32[] memory pluckedValues\n    ) external view returns (bool success);\n}\n"
          }
        },
        "settings": {
          "evmVersion": "cancun",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata"
              ],
              "": [
                "ast"
              ]
            }
          }
        }
      }
    }
  },
  "Integrity": {
    "2.1.0": {
      "contractName": "Integrity",
      "sourceName": "contracts/Integrity.sol",
      "contractVersion": "2.1.0",
      "compilerVersion": "v0.8.21+commit.d9974bed",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x6a6Af4b16458Bc39817e4019fB02BD3b26d41049",
      "bytecode": "0x611605610035600b8282823980515f1a60731461002957634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c8063783a904714610038575b5f80fd5b61004b610046366004611386565b61004d565b005b610056816100a1565b5f5b815181101561009457610084828281518110610076576100766114b8565b602002602001015182610141565b61008d816114e0565b9050610058565b5061009e8161067b565b50565b5f805b82518110156100ef57808382815181106100c0576100c06114b8565b60200260200101515f015160ff16036100df576100dc826114e0565b91505b6100e8816114e0565b90506100a4565b5080600114158061011f5750815f8151811061010d5761010d6114b8565b60200260200101515f015160ff165f14155b1561013d57604051632f48858160e21b815260040160405180910390fd5b5050565b6040820151602083015160608401515f83601f811115610163576101636114f8565b03610199576060850151511561019457604051632d6ee65d60e21b8152600481018590526024015b60405180910390fd5b610674565b600183601f8111156101ad576101ad6114f8565b101580156101cd5750600383601f8111156101ca576101ca6114f8565b11155b1561022d575f8260068111156101e5576101e56114f8565b146102065760405163de10075b60e01b81526004810185905260240161018b565b6060850151511561019457604051632d6ee65d60e21b81526004810185905260240161018b565b600583601f811115610241576102416114f8565b036102fa57600382600681111561025a5761025a6114f8565b1415801561027a57506004826006811115610277576102776114f8565b14155b801561029857506005826006811115610295576102956114f8565b14155b80156102b6575060068260068111156102b3576102b36114f8565b14155b156102d75760405163de10075b60e01b81526004810185905260240161018b565b80511561019457604051632d6ee65d60e21b81526004810185905260240161018b565b600683601f81111561030e5761030e6114f8565b148061032b5750600783601f811115610329576103296114f8565b145b806103475750600883601f811115610345576103456114f8565b145b156103825760045b826006811115610361576103616114f8565b146102d75760405163de10075b60e01b81526004810185905260240161018b565b600f83601f811115610396576103966114f8565b036103a257600161034f565b601083601f8111156103b6576103b66114f8565b036104875760018260068111156103cf576103cf6114f8565b141580156103ef575060028260068111156103ec576103ec6114f8565b14155b801561040d5750600382600681111561040a5761040a6114f8565b14155b801561042b57506004826006811115610428576104286114f8565b14155b1561044c5760405163de10075b60e01b81526004810185905260240161018b565b80511580610466575060208151610463919061150c565b15155b1561019457604051632d6ee65d60e21b81526004810185905260240161018b565b601183601f81111561049b5761049b6114f8565b14806104b85750601283601f8111156104b6576104b66114f8565b145b806104d45750601383601f8111156104d2576104d26114f8565b145b806104f05750601483601f8111156104ee576104ee6114f8565b145b156105505760015b82600681111561050a5761050a6114f8565b1461052b5760405163de10075b60e01b81526004810185905260240161018b565b805160201461019457604051632d6ee65d60e21b81526004810185905260240161018b565b601583601f811115610564576105646114f8565b036105be57600182600681111561057d5761057d6114f8565b1415801561059d5750600282600681111561059a5761059a6114f8565b14155b1561052b5760405163de10075b60e01b81526004810185905260240161018b565b601683601f8111156105d2576105d26114f8565b036105fc57805160201461019457604051632d6ee65d60e21b81526004810185905260240161018b565b601c83601f811115610610576106106114f8565b0361061c5760016104f8565b601d83601f811115610630576106306114f8565b148061064d5750601e83601f81111561064b5761064b6114f8565b145b15610658575f6104f8565b604051630a7d7b8960e41b81526004810185905260240161018b565b5050505050565b805160015b818110156107035782818151811061069a5761069a6114b8565b60200260200101515f015160ff16836001836106b6919061152b565b815181106106c6576106c66114b8565b60200260200101515f015160ff1611156106f357604051638484738160e01b815260040160405180910390fd5b6106fc816114e0565b9050610680565b505f5b8181101561080457601d838281518110610722576107226114b8565b602002602001015160400151601f81111561073f5761073f6114f8565b14806107795750601e83828151811061075a5761075a6114b8565b602002602001015160400151601f811115610777576107776114f8565b145b80156107d35750600583848381518110610795576107956114b8565b60200260200101515f015160ff16815181106107b3576107b36114b8565b60200260200101516020015160068111156107d0576107d06114f8565b14155b156107f457604051631d40413960e11b81526004810182905260240161018b565b6107fd816114e0565b9050610706565b505f61080f83610c83565b90505f5b8351811015610b59575f84828151811061082f5761082f6114b8565b602002602001015190505f83838151811061084c5761084c6114b8565b602002602001015190505f6006811115610868576108686114f8565b8260200151600681111561087e5761087e6114f8565b0361095957601d8260400151601f81111561089b5761089b6114f8565b14806108bc5750601e8260400151601f8111156108ba576108ba6114f8565b145b80156108cb5750604081015115155b156108ec5760405163f3379ddd60e01b81526004810184905260240161018b565b60018260400151601f811115610904576109046114f8565b10158015610928575060038260400151601f811115610925576109256114f8565b11155b156109545780604001515f036109545760405163f3379ddd60e01b81526004810184905260240161018b565b610b44565b600182602001516006811115610971576109716114f8565b14806109925750600282602001516006811115610990576109906114f8565b145b156109bd576040810151156109545760405163f3379ddd60e01b81526004810184905260240161018b565b6003826020015160068111156109d5576109d56114f8565b14806109f657506005826020015160068111156109f4576109f46114f8565b145b80610a165750600682602001516006811115610a1457610a146114f8565b145b15610a425780604001515f036109545760405163f3379ddd60e01b81526004810184905260240161018b565b600482602001516006811115610a5a57610a5a6114f8565b14610a6757610a67611544565b80604001515f03610a8e5760405163f3379ddd60e01b81526004810184905260240161018b565b60068260400151601f811115610aa657610aa66114f8565b1480610ac7575060078260400151601f811115610ac557610ac56114f8565b145b8015610ad857508060400151600114155b15610af95760405163f3379ddd60e01b81526004810184905260240161018b565b60088260400151601f811115610b1157610b116114f8565b148015610b2357506101008160400151115b15610b445760405163f3379ddd60e01b81526004810184905260240161018b565b50508080610b51906114e0565b915050610813565b505f5b8351811015610c3b575f848281518110610b7857610b786114b8565b602002602001015190506001601f811115610b9557610b956114f8565b8160400151601f811115610bab57610bab6114f8565b10158015610bcf575060038160400151601f811115610bcc57610bcc6114f8565b11155b80610bef5750600481602001516006811115610bed57610bed6114f8565b145b8015610c1857506001838381518110610c0a57610c0a6114b8565b602002602001015160400151115b15610c2857610c28858385610dcd565b5080610c33816114e0565b915050610b5c565b505f610c48845f84610e82565b9050600581516006811115610c5f57610c5f6114f8565b14610c7d57604051632f48858160e21b815260040160405180910390fd5b50505050565b805160609080610c9557610c95611544565b806001600160401b03811115610cad57610cad61129c565b604051908082528060200260200182016040528015610cff57816020015b610cec60405180606001604052805f81526020015f81526020015f81525090565b815260200190600190039081610ccb5790505b5091505f19825f81518110610d1657610d166114b8565b60209081029190910101515260015b81811015610dc6575f19838281518110610d4157610d416114b8565b60200260200101515f0181815250505f83858381518110610d6457610d646114b8565b60200260200101515f015160ff1681518110610d8257610d826114b8565b602002602001015190505f19815f015103610d9b578181525b610da6826001611558565b602082018190528151610db89161152b565b604090910152600101610d25565b5050919050565b5f818381518110610de057610de06114b8565b60200260200101515f015190505f828481518110610e0057610e006114b8565b60200260200101516020015190505f826001610e1c9190611558565b90505b81811015610e7a57610e3386848387611101565b158015610e495750610e478684838761112d565b155b15610e6a576040516303a3183b60e61b81526004810186905260240161018b565b610e73816114e0565b9050610e1f565b505050505050565b604080518082019091525f8152606060208201525f848481518110610ea957610ea96114b8565b602002602001015190506001601f811115610ec657610ec66114f8565b8160400151601f811115610edc57610edc6114f8565b10158015610f00575060038160400151601f811115610efd57610efd6114f8565b11155b15610f60575f838581518110610f1857610f186114b8565b60200260200101516040015111610f3157610f31611544565b610f5885848681518110610f4757610f476114b8565b60200260200101515f015185610e82565b9150506110fa565b602081015182906006811115610f7857610f786114f8565b90816006811115610f8b57610f8b6114f8565b815250505f838581518110610fa257610fa26114b8565b60200260200101516040015111156110f8575f838581518110610fc757610fc76114b8565b60209081029190910101515190505f600483602001516006811115610fee57610fee6114f8565b1461101657848681518110611005576110056114b8565b60200260200101516020015161103f565b848681518110611028576110286114b8565b60200260200101515f0151600161103f9190611558565b905061104b828261152b565b6001600160401b038111156110625761106261129c565b6040519080825280602002602001820160405280156110a757816020015b604080518082019091525f8152606060208201528152602001906001900390816110805790505b506020850152815b818110156110f4576110c2888288610e82565b60208601516110d1858461152b565b815181106110e1576110e16114b8565b60209081029190910101526001016110af565b5050505b505b9392505050565b5f611115611110868585610e82565b6111a0565b611123611110878786610e82565b1495945050505050565b5f8061113a868685610e82565b5190506005816006811115611151576111516114f8565b148061116e5750600681600681111561116c5761116c6114f8565b145b801561119657506002611182878686610e82565b516006811115611194576111946114f8565b145b9695505050505050565b6020810151515f908015611289575f8360200151516001600160401b038111156111cc576111cc61129c565b6040519080825280602002602001820160405280156111f5578160200160208202803683370190505b5090505f5b82811015611255576112288560200151828151811061121b5761121b6114b8565b60200260200101516111a0565b82828151811061123a5761123a6114b8565b602090810291909101015261124e816114e0565b90506111fa565b50835160405161126a9190839060200161156b565b6040516020818303038152906040528051906020012092505050919050565b825160068111156110fa576110fa6114f8565b634e487b7160e01b5f52604160045260245ffd5b604051608081016001600160401b03811182821017156112d2576112d261129c565b60405290565b604051601f8201601f191681016001600160401b03811182821017156113005761130061129c565b604052919050565b803560208110611316575f80fd5b919050565b5f82601f83011261132a575f80fd5b81356001600160401b038111156113435761134361129c565b611356601f8201601f19166020016112d8565b81815284602083860101111561136a575f80fd5b816020850160208301375f918101602001919091529392505050565b5f6020808385031215611397575f80fd5b82356001600160401b03808211156113ad575f80fd5b818501915085601f8301126113c0575f80fd5b8135818111156113d2576113d261129c565b8060051b6113e18582016112d8565b91825283810185019185810190898411156113fa575f80fd5b86860192505b838310156114ab57823585811115611417575f8081fd5b86016080818c03601f190181131561142e575f8081fd5b6114366112b0565b8983013560ff81168114611449575f8081fd5b81526040838101356007811061145e575f8081fd5b828c0152606061146f858201611308565b83830152928401359289841115611487575f91508182fd5b6114958f8d8688010161131b565b9083015250845250509186019190860190611400565b9998505050505050505050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b5f600182016114f1576114f16114cc565b5060010190565b634e487b7160e01b5f52602160045260245ffd5b5f8261152657634e487b7160e01b5f52601260045260245ffd5b500690565b8181038181111561153e5761153e6114cc565b92915050565b634e487b7160e01b5f52600160045260245ffd5b8082018082111561153e5761153e6114cc565b5f6007841061158857634e487b7160e01b5f52602160045260245ffd5b8360f81b82526001602d60f81b8184015260028301845160208087015f5b838110156115c15781518552938201939082019085016115a6565b50929897505050505050505056fea26469706673582212201c1e03ab2a1598caac0eb26e3051d530e58d0f65d2024008f73f7ba8fcfec77f64736f6c63430008150033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [],
          "name": "NotBFS",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableChildCount",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableChildTypeTree",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableCompValue",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableParameterType",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableParent",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "UnsuitableRootNode",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsupportedOperator",
          "type": "error"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "parent",
                  "type": "uint8"
                },
                {
                  "internalType": "enum ParameterType",
                  "name": "paramType",
                  "type": "ParameterType"
                },
                {
                  "internalType": "enum Operator",
                  "name": "operator",
                  "type": "Operator"
                },
                {
                  "internalType": "bytes",
                  "name": "compValue",
                  "type": "bytes"
                }
              ],
              "internalType": "struct ConditionFlat[]",
              "name": "conditions",
              "type": "tuple[]"
            }
          ],
          "name": "enforce",
          "outputs": [],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "contracts/Integrity.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\n\n/**\n * @title Integrity, A library that validates condition integrity, and\n * adherence to the expected input structure and rules.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Integrity {\n    error UnsuitableRootNode();\n\n    error NotBFS();\n\n    error UnsuitableParameterType(uint256 index);\n\n    error UnsuitableCompValue(uint256 index);\n\n    error UnsupportedOperator(uint256 index);\n\n    error UnsuitableParent(uint256 index);\n\n    error UnsuitableChildCount(uint256 index);\n\n    error UnsuitableChildTypeTree(uint256 index);\n\n    function enforce(ConditionFlat[] memory conditions) external pure {\n        _root(conditions);\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            _node(conditions[i], i);\n        }\n        _tree(conditions);\n    }\n\n    function _root(ConditionFlat[] memory conditions) private pure {\n        uint256 count;\n\n        for (uint256 i; i < conditions.length; ++i) {\n            if (conditions[i].parent == i) ++count;\n        }\n        if (count != 1 || conditions[0].parent != 0) {\n            revert UnsuitableRootNode();\n        }\n    }\n\n    function _node(ConditionFlat memory condition, uint256 index) private pure {\n        Operator operator = condition.operator;\n        ParameterType paramType = condition.paramType;\n        bytes memory compValue = condition.compValue;\n        if (operator == Operator.Pass) {\n            if (condition.compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator >= Operator.And && operator <= Operator.Nor) {\n            if (paramType != ParameterType.None) {\n                revert UnsuitableParameterType(index);\n            }\n            if (condition.compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.Matches) {\n            if (\n                paramType != ParameterType.Tuple &&\n                paramType != ParameterType.Array &&\n                paramType != ParameterType.Calldata &&\n                paramType != ParameterType.AbiEncoded\n            ) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (\n            operator == Operator.ArraySome ||\n            operator == Operator.ArrayEvery ||\n            operator == Operator.ArraySubset\n        ) {\n            if (paramType != ParameterType.Array) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.EqualToAvatar) {\n            if (paramType != ParameterType.Static) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.EqualTo) {\n            if (\n                paramType != ParameterType.Static &&\n                paramType != ParameterType.Dynamic &&\n                paramType != ParameterType.Tuple &&\n                paramType != ParameterType.Array\n            ) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length == 0 || compValue.length % 32 != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (\n            operator == Operator.GreaterThan ||\n            operator == Operator.LessThan ||\n            operator == Operator.SignedIntGreaterThan ||\n            operator == Operator.SignedIntLessThan\n        ) {\n            if (paramType != ParameterType.Static) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.Bitmask) {\n            if (\n                paramType != ParameterType.Static &&\n                paramType != ParameterType.Dynamic\n            ) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.Custom) {\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.WithinAllowance) {\n            if (paramType != ParameterType.Static) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (\n            operator == Operator.EtherWithinAllowance ||\n            operator == Operator.CallWithinAllowance\n        ) {\n            if (paramType != ParameterType.None) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else {\n            revert UnsupportedOperator(index);\n        }\n    }\n\n    function _tree(ConditionFlat[] memory conditions) private pure {\n        uint256 length = conditions.length;\n        // check BFS\n        for (uint256 i = 1; i < length; ++i) {\n            if (conditions[i - 1].parent > conditions[i].parent) {\n                revert NotBFS();\n            }\n        }\n\n        for (uint256 i = 0; i < length; ++i) {\n            if (\n                (conditions[i].operator == Operator.EtherWithinAllowance ||\n                    conditions[i].operator == Operator.CallWithinAllowance) &&\n                conditions[conditions[i].parent].paramType !=\n                ParameterType.Calldata\n            ) {\n                revert UnsuitableParent(i);\n            }\n        }\n\n        Topology.Bounds[] memory childrenBounds = Topology.childrenBounds(\n            conditions\n        );\n\n        for (uint256 i = 0; i < conditions.length; i++) {\n            ConditionFlat memory condition = conditions[i];\n            Topology.Bounds memory childBounds = childrenBounds[i];\n\n            if (condition.paramType == ParameterType.None) {\n                if (\n                    (condition.operator == Operator.EtherWithinAllowance ||\n                        condition.operator == Operator.CallWithinAllowance) &&\n                    childBounds.length != 0\n                ) {\n                    revert UnsuitableChildCount(i);\n                }\n                if (\n                    (condition.operator >= Operator.And &&\n                        condition.operator <= Operator.Nor)\n                ) {\n                    if (childBounds.length == 0) {\n                        revert UnsuitableChildCount(i);\n                    }\n                }\n            } else if (\n                condition.paramType == ParameterType.Static ||\n                condition.paramType == ParameterType.Dynamic\n            ) {\n                if (childBounds.length != 0) {\n                    revert UnsuitableChildCount(i);\n                }\n            } else if (\n                condition.paramType == ParameterType.Tuple ||\n                condition.paramType == ParameterType.Calldata ||\n                condition.paramType == ParameterType.AbiEncoded\n            ) {\n                if (childBounds.length == 0) {\n                    revert UnsuitableChildCount(i);\n                }\n            } else {\n                assert(condition.paramType == ParameterType.Array);\n\n                if (childBounds.length == 0) {\n                    revert UnsuitableChildCount(i);\n                }\n\n                if (\n                    (condition.operator == Operator.ArraySome ||\n                        condition.operator == Operator.ArrayEvery) &&\n                    childBounds.length != 1\n                ) {\n                    revert UnsuitableChildCount(i);\n                } else if (\n                    condition.operator == Operator.ArraySubset &&\n                    childBounds.length > 256\n                ) {\n                    revert UnsuitableChildCount(i);\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < conditions.length; i++) {\n            ConditionFlat memory condition = conditions[i];\n            if (\n                ((condition.operator >= Operator.And &&\n                    condition.operator <= Operator.Nor) ||\n                    condition.paramType == ParameterType.Array) &&\n                childrenBounds[i].length > 1\n            ) {\n                _compatibleSiblingTypes(conditions, i, childrenBounds);\n            }\n        }\n\n        Topology.TypeTree memory typeTree = Topology.typeTree(\n            conditions,\n            0,\n            childrenBounds\n        );\n\n        if (typeTree.paramType != ParameterType.Calldata) {\n            revert UnsuitableRootNode();\n        }\n    }\n\n    function _compatibleSiblingTypes(\n        ConditionFlat[] memory conditions,\n        uint256 index,\n        Topology.Bounds[] memory childrenBounds\n    ) private pure {\n        uint256 start = childrenBounds[index].start;\n        uint256 end = childrenBounds[index].end;\n\n        for (uint256 j = start + 1; j < end; ++j) {\n            if (\n                !_isTypeMatch(conditions, start, j, childrenBounds) &&\n                !_isTypeEquivalent(conditions, start, j, childrenBounds)\n            ) {\n                revert UnsuitableChildTypeTree(index);\n            }\n        }\n    }\n\n    function _isTypeMatch(\n        ConditionFlat[] memory conditions,\n        uint256 i,\n        uint256 j,\n        Topology.Bounds[] memory childrenBounds\n    ) private pure returns (bool) {\n        return\n            typeTreeId(Topology.typeTree(conditions, i, childrenBounds)) ==\n            typeTreeId(Topology.typeTree(conditions, j, childrenBounds));\n    }\n\n    function _isTypeEquivalent(\n        ConditionFlat[] memory conditions,\n        uint256 i,\n        uint256 j,\n        Topology.Bounds[] memory childrenBounds\n    ) private pure returns (bool) {\n        ParameterType leftParamType = Topology\n            .typeTree(conditions, i, childrenBounds)\n            .paramType;\n        return\n            (leftParamType == ParameterType.Calldata ||\n                leftParamType == ParameterType.AbiEncoded) &&\n            Topology.typeTree(conditions, j, childrenBounds).paramType ==\n            ParameterType.Dynamic;\n    }\n\n    function typeTreeId(\n        Topology.TypeTree memory node\n    ) private pure returns (bytes32) {\n        uint256 childCount = node.children.length;\n        if (childCount > 0) {\n            bytes32[] memory ids = new bytes32[](node.children.length);\n            for (uint256 i = 0; i < childCount; ++i) {\n                ids[i] = typeTreeId(node.children[i]);\n            }\n\n            return keccak256(abi.encodePacked(node.paramType, \"-\", ids));\n        } else {\n            return bytes32(uint256(node.paramType));\n        }\n    }\n}\n"
          },
          "contracts/Topology.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Types.sol\";\n\n/**\n * @title Topology - a library that provides helper functions for dealing with\n * the flat representation of conditions.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Topology {\n    struct TypeTree {\n        ParameterType paramType;\n        TypeTree[] children;\n    }\n\n    struct Bounds {\n        uint256 start;\n        uint256 end;\n        uint256 length;\n    }\n\n    function childrenBounds(\n        ConditionFlat[] memory conditions\n    ) internal pure returns (Bounds[] memory result) {\n        uint256 count = conditions.length;\n        assert(count > 0);\n\n        // parents are breadth-first\n        result = new Bounds[](count);\n        result[0].start = type(uint256).max;\n\n        // first item is the root\n        for (uint256 i = 1; i < count; ) {\n            result[i].start = type(uint256).max;\n            Bounds memory parentBounds = result[conditions[i].parent];\n            if (parentBounds.start == type(uint256).max) {\n                parentBounds.start = i;\n            }\n            parentBounds.end = i + 1;\n            parentBounds.length = parentBounds.end - parentBounds.start;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function isInline(TypeTree memory node) internal pure returns (bool) {\n        ParameterType paramType = node.paramType;\n        if (paramType == ParameterType.Static) {\n            return true;\n        } else if (\n            paramType == ParameterType.Dynamic ||\n            paramType == ParameterType.Array ||\n            paramType == ParameterType.Calldata ||\n            paramType == ParameterType.AbiEncoded\n        ) {\n            return false;\n        } else {\n            uint256 length = node.children.length;\n\n            for (uint256 i; i < length; ) {\n                if (!isInline(node.children[i])) {\n                    return false;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n            return true;\n        }\n    }\n\n    function typeTree(\n        Condition memory condition\n    ) internal pure returns (TypeTree memory result) {\n        if (\n            condition.operator >= Operator.And &&\n            condition.operator <= Operator.Nor\n        ) {\n            assert(condition.children.length > 0);\n            return typeTree(condition.children[0]);\n        }\n\n        result.paramType = condition.paramType;\n        if (condition.children.length > 0) {\n            uint256 length = condition.paramType == ParameterType.Array\n                ? 1\n                : condition.children.length;\n            result.children = new TypeTree[](length);\n\n            for (uint256 i; i < length; ) {\n                result.children[i] = typeTree(condition.children[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    function typeTree(\n        ConditionFlat[] memory conditions,\n        uint256 index,\n        Bounds[] memory bounds\n    ) internal pure returns (TypeTree memory result) {\n        ConditionFlat memory condition = conditions[index];\n        if (\n            condition.operator >= Operator.And &&\n            condition.operator <= Operator.Nor\n        ) {\n            assert(bounds[index].length > 0);\n            return typeTree(conditions, bounds[index].start, bounds);\n        }\n\n        result.paramType = condition.paramType;\n        if (bounds[index].length > 0) {\n            uint256 start = bounds[index].start;\n            uint256 end = condition.paramType == ParameterType.Array\n                ? bounds[index].start + 1\n                : bounds[index].end;\n            result.children = new TypeTree[](end - start);\n            for (uint256 i = start; i < end; ) {\n                result.children[i - start] = typeTree(conditions, i, bounds);\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}\n"
          },
          "contracts/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\n/**\n * @title Types - a file that contains all of the type definitions used throughout\n * the Zodiac Roles Mod.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\n\nenum ParameterType {\n    None,\n    Static,\n    Dynamic,\n    Tuple,\n    Array,\n    Calldata,\n    AbiEncoded\n}\n\nenum Operator {\n    // 00:    EMPTY EXPRESSION (default, always passes)\n    //          paramType: Static / Dynamic / Tuple / Array\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          🚫 compValue\n    /* 00: */ Pass,\n    // ------------------------------------------------------------\n    // 01-04: LOGICAL EXPRESSIONS\n    //          paramType: None\n    //          ✅ children\n    //          🚫 compValue\n    /* 01: */ And,\n    /* 02: */ Or,\n    /* 03: */ Nor,\n    /* 04: */ _Placeholder04,\n    // ------------------------------------------------------------\n    // 05-14: COMPLEX EXPRESSIONS\n    //          paramType: Calldata / AbiEncoded / Tuple / Array,\n    //          ✅ children\n    //          🚫 compValue\n    /* 05: */ Matches,\n    /* 06: */ ArraySome,\n    /* 07: */ ArrayEvery,\n    /* 08: */ ArraySubset,\n    /* 09: */ _Placeholder09,\n    /* 10: */ _Placeholder10,\n    /* 11: */ _Placeholder11,\n    /* 12: */ _Placeholder12,\n    /* 13: */ _Placeholder13,\n    /* 14: */ _Placeholder14,\n    // ------------------------------------------------------------\n    // 15:    SPECIAL COMPARISON (without compValue)\n    //          paramType: Static\n    //          🚫 children\n    //          🚫 compValue\n    /* 15: */ EqualToAvatar,\n    // ------------------------------------------------------------\n    // 16-31: COMPARISON EXPRESSIONS\n    //          paramType: Static / Dynamic / Tuple / Array\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          ✅ compValue\n    /* 16: */ EqualTo, // paramType: Static / Dynamic / Tuple / Array\n    /* 17: */ GreaterThan, // paramType: Static\n    /* 18: */ LessThan, // paramType: Static\n    /* 19: */ SignedIntGreaterThan, // paramType: Static\n    /* 20: */ SignedIntLessThan, // paramType: Static\n    /* 21: */ Bitmask, // paramType: Static / Dynamic\n    /* 22: */ Custom, // paramType: Static / Dynamic / Tuple / Array\n    /* 23: */ _Placeholder23,\n    /* 24: */ _Placeholder24,\n    /* 25: */ _Placeholder25,\n    /* 26: */ _Placeholder26,\n    /* 27: */ _Placeholder27,\n    /* 28: */ WithinAllowance, // paramType: Static\n    /* 29: */ EtherWithinAllowance, // paramType: None\n    /* 30: */ CallWithinAllowance, // paramType: None\n    /* 31: */ _Placeholder31\n}\n\nenum ExecutionOptions {\n    None,\n    Send,\n    DelegateCall,\n    Both\n}\n\nenum Clearance {\n    None,\n    Target,\n    Function\n}\n\n// This struct is a flattened version of Condition\n// used for ABI encoding a scope config tree\n// (ABI does not support recursive types)\nstruct ConditionFlat {\n    uint8 parent;\n    ParameterType paramType;\n    Operator operator;\n    bytes compValue;\n}\n\nstruct Condition {\n    ParameterType paramType;\n    Operator operator;\n    bytes32 compValue;\n    Condition[] children;\n}\nstruct ParameterPayload {\n    uint256 location;\n    uint256 size;\n    ParameterPayload[] children;\n}\n\nstruct TargetAddress {\n    Clearance clearance;\n    ExecutionOptions options;\n}\n\nstruct Role {\n    mapping(address => bool) members;\n    mapping(address => TargetAddress) targets;\n    mapping(bytes32 => bytes32) scopeConfig;\n}\n\n/// @notice The order of members in the `Allowance` struct is significant; members updated during accrual (`balance` and `timestamp`) should be stored in the same word.\n/// @custom:member refill Amount added to balance after each period elapses.\n/// @custom:member maxRefill Refilling stops when balance reaches this value.\n/// @custom:member period Duration, in seconds, before a refill occurs. If set to 0, the allowance is for one-time use and won't be replenished.\n/// @custom:member balance Remaining allowance available for use. Decreases with usage and increases after each refill by the specified refill amount.\n/// @custom:member timestamp Timestamp when the last refill occurred.\nstruct Allowance {\n    uint128 refill;\n    uint128 maxRefill;\n    uint64 period;\n    uint128 balance;\n    uint64 timestamp;\n}\n\nstruct Consumption {\n    bytes32 allowanceKey;\n    uint128 balance;\n    uint128 consumed;\n}\n"
          }
        },
        "settings": {
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "evm.bytecode",
                "evm.deployedBytecode",
                "devdoc",
                "userdoc",
                "metadata",
                "abi"
              ]
            }
          },
          "libraries": {}
        }
      }
    }
  },
  "Packer": {
    "2.1.0": {
      "contractName": "Packer",
      "sourceName": "contracts/packers/Packer.sol",
      "contractVersion": "2.1.0",
      "compilerVersion": "v0.8.21+commit.d9974bed",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x61C5B1bE435391fDd7BC6703F3740C0d11728a8C",
      "bytecode": "0x61085a610035600b8282823980515f1a60731461002957634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c8063806362d214610038575b5f80fd5b61004b610046366004610602565b610061565b6040516100589190610735565b60405180910390f35b606061006c82610184565b61007582610246565b67ffffffffffffffff81111561008d5761008d610515565b6040519080825280601f01601f1916602001820160405280156100b7576020820181803683370190505b5082519091505f6100c9826002610794565b6100d49060206107ab565b90505f5b8281101561017c5761010484828784815181106100f7576100f76107be565b60200260200101516102bc565b6010858281518110610118576101186107be565b602002602001015160400151601f811115610135576101356107d2565b1061016c5761015e8483878481518110610151576101516107be565b6020026020010151610369565b6101696020836107ab565b91505b610175816107e6565b90506100d8565b505050919050565b80515f5b818110156102415760108382815181106101a4576101a46107be565b602002602001015160400151601f8111156101c1576101c16107d2565b1480156101d557506101d383826103b3565b155b15610231575f8382815181106101ed576101ed6107be565b60200260200101516060015190505f815190506020820191506020810382528185848151811061021f5761021f6107be565b60200260200101516060018190525050505b61023a816107e6565b9050610188565b505050565b80515f90610255600282610794565b91505f5b818110156102b5576010848281518110610275576102756107be565b602002602001015160400151601f811115610292576102926107d2565b106102a5576102a26020846107ab565b92505b6102ae816107e6565b9050610259565b5050919050565b5f6102c8600284610794565b9050815f015160f81b8482815181106102e3576102e36107be565b60200101906001600160f81b03191690815f1a9053508160400151601f81111561030f5761030f6107d2565b60208301516005906006811115610328576103286107d2565b60ff16901b1760f81b8461033d8360016107ab565b8151811061034d5761034d6107be565b60200101906001600160f81b03191690815f1a90535050505050565b5f60108260400151601f811115610382576103826107d2565b1461039a578160600151610395906107fe565b6103a7565b8160600151805190602001205b93909201929092525050565b5f808383815181106103c7576103c76107be565b6020026020010151602001519050600160068111156103e8576103e86107d2565b8160068111156103fa576103fa6107d2565b0361040957600191505061050f565b600281600681111561041d5761041d6107d2565b148061043a57506004816006811115610438576104386107d2565b145b8061045657506005816006811115610454576104546107d2565b145b8061047257506006816006811115610470576104706107d2565b145b15610480575f91505061050f565b83515f61048e8560016107ab565b90505b81811015610507575f8682815181106104ac576104ac6107be565b60200260200101515f01519050858160ff1610156104ca57506104f7565b858160ff1611156104db5750610507565b6104e587836103b3565b6104f5575f94505050505061050f565b505b610500816107e6565b9050610491565b506001925050505b92915050565b634e487b7160e01b5f52604160045260245ffd5b6040516080810167ffffffffffffffff8111828210171561054c5761054c610515565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561057b5761057b610515565b604052919050565b803560208110610591575f80fd5b919050565b5f82601f8301126105a5575f80fd5b813567ffffffffffffffff8111156105bf576105bf610515565b6105d2601f8201601f1916602001610552565b8181528460208386010111156105e6575f80fd5b816020850160208301375f918101602001919091529392505050565b5f6020808385031215610613575f80fd5b823567ffffffffffffffff8082111561062a575f80fd5b818501915085601f83011261063d575f80fd5b81358181111561064f5761064f610515565b8060051b61065e858201610552565b9182528381018501918581019089841115610677575f80fd5b86860192505b8383101561072857823585811115610694575f8081fd5b86016080818c03601f19018113156106ab575f8081fd5b6106b3610529565b8983013560ff811681146106c6575f8081fd5b8152604083810135600781106106db575f8081fd5b828c015260606106ec858201610583565b83830152928401359289841115610704575f91508182fd5b6107128f8d86880101610596565b908301525084525050918601919086019061067d565b9998505050505050505050565b5f6020808352835180828501525f5b8181101561076057858101830151858201604001528201610744565b505f604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b5f52601160045260245ffd5b808202811582820484141761050f5761050f610780565b8082018082111561050f5761050f610780565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52602160045260245ffd5b5f600182016107f7576107f7610780565b5060010190565b8051602080830151919081101561081e575f198160200360031b1b821691505b5091905056fea2646970667358221220846602d30c03a74612cec2230aa80d825d1a1f351c7e8939c0c2ec81a32434a064736f6c63430008150033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "parent",
                  "type": "uint8"
                },
                {
                  "internalType": "enum ParameterType",
                  "name": "paramType",
                  "type": "ParameterType"
                },
                {
                  "internalType": "enum Operator",
                  "name": "operator",
                  "type": "Operator"
                },
                {
                  "internalType": "bytes",
                  "name": "compValue",
                  "type": "bytes"
                }
              ],
              "internalType": "struct ConditionFlat[]",
              "name": "conditionsFlat",
              "type": "tuple[]"
            }
          ],
          "name": "pack",
          "outputs": [
            {
              "internalType": "bytes",
              "name": "buffer",
              "type": "bytes"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/core/Modifier.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport {ExecutionTracker} from \"../signature/ExecutionTracker.sol\";\nimport {IAvatar} from \"../interfaces/IAvatar.sol\";\nimport {Module} from \"./Module.sol\";\nimport {SignatureChecker} from \"../signature/SignatureChecker.sol\";\n\n/// @title Modifier Interface - A contract that sits between a Module and an Avatar and enforce some additional logic.\nabstract contract Modifier is\n  Module,\n  ExecutionTracker,\n  SignatureChecker,\n  IAvatar\n{\n  address internal constant SENTINEL_MODULES = address(0x1);\n  /// Mapping of modules.\n  mapping(address => address) internal modules;\n\n  /// `sender` is not an authorized module.\n  /// @param sender The address of the sender.\n  error NotAuthorized(address sender);\n\n  /// `module` is invalid.\n  error InvalidModule(address module);\n\n  /// `pageSize` is invalid.\n  error InvalidPageSize();\n\n  /// `module` is already disabled.\n  error AlreadyDisabledModule(address module);\n\n  /// `module` is already enabled.\n  error AlreadyEnabledModule(address module);\n\n  /// @dev `setModules()` was already called.\n  error SetupModulesAlreadyCalled();\n\n  /*\n    --------------------------------------------------\n    You must override both of the following virtual functions,\n    execTransactionFromModule() and execTransactionFromModuleReturnData().\n    It is recommended that implementations of both functions make use the \n    onlyModule modifier.\n    */\n\n  /// @dev Passes a transaction to the modifier.\n  /// @notice Can only be called by enabled modules.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction.\n  function execTransactionFromModule(\n    address to,\n    uint256 value,\n    bytes calldata data,\n    Enum.Operation operation\n  ) public virtual returns (bool success);\n\n  /// @dev Passes a transaction to the modifier, expects return data.\n  /// @notice Can only be called by enabled modules.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction.\n  function execTransactionFromModuleReturnData(\n    address to,\n    uint256 value,\n    bytes calldata data,\n    Enum.Operation operation\n  ) public virtual returns (bool success, bytes memory returnData);\n\n  /*\n    --------------------------------------------------\n    */\n\n  modifier moduleOnly() {\n    if (modules[msg.sender] == address(0)) {\n      (bytes32 hash, address signer) = moduleTxSignedBy();\n\n      // is the signer a module?\n      if (modules[signer] == address(0)) {\n        revert NotAuthorized(msg.sender);\n      }\n\n      // is the provided signature fresh?\n      if (consumed[signer][hash]) {\n        revert HashAlreadyConsumed(hash);\n      }\n\n      consumed[signer][hash] = true;\n      emit HashExecuted(hash);\n    }\n\n    _;\n  }\n\n  function sentOrSignedByModule() internal view returns (address) {\n    if (modules[msg.sender] != address(0)) {\n      return msg.sender;\n    }\n\n    (, address signer) = moduleTxSignedBy();\n    if (modules[signer] != address(0)) {\n      return signer;\n    }\n\n    return address(0);\n  }\n\n  /// @dev Disables a module on the modifier.\n  /// @notice This can only be called by the owner.\n  /// @param prevModule Module that pointed to the module to be removed in the linked list.\n  /// @param module Module to be removed.\n  function disableModule(\n    address prevModule,\n    address module\n  ) public override onlyOwner {\n    if (module == address(0) || module == SENTINEL_MODULES)\n      revert InvalidModule(module);\n    if (modules[prevModule] != module) revert AlreadyDisabledModule(module);\n    modules[prevModule] = modules[module];\n    modules[module] = address(0);\n    emit DisabledModule(module);\n  }\n\n  /// @dev Enables a module that can add transactions to the queue\n  /// @param module Address of the module to be enabled\n  /// @notice This can only be called by the owner\n  function enableModule(address module) public override onlyOwner {\n    if (module == address(0) || module == SENTINEL_MODULES)\n      revert InvalidModule(module);\n    if (modules[module] != address(0)) revert AlreadyEnabledModule(module);\n    modules[module] = modules[SENTINEL_MODULES];\n    modules[SENTINEL_MODULES] = module;\n    emit EnabledModule(module);\n  }\n\n  /// @dev Returns if an module is enabled\n  /// @return True if the module is enabled\n  function isModuleEnabled(\n    address _module\n  ) public view override returns (bool) {\n    return SENTINEL_MODULES != _module && modules[_module] != address(0);\n  }\n\n  /// @dev Returns array of modules.\n  ///      If all entries fit into a single page, the next pointer will be 0x1.\n  ///      If another page is present, next will be the last element of the returned array.\n  /// @param start Start of the page. Has to be a module or start pointer (0x1 address)\n  /// @param pageSize Maximum number of modules that should be returned. Has to be > 0\n  /// @return array Array of modules.\n  /// @return next Start of the next page.\n  function getModulesPaginated(\n    address start,\n    uint256 pageSize\n  ) external view override returns (address[] memory array, address next) {\n    if (start != SENTINEL_MODULES && !isModuleEnabled(start)) {\n      revert InvalidModule(start);\n    }\n    if (pageSize == 0) {\n      revert InvalidPageSize();\n    }\n\n    // Init array with max page size\n    array = new address[](pageSize);\n\n    // Populate return array\n    uint256 moduleCount = 0;\n    next = modules[start];\n    while (\n      next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize\n    ) {\n      array[moduleCount] = next;\n      next = modules[next];\n      moduleCount++;\n    }\n\n    // Because of the argument validation we can assume that\n    // the `currentModule` will always be either a module address\n    // or sentinel address (aka the end). If we haven't reached the end\n    // inside the loop, we need to set the next pointer to the last element\n    // because it skipped over to the next module which is neither included\n    // in the current page nor won't be included in the next one\n    // if you pass it as a start.\n    if (next != SENTINEL_MODULES) {\n      next = array[moduleCount - 1];\n    }\n    // Set correct size of returned array\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      mstore(array, moduleCount)\n    }\n  }\n\n  /// @dev Initializes the modules linked list.\n  /// @notice Should be called as part of the `setUp` / initializing function and can only be called once.\n  function setupModules() internal {\n    if (modules[SENTINEL_MODULES] != address(0))\n      revert SetupModulesAlreadyCalled();\n    modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n  }\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/core/Module.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\nimport {FactoryFriendly} from \"../factory/FactoryFriendly.sol\";\nimport {IAvatar} from \"../interfaces/IAvatar.sol\";\n\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\nabstract contract Module is FactoryFriendly {\n  /// @dev Address that will ultimately execute function calls.\n  address public avatar;\n  /// @dev Address that this module will pass transactions to.\n  address public target;\n\n  /// @dev Emitted each time the avatar is set.\n  event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\n  /// @dev Emitted each time the Target is set.\n  event TargetSet(address indexed previousTarget, address indexed newTarget);\n\n  /// @dev Sets the avatar to a new avatar (`newAvatar`).\n  /// @notice Can only be called by the current owner.\n  function setAvatar(address _avatar) public onlyOwner {\n    address previousAvatar = avatar;\n    avatar = _avatar;\n    emit AvatarSet(previousAvatar, _avatar);\n  }\n\n  /// @dev Sets the target to a new target (`newTarget`).\n  /// @notice Can only be called by the current owner.\n  function setTarget(address _target) public onlyOwner {\n    address previousTarget = target;\n    target = _target;\n    emit TargetSet(previousTarget, _target);\n  }\n\n  /// @dev Passes a transaction to be executed by the avatar.\n  /// @notice Can only be called by this contract.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function exec(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) internal virtual returns (bool success) {\n    return\n      IAvatar(target).execTransactionFromModule(to, value, data, operation);\n  }\n\n  /// @dev Passes a transaction to be executed by the target and returns data.\n  /// @notice Can only be called by this contract.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execAndReturnData(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) internal virtual returns (bool success, bytes memory returnData) {\n    return\n      IAvatar(target).execTransactionFromModuleReturnData(\n        to,\n        value,\n        data,\n        operation\n      );\n  }\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\npragma solidity >=0.7.0 <0.9.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract FactoryFriendly is OwnableUpgradeable {\n  function setUp(bytes memory initializeParams) public virtual;\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n  event EnabledModule(address module);\n  event DisabledModule(address module);\n  event ExecutionFromModuleSuccess(address indexed module);\n  event ExecutionFromModuleFailure(address indexed module);\n\n  /// @dev Enables a module on the avatar.\n  /// @notice Can only be called by the avatar.\n  /// @notice Modules should be stored as a linked list.\n  /// @notice Must emit EnabledModule(address module) if successful.\n  /// @param module Module to be enabled.\n  function enableModule(address module) external;\n\n  /// @dev Disables a module on the avatar.\n  /// @notice Can only be called by the avatar.\n  /// @notice Must emit DisabledModule(address module) if successful.\n  /// @param prevModule Address that pointed to the module to be removed in the linked list\n  /// @param module Module to be removed.\n  function disableModule(address prevModule, address module) external;\n\n  /// @dev Allows a Module to execute a transaction.\n  /// @notice Can only be called by an enabled module.\n  /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n  /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execTransactionFromModule(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) external returns (bool success);\n\n  /// @dev Allows a Module to execute a transaction and return data\n  /// @notice Can only be called by an enabled module.\n  /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n  /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execTransactionFromModuleReturnData(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) external returns (bool success, bytes memory returnData);\n\n  /// @dev Returns if an module is enabled\n  /// @return True if the module is enabled\n  function isModuleEnabled(address module) external view returns (bool);\n\n  /// @dev Returns array of modules.\n  /// @param start Start of the page.\n  /// @param pageSize Maximum number of modules that should be returned.\n  /// @return array Array of modules.\n  /// @return next Start of the next page.\n  function getModulesPaginated(\n    address start,\n    uint256 pageSize\n  ) external view returns (address[] memory array, address next);\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/signature/ExecutionTracker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n/// @title ExecutionTracker - A contract that keeps track of executed and invalidated hashes\ncontract ExecutionTracker {\n  error HashAlreadyConsumed(bytes32);\n\n  event HashExecuted(bytes32);\n  event HashInvalidated(bytes32);\n\n  mapping(address => mapping(bytes32 => bool)) public consumed;\n\n  function invalidate(bytes32 hash) external {\n    consumed[msg.sender][hash] = true;\n    emit HashInvalidated(hash);\n  }\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/signature/IERC1271.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC1271 {\n  /**\n   * @notice EIP1271 method to validate a signature.\n   * @param hash Hash of the data signed on the behalf of address(this).\n   * @param signature Signature byte array associated with _data.\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */\n  function isValidSignature(\n    bytes32 hash,\n    bytes memory signature\n  ) external view returns (bytes4);\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/signature/SignatureChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IERC1271} from \"./IERC1271.sol\";\n\n/// @title SignatureChecker - A contract that retrieves and validates signatures appended to transaction calldata.\n/// @dev currently supports eip-712 and eip-1271 signatures\nabstract contract SignatureChecker {\n  /**\n   * @notice Searches for a signature, validates it, and returns the signer's address.\n   * @dev When signature not found or invalid, zero address is returned\n   * @return The address of the signer.\n   */\n  function moduleTxSignedBy() internal view returns (bytes32, address) {\n    bytes calldata data = msg.data;\n\n    /*\n     * The idea is to extend `onlyModule` and provide signature checking\n     * without code changes to inheriting contracts (Modifiers).\n     *\n     * Since it's a generic mechanism, there is no way to conclusively\n     * identify the trailing bytes as a signature. We simply slice those\n     * and recover signer.\n     *\n     * As a result, we impose a minimum calldata length equal to a function\n     * selector plus salt, plus a signature (i.e., 4 + 32 + 65 bytes), any\n     * shorter and calldata it guaranteed to not contain a signature.\n     */\n    if (data.length < 4 + 32 + 65) {\n      return (bytes32(0), address(0));\n    }\n\n    (uint8 v, bytes32 r, bytes32 s) = _splitSignature(data);\n\n    uint256 end = data.length - (32 + 65);\n    bytes32 salt = bytes32(data[end:]);\n\n    /*\n     * When handling contract signatures:\n     *  v - is zero\n     *  r - contains the signer\n     *  s - contains the offset within calldata where the signer specific\n     *      signature is located\n     *\n     * We detect contract signatures by checking:\n     *  1- `v` is zero\n     *  2- `s` points within the buffer, is after selector, is before\n     *      salt and delimits a non-zero length buffer\n     */\n    if (v == 0) {\n      uint256 start = uint256(s);\n      if (start < 4 || start > end) {\n        return (bytes32(0), address(0));\n      }\n      address signer = address(uint160(uint256(r)));\n\n      bytes32 hash = moduleTxHash(data[:start], salt);\n      return\n        _isValidContractSignature(signer, hash, data[start:end])\n          ? (hash, signer)\n          : (bytes32(0), address(0));\n    } else {\n      bytes32 hash = moduleTxHash(data[:end], salt);\n      return (hash, ecrecover(hash, v, r, s));\n    }\n  }\n\n  /**\n   * @notice Hashes the transaction EIP-712 data structure.\n   * @dev The produced hash is intended to be signed.\n   * @param data The current transaction's calldata.\n   * @param salt The salt value.\n   * @return The 32-byte hash that is to be signed.\n   */\n  function moduleTxHash(\n    bytes calldata data,\n    bytes32 salt\n  ) public view returns (bytes32) {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this)\n    );\n    bytes memory moduleTxData = abi.encodePacked(\n      bytes1(0x19),\n      bytes1(0x01),\n      domainSeparator,\n      keccak256(abi.encode(MODULE_TX_TYPEHASH, keccak256(data), salt))\n    );\n    return keccak256(moduleTxData);\n  }\n\n  /**\n   * @dev Extracts signature from calldata, and divides it into `uint8 v, bytes32 r, bytes32 s`.\n   * @param data The current transaction's calldata.\n   * @return v The ECDSA v value\n   * @return r The ECDSA r value\n   * @return s The ECDSA s value\n   */\n  function _splitSignature(\n    bytes calldata data\n  ) private pure returns (uint8 v, bytes32 r, bytes32 s) {\n    v = uint8(bytes1(data[data.length - 1:]));\n    r = bytes32(data[data.length - 65:]);\n    s = bytes32(data[data.length - 33:]);\n  }\n\n  /**\n   * @dev Calls the signer contract, and validates the contract signature.\n   * @param signer The address of the signer contract.\n   * @param hash Hash of the data signed\n   * @param signature The contract signature.\n   * @return result Indicates whether the signature is valid.\n   */\n  function _isValidContractSignature(\n    address signer,\n    bytes32 hash,\n    bytes calldata signature\n  ) internal view returns (bool result) {\n    uint256 size;\n    // eslint-disable-line no-inline-assembly\n    assembly {\n      size := extcodesize(signer)\n    }\n    if (size == 0) {\n      return false;\n    }\n\n    (, bytes memory returnData) = signer.staticcall(\n      abi.encodeWithSelector(\n        IERC1271.isValidSignature.selector,\n        hash,\n        signature\n      )\n    );\n\n    return bytes4(returnData) == EIP1271_MAGIC_VALUE;\n  }\n\n  // keccak256(\n  //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n  // );\n  bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n    0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n  // keccak256(\n  //     \"ModuleTx(bytes data,bytes32 salt)\"\n  // );\n  bytes32 private constant MODULE_TX_TYPEHASH =\n    0x2939aeeda3ca260200c9f7b436b19e13207547ccc65cfedc857751c5ea6d91d4;\n\n  // bytes4(keccak256(\n  //     \"isValidSignature(bytes32,bytes)\"\n  // ));\n  bytes4 private constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
          },
          "contracts/packers/BufferPacker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../Types.sol\";\n\n/**\n * @title BufferPacker a library that provides packing and unpacking functions\n * for conditions. It allows packing externally provided ConditionsFlat[] into\n * a storage-optimized buffer, and later unpack it into memory.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary BufferPacker {\n    // HEADER (stored as a single word in storage)\n    // 2   bytes -> count (Condition count)\n    // 1   bytes -> options (ExecutionOptions)\n    // 1   bytes -> isWildcarded\n    // 8   bytes -> unused\n    // 20  bytes -> pointer (address containining packed conditions)\n    uint256 private constant OFFSET_COUNT = 240;\n    uint256 private constant OFFSET_OPTIONS = 224;\n    uint256 private constant OFFSET_IS_WILDCARDED = 216;\n    uint256 private constant MASK_COUNT = 0xffff << OFFSET_COUNT;\n    uint256 private constant MASK_OPTIONS = 0xff << OFFSET_OPTIONS;\n    uint256 private constant MASK_IS_WILDCARDED = 0x1 << OFFSET_IS_WILDCARDED;\n    // CONDITION (stored as runtimeBytecode at pointer address kept in header)\n    // 8    bits -> parent\n    // 3    bits -> type\n    // 5    bits -> operator\n    uint256 private constant BYTES_PER_CONDITION = 2;\n    uint16 private constant OFFSET_PARENT = 8;\n    uint16 private constant OFFSET_PARAM_TYPE = 5;\n    uint16 private constant OFFSET_OPERATOR = 0;\n    uint16 private constant MASK_PARENT = uint16(0xff << OFFSET_PARENT);\n    uint16 private constant MASK_PARAM_TYPE = uint16(0x07 << OFFSET_PARAM_TYPE);\n    uint16 private constant MASK_OPERATOR = uint16(0x1f << OFFSET_OPERATOR);\n\n    function packedSize(\n        ConditionFlat[] memory conditions\n    ) internal pure returns (uint256 result) {\n        uint256 count = conditions.length;\n\n        result = count * BYTES_PER_CONDITION;\n        for (uint256 i; i < count; ++i) {\n            if (conditions[i].operator >= Operator.EqualTo) {\n                result += 32;\n            }\n        }\n    }\n\n    function packHeader(\n        uint256 count,\n        ExecutionOptions options,\n        address pointer\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(count << OFFSET_COUNT) |\n            (bytes32(uint256(options)) << OFFSET_OPTIONS) |\n            bytes32(uint256(uint160(pointer)));\n    }\n\n    function packHeaderAsWildcarded(\n        ExecutionOptions options\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(uint256(options) << OFFSET_OPTIONS) |\n            bytes32(MASK_IS_WILDCARDED);\n    }\n\n    function unpackHeader(\n        bytes32 header\n    ) internal pure returns (uint256 count, address pointer) {\n        count = (uint256(header) & MASK_COUNT) >> OFFSET_COUNT;\n        pointer = address(bytes20(uint160(uint256(header))));\n    }\n\n    function unpackOptions(\n        bytes32 header\n    ) internal pure returns (bool isWildcarded, ExecutionOptions options) {\n        isWildcarded = uint256(header) & MASK_IS_WILDCARDED != 0;\n        options = ExecutionOptions(\n            (uint256(header) & MASK_OPTIONS) >> OFFSET_OPTIONS\n        );\n    }\n\n    function packCondition(\n        bytes memory buffer,\n        uint256 index,\n        ConditionFlat memory condition\n    ) internal pure {\n        uint256 offset = index * BYTES_PER_CONDITION;\n        buffer[offset] = bytes1(condition.parent);\n        buffer[offset + 1] = bytes1(\n            (uint8(condition.paramType) << uint8(OFFSET_PARAM_TYPE)) |\n                uint8(condition.operator)\n        );\n    }\n\n    function packCompValue(\n        bytes memory buffer,\n        uint256 offset,\n        ConditionFlat memory condition\n    ) internal pure {\n        bytes32 word = condition.operator == Operator.EqualTo\n            ? keccak256(condition.compValue)\n            : bytes32(condition.compValue);\n\n        assembly {\n            mstore(add(buffer, offset), word)\n        }\n    }\n\n    function unpackBody(\n        bytes memory buffer,\n        uint256 count\n    )\n        internal\n        pure\n        returns (ConditionFlat[] memory result, bytes32[] memory compValues)\n    {\n        result = new ConditionFlat[](count);\n        compValues = new bytes32[](count);\n\n        bytes32 word;\n        uint256 offset = 32;\n        uint256 compValueOffset = 32 + count * BYTES_PER_CONDITION;\n\n        for (uint256 i; i < count; ) {\n            assembly {\n                word := mload(add(buffer, offset))\n            }\n            offset += BYTES_PER_CONDITION;\n\n            uint16 bits = uint16(bytes2(word));\n            ConditionFlat memory condition = result[i];\n            condition.parent = uint8((bits & MASK_PARENT) >> OFFSET_PARENT);\n            condition.paramType = ParameterType(\n                (bits & MASK_PARAM_TYPE) >> OFFSET_PARAM_TYPE\n            );\n            condition.operator = Operator(bits & MASK_OPERATOR);\n\n            if (condition.operator >= Operator.EqualTo) {\n                assembly {\n                    word := mload(add(buffer, compValueOffset))\n                }\n                compValueOffset += 32;\n                compValues[i] = word;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
          },
          "contracts/packers/Packer.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/zodiac/contracts/core/Modifier.sol\";\n\nimport \"./BufferPacker.sol\";\n\n/**\n * @title Packer - a library that coordinates the process of packing\n * conditionsFlat into a storage optimized buffer.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Packer {\n    function pack(\n        ConditionFlat[] memory conditionsFlat\n    ) external pure returns (bytes memory buffer) {\n        _removeExtraneousOffsets(conditionsFlat);\n\n        buffer = new bytes(BufferPacker.packedSize(conditionsFlat));\n\n        uint256 count = conditionsFlat.length;\n        uint256 offset = 32 + count * 2;\n        for (uint256 i; i < count; ++i) {\n            BufferPacker.packCondition(buffer, i, conditionsFlat[i]);\n            if (conditionsFlat[i].operator >= Operator.EqualTo) {\n                BufferPacker.packCompValue(buffer, offset, conditionsFlat[i]);\n                offset += 32;\n            }\n        }\n    }\n\n    /**\n     * @dev This function removes unnecessary offsets from compValue fields of\n     * the `conditions` array. Its purpose is to ensure a consistent API where\n     * every `compValue` provided for use in `Operations.EqualsTo` is obtained\n     * by calling `abi.encode` directly.\n     *\n     * By removing the leading extraneous offsets this function makes\n     * abi.encode(...) match the output produced by Decoder inspection.\n     * Without it, the encoded fields would need to be patched externally\n     * depending on whether the payload is fully encoded inline or not.\n     *\n     * @param conditionsFlat Array of ConditionFlat structs to remove extraneous\n     * offsets from\n     */\n    function _removeExtraneousOffsets(\n        ConditionFlat[] memory conditionsFlat\n    ) private pure {\n        uint256 count = conditionsFlat.length;\n        for (uint256 i; i < count; ++i) {\n            if (\n                conditionsFlat[i].operator == Operator.EqualTo &&\n                !_isInline(conditionsFlat, i)\n            ) {\n                bytes memory compValue = conditionsFlat[i].compValue;\n                uint256 length = compValue.length;\n                assembly {\n                    compValue := add(compValue, 32)\n                    mstore(compValue, sub(length, 32))\n                }\n                conditionsFlat[i].compValue = compValue;\n            }\n        }\n    }\n\n    function _isInline(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure returns (bool) {\n        ParameterType paramType = conditions[index].paramType;\n        if (paramType == ParameterType.Static) {\n            return true;\n        } else if (\n            paramType == ParameterType.Dynamic ||\n            paramType == ParameterType.Array ||\n            paramType == ParameterType.Calldata ||\n            paramType == ParameterType.AbiEncoded\n        ) {\n            return false;\n        } else {\n            uint256 length = conditions.length;\n\n            for (uint256 j = index + 1; j < length; ++j) {\n                uint8 parent = conditions[j].parent;\n                if (parent < index) {\n                    continue;\n                }\n\n                if (parent > index) {\n                    break;\n                }\n\n                if (!_isInline(conditions, j)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n"
          },
          "contracts/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\n/**\n * @title Types - a file that contains all of the type definitions used throughout\n * the Zodiac Roles Mod.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\n\nenum ParameterType {\n    None,\n    Static,\n    Dynamic,\n    Tuple,\n    Array,\n    Calldata,\n    AbiEncoded\n}\n\nenum Operator {\n    // 00:    EMPTY EXPRESSION (default, always passes)\n    //          paramType: Static / Dynamic / Tuple / Array\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          🚫 compValue\n    /* 00: */ Pass,\n    // ------------------------------------------------------------\n    // 01-04: LOGICAL EXPRESSIONS\n    //          paramType: None\n    //          ✅ children\n    //          🚫 compValue\n    /* 01: */ And,\n    /* 02: */ Or,\n    /* 03: */ Nor,\n    /* 04: */ _Placeholder04,\n    // ------------------------------------------------------------\n    // 05-14: COMPLEX EXPRESSIONS\n    //          paramType: Calldata / AbiEncoded / Tuple / Array,\n    //          ✅ children\n    //          🚫 compValue\n    /* 05: */ Matches,\n    /* 06: */ ArraySome,\n    /* 07: */ ArrayEvery,\n    /* 08: */ ArraySubset,\n    /* 09: */ _Placeholder09,\n    /* 10: */ _Placeholder10,\n    /* 11: */ _Placeholder11,\n    /* 12: */ _Placeholder12,\n    /* 13: */ _Placeholder13,\n    /* 14: */ _Placeholder14,\n    // ------------------------------------------------------------\n    // 15:    SPECIAL COMPARISON (without compValue)\n    //          paramType: Static\n    //          🚫 children\n    //          🚫 compValue\n    /* 15: */ EqualToAvatar,\n    // ------------------------------------------------------------\n    // 16-31: COMPARISON EXPRESSIONS\n    //          paramType: Static / Dynamic / Tuple / Array\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          ✅ compValue\n    /* 16: */ EqualTo, // paramType: Static / Dynamic / Tuple / Array\n    /* 17: */ GreaterThan, // paramType: Static\n    /* 18: */ LessThan, // paramType: Static\n    /* 19: */ SignedIntGreaterThan, // paramType: Static\n    /* 20: */ SignedIntLessThan, // paramType: Static\n    /* 21: */ Bitmask, // paramType: Static / Dynamic\n    /* 22: */ Custom, // paramType: Static / Dynamic / Tuple / Array\n    /* 23: */ _Placeholder23,\n    /* 24: */ _Placeholder24,\n    /* 25: */ _Placeholder25,\n    /* 26: */ _Placeholder26,\n    /* 27: */ _Placeholder27,\n    /* 28: */ WithinAllowance, // paramType: Static\n    /* 29: */ EtherWithinAllowance, // paramType: None\n    /* 30: */ CallWithinAllowance, // paramType: None\n    /* 31: */ _Placeholder31\n}\n\nenum ExecutionOptions {\n    None,\n    Send,\n    DelegateCall,\n    Both\n}\n\nenum Clearance {\n    None,\n    Target,\n    Function\n}\n\n// This struct is a flattened version of Condition\n// used for ABI encoding a scope config tree\n// (ABI does not support recursive types)\nstruct ConditionFlat {\n    uint8 parent;\n    ParameterType paramType;\n    Operator operator;\n    bytes compValue;\n}\n\nstruct Condition {\n    ParameterType paramType;\n    Operator operator;\n    bytes32 compValue;\n    Condition[] children;\n}\nstruct ParameterPayload {\n    uint256 location;\n    uint256 size;\n    ParameterPayload[] children;\n}\n\nstruct TargetAddress {\n    Clearance clearance;\n    ExecutionOptions options;\n}\n\nstruct Role {\n    mapping(address => bool) members;\n    mapping(address => TargetAddress) targets;\n    mapping(bytes32 => bytes32) scopeConfig;\n}\n\n/// @notice The order of members in the `Allowance` struct is significant; members updated during accrual (`balance` and `timestamp`) should be stored in the same word.\n/// @custom:member refill Amount added to balance after each period elapses.\n/// @custom:member maxRefill Refilling stops when balance reaches this value.\n/// @custom:member period Duration, in seconds, before a refill occurs. If set to 0, the allowance is for one-time use and won't be replenished.\n/// @custom:member balance Remaining allowance available for use. Decreases with usage and increases after each refill by the specified refill amount.\n/// @custom:member timestamp Timestamp when the last refill occurred.\nstruct Allowance {\n    uint128 refill;\n    uint128 maxRefill;\n    uint64 period;\n    uint128 balance;\n    uint64 timestamp;\n}\n\nstruct Consumption {\n    bytes32 allowanceKey;\n    uint128 balance;\n    uint128 consumed;\n}\n"
          }
        },
        "settings": {
          "evmVersion": "shanghai",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "evm.bytecode",
                "evm.deployedBytecode",
                "devdoc",
                "userdoc",
                "metadata",
                "abi"
              ]
            }
          },
          "libraries": {}
        }
      }
    }
  },
  "Roles": {
    "2.1.0": {
      "contractName": "Roles",
      "sourceName": "contracts/Roles.sol",
      "contractVersion": "2.1.0",
      "compilerVersion": "v0.8.21+commit.d9974bed",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x9646fDAD06d3e24444381f44362a3B0eB343D337",
      "bytecode": "0x608060405234801562000010575f80fd5b506040516200630a3803806200630a83398101604081905262000033916200035a565b604080516001600160a01b038581166020830152848116828401528316606080830191909152825180830390910181526080909101909152620000768162000080565b50505050620003ab565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03165f81158015620000ca5750825b90505f826001600160401b03166001148015620000e65750303b155b905081158015620000f5575080155b15620001145760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b031916600117855583156200014357845460ff60401b1916680100000000000000001785555b5f805f888060200190518101906200015c91906200035a565b919450925090506200016e8362000240565b5f80546001600160a01b038085166001600160a01b0319928316179092556001805492841692909116919091179055620001a7620002b0565b6040516001600160a01b038281168252808416919085169033907f34d3b96a088381c6843a1f9d94d251afa88f83cc7a0d17fc23a7057506a3fc6d9060200160405180910390a450505083156200023857845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930080546001600160a01b031981166001600160a01b03848116918217845560405192169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a3505050565b60015f5260036020527fa15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054c546001600160a01b031615620003035760405163dfd49ebd60e01b815260040160405180910390fd5b60015f81905260036020527fa15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054c80546001600160a01b0319169091179055565b6001600160a01b038116811462000357575f80fd5b50565b5f805f606084860312156200036d575f80fd5b83516200037a8162000342565b60208501519093506200038d8162000342565b6040850151909250620003a08162000342565b809150509250925092565b615f5180620003b95f395ff3fe608060405234801561000f575f80fd5b50600436106101ab575f3560e01c80637508dd98116100eb578063b3dd25c71161008f578063b3dd25c71461044a578063c6fe87471461045d578063cc2f845214610470578063d4b8399214610491578063d8afba76146104a4578063e009cfde146104b7578063e29dfba8146104ca578063f2fde38b146104f7575f80fd5b80637508dd98146103bd578063776d1a01146103d05780637b0da5b2146103e35780638da5cb5b146103f6578063946d364e146103fe578063957ed2b314610411578063a4f9edbf14610424578063a8ec43ee14610437575f80fd5b8063468721a711610152578063468721a7146102ac5780635229073f146102bf5780635aef7de6146102d25780635e7c9fe8146102e4578063610b59251461037c57806366523f7d1461038f57806369ecc3cf146103a2578063715018a6146103b5575f80fd5b80630172a43a146101af578063086cfca8146101c45780630c6c76b8146101d75780632916a9af146101ea5780632959513c146101fd5780632b99e5061461023b5780632d3c25471461025c5780632d9ad53d14610289575b5f80fd5b6101c26101bd366004614d45565b61050a565b005b6101c26101d2366004614d73565b6105e0565b6101c26101e5366004614d45565b610637565b6101c26101f8366004614da5565b61070b565b61022561020b366004614deb565b60066020525f90815260409020546001600160a01b031681565b6040516102329190614e02565b60405180910390f35b61024e610249366004614e6c565b6107b0565b604051610232929190614f42565b61027b61026a366004614d73565b60076020525f908152604090205481565b604051908152602001610232565b61029c610297366004614d73565b610854565b6040519015158152602001610232565b61029c6102ba366004614f5c565b61088d565b61024e6102cd366004614f5c565b61090f565b5f54610225906001600160a01b031681565b61033d6102f2366004614deb565b60056020525f9081526040902080546001909101546001600160801b0380831692600160801b90048116916001600160401b0380821692600160401b83041691600160c01b90041685565b604080516001600160801b03968716815294861660208601526001600160401b039384169085015293166060830152909116608082015260a001610232565b6101c261038a366004614d73565b610998565b6101c261039d366004614fca565b610aa7565b6101c26103b0366004614deb565b610b31565b6101c2610b83565b6101c26103cb366004615140565b610b96565b6101c26103de366004614d73565b610c69565b6101c26103f13660046152b3565b610cc2565b610225610d9d565b6101c261040c3660046152e5565b610dcb565b6101c261041f36600461534f565b610e23565b6101c26104323660046153cb565b610f38565b6101c2610445366004615428565b6110f1565b6101c2610458366004615491565b6112ea565b61029c61046b366004614e6c565b61136a565b61048361047e3660046152e5565b611408565b6040516102329291906154dd565b600154610225906001600160a01b031681565b61027b6104b2366004615539565b611598565b6101c26104c5366004615580565b6116b6565b61029c6104d83660046152e5565b600260209081525f928352604080842090915290825290205460ff1681565b6101c2610505366004614d73565b6117ad565b6105126117ea565b6040805180820182525f8082526020808301829052858252600481528382206001600160a01b0386168352600190810190915292902081518154929391929091839160ff19169083600281111561056b5761056b6155ac565b021790555060208201518154829061ff001916610100836003811115610593576105936155ac565b021790555050604080518481526001600160a01b03841660208201527f3ccf62aacc3286173cedf5c20ec550071636a2faf0a3b28d93841736a43f822b9250015b60405180910390a15050565b6105e86117ea565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f52ae88b092de36f87fb43fe794eb1381023b9c1bce563a871154022c63dce3429190a35050565b61063f6117ea565b6040805180820190915280600281526020015f90525f8381526004602090815260408083206001600160a01b038616845260019081019092529091208251815491929091839160ff199091169083600281111561069e5761069e6155ac565b021790555060208201518154829061ff0019166101008360038111156106c6576106c66155ac565b021790555050604080518481526001600160a01b03841660208201527f277465b84f512b759d745fab70327b693ee21ce592fca91a3f491739a25fa76a9250016105d4565b6107136117ea565b60a082901c63ffffffff60401b16606084811b6001600160601b031916919091175f9081526006602090815260409182902080546001600160a01b0319166001600160a01b03868116918217909255835191881682526001600160e01b0319871692820192909252918201527f1330d96b64c7e86736f77e027ca34223dd3d1d08049281281c9d597d8098ed5991015b60405180910390a1505050565b5f60605f6107c2858b8b8b8b8b61181c565b90506107cd81611a77565b61080f8a8a8a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508c9250611bd0915050565b909350915083801561081f575082155b1561083d5760405163d27b44a960e01b815260040160405180910390fd5b6108478184611c5a565b5097509795505050505050565b5f60016001600160a01b0383161480159061088757506001600160a01b038281165f908152600360205260409020541615155b92915050565b335f9081526007602052604081205481906108ac90888888888861181c565b90506108b781611a77565b6108f9878787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250899250611d46915050565b91506109058183611c5a565b5095945050505050565b335f90815260076020526040812054606090829061093190898989898961181c565b905061093c81611a77565b61097e888888888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508a9250611bd0915050565b909350915061098d8184611c5a565b509550959350505050565b6109a06117ea565b6001600160a01b03811615806109bf57506001600160a01b0381166001145b156109e85780604051635c93ff2f60e11b81526004016109df9190614e02565b60405180910390fd5b6001600160a01b038181165f908152600360205260409020541615610a225780604051632061897360e01b81526004016109df9190614e02565b60036020525f80516020615efc83398151915280546001600160a01b038381165f81815260408082208054949095166001600160a01b03199485161790945560019052835490911617909155517fecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f844090610a9c908390614e02565b60405180910390a150565b610aaf6117ea565b5f83815260046020526040812060020190610aca8484611dc7565b81526020019081526020015f205f90557f32a3a599b308fc900a0e6513db2ad40bf0c94367da90048a4b308d8c6b2dd6ea8383836040516107a3939291909283526001600160a01b039190911660208301526001600160e01b031916604082015260600190565b335f908152600260209081526040808320848452825291829020805460ff1916600117905590518281527f89a77869d7b8125ba16e08a92ddc8cc26fb1fa47241971167954489a5e66c2559101610a9c565b610b8b6117ea565b610b945f611de7565b565b610b9e6117ea565b60405163783a904760e01b8152736a6af4b16458bc39817e4019fb02bd3b26d410499063783a904790610bd59085906004016155e4565b5f6040518083038186803b158015610beb575f80fd5b505af4158015610bfd573d5f803e3d5ffd5b5050505f868152600460205260409020610c239150610c1c8686611dc7565b8484611e57565b7f4f6c340456f64db31a3d003c1224ba1de058557b1cdf71f21ae48ce4a4f64f528585858585604051610c5a959493929190615691565b60405180910390a15050505050565b610c716117ea565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f90cc2f570a6eb594b1580ea3e41247d2d73a55281889e86bd4ec2fc29c7e62d6905f90a35050565b610cca6117ea565b604080518082019091528060018152602001826003811115610cee57610cee6155ac565b90525f8481526004602090815260408083206001600160a01b038716845260019081019092529091208251815491929091839160ff1990911690836002811115610d3a57610d3a6155ac565b021790555060208201518154829061ff001916610100836003811115610d6257610d626155ac565b02179055509050507f05e4ec9b54e94ad676ef61d57214f6d57d752ed2022dea5e5f956d5df7ccb2508383836040516107a39392919061575d565b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300546001600160a01b031690565b610dd36117ea565b6001600160a01b0382165f81815260076020908152604091829020849055815192835282018390527f60c85b61661a191efceebca036d48b290e04a1f08dd96472b920adbdd50c64e891016105d4565b610e2b6117ea565b828114610e4b576040516374f4d53760e01b815260040160405180910390fd5b5f5b61ffff8116841115610eea5782828261ffff16818110610e6f57610e6f615780565b9050602002016020810190610e849190615794565b60045f87878561ffff16818110610e9d57610e9d615780565b602090810292909201358352508181019290925260409081015f9081206001600160a01b038b1682529092529020805460ff1916911515919091179055610ee3816157c3565b9050610e4d565b50610ef485610854565b610f0157610f0185610998565b7f9f8368fa4ddcbd561efd7ad2a2174235bf5b840a73fb18f20db9705c114624988585858585604051610c5a9594939291906157e3565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a008054600160401b810460ff1615906001600160401b03165f81158015610f7c5750825b90505f826001600160401b03166001148015610f975750303b155b905081158015610fa5575080155b15610fc35760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff191660011785558315610fed57845460ff60401b1916600160401b1785555b5f805f888060200190518101906110049190615872565b92509250925061101383611de7565b5f80546001600160a01b038085166001600160a01b031992831617909255600180549284169290911691909117905561104a611f06565b816001600160a01b0316836001600160a01b0316336001600160a01b03167f34d3b96a088381c6843a1f9d94d251afa88f83cc7a0d17fc23a7057506a3fc6d846040516110979190614e02565b60405180910390a450505083156110e957845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2906020015b60405180910390a15b505050505050565b6110f96117ea565b836001600160801b03165f03611116576001600160801b03611118565b835b9350806001600160401b03165f036111305742611132565b805b90506040518060a00160405280846001600160801b03168152602001856001600160801b03168152602001836001600160401b03168152602001866001600160801b03168152602001826001600160401b031681525060055f8881526020019081526020015f205f820151815f015f6101000a8154816001600160801b0302191690836001600160801b031602179055506020820151815f0160106101000a8154816001600160801b0302191690836001600160801b031602179055506040820151816001015f6101000a8154816001600160401b0302191690836001600160401b0316021790555060608201518160010160086101000a8154816001600160801b0302191690836001600160801b0316021790555060808201518160010160186101000a8154816001600160401b0302191690836001600160401b031602179055509050507f63d7ec44a20b176da1d60d75259d264ee67b3d8213706afa71a28f69ed8ebece8686868686866040516110e0969594939291909586526001600160801b0394851660208701529284166040860152921660608401526001600160401b0391821660808401521660a082015260c00190565b6112f26117ea565b6112fb81611f71565b5f858152600460205260408120600201906113168686611dc7565b81526020019081526020015f20819055507f9603b65b11492fec54ccc3d9feb93536f804d82e12228187ff730a253fc283ee8484848460405161135c94939291906158b1565b60405180910390a150505050565b5f8061137a848a8a8a8a8a61181c565b905061138581611a77565b6113c7898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b9250611d46915050565b91508280156113d4575081155b156113f25760405163d27b44a960e01b815260040160405180910390fd5b6113fc8183611c5a565b50979650505050505050565b60605f6001600160a01b03841660011480159061142b575061142984610854565b155b1561144b5783604051635c93ff2f60e11b81526004016109df9190614e02565b825f0361146b576040516372dbed9760e11b815260040160405180910390fd5b826001600160401b0381111561148357611483614ffc565b6040519080825280602002602001820160405280156114ac578160200160208202803683370190505b506001600160a01b038086165f90815260036020526040812054929450911691505b6001600160a01b038216158015906114f057506001600160a01b038216600114155b80156114fb57508381105b15611555578183828151811061151357611513615780565b6001600160a01b039283166020918202929092018101919091529281165f9081526003909352604090922054909116908061154d816158e4565b9150506114ce565b6001600160a01b03821660011461158d57826115726001836158fc565b8151811061158257611582615780565b602002602001015191505b808352509250929050565b604080517f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218602082015246918101919091523060608201525f9081906080016040516020818303038152906040528051906020012090505f601960f81b600160f81b837f2939aeeda3ca260200c9f7b436b19e13207547ccc65cfedc857751c5ea6d91d45f1b898960405161162e92919061590f565b6040805191829003822060208301939093528101919091526060810188905260800160408051808303601f190181529082905280516020918201206001600160f81b0319958616918301919091529290931660218401526022830152604282015260620160408051601f198184030181529190528051602090910120925050505b9392505050565b6116be6117ea565b6001600160a01b03811615806116dd57506001600160a01b0381166001145b156116fd5780604051635c93ff2f60e11b81526004016109df9190614e02565b6001600160a01b038281165f9081526003602052604090205481169082161461173b5780604051638b4189ff60e01b81526004016109df9190614e02565b6001600160a01b038181165f81815260036020526040808220805487861684528284208054919096166001600160a01b0319918216179095559290915281549092169055517faab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace4054276906105d4908390614e02565b6117b56117ea565b6001600160a01b0381166117de575f604051631e4fbdf760e01b81526004016109df9190614e02565b6117e781611de7565b50565b336117f3610d9d565b6001600160a01b031614610b94573360405163118cdaa760e01b81526004016109df9190614e02565b335f908152600360205260409020546060906001600160a01b031661192c575f80611845611f94565b6001600160a01b038082165f90815260036020526040902054929450909250166118845733604051634a0bfec160e01b81526004016109df9190614e02565b6001600160a01b0381165f90815260026020908152604080832085845290915290205460ff16156118cb57604051639e1dc0c560e01b8152600481018390526024016109df565b6001600160a01b0381165f908152600260209081526040808320858452825291829020805460ff1916600117905590518381527f8c8e19e7e8e193118a05465d7676e82215052d3cb150628fbf598105dc2bb6ab910160405180910390a150505b5f87900361194d57604051631fb1d3e560e31b815260040160405180910390fd5b5f8781526004602052604081209081906119656120ef565b6001600160a01b0316815260208101919091526040015f205460ff1661199e57604051631fb1d3e560e31b815260040160405180910390fd5b5f6119e4886119ad878961591e565b60a01c63ffffffff60401b1660609190911b6001600160601b031916175f908152600660205260409020546001600160a01b031690565b90505f6119ef614ce1565b6001600160a01b038316611a1957611a0f848b8b8b8b8b875f015161214a565b9092509050611a2e565b611a2883858c8c8c8c8c612398565b90925090505b5f826013811115611a4157611a416155ac565b14611a66576020810151604051631a1537eb60e31b81526109df91849160040161594e565b5193505050505b9695505050505050565b80515f5b81811015611bcb575f838281518110611a9657611a96615780565b60209081029190910181015180516040808301515f83815260058652828120835160a08101855281546001600160801b038082168352600160801b90910481169882019890985260018201546001600160401b0380821696830196909652600160401b81049098166060820152600160c01b90970490931660808701529395509193919290918190611b2890426124dd565b9150915085602001516001600160801b0316826001600160801b031614611b5157611b5161596c565b816001600160801b0316846001600160801b03161115611b7357611b7361596c565b611b7d8483615980565b600193840180546001600160401b03938416600160c01b026001600160c01b036001600160801b0394909416600160401b029390931693169290921717905550939093019250611a7b915050565b505050565b600154604051635229073f60e01b81525f916060916001600160a01b0390911690635229073f90611c0b9089908990899089906004016159b0565b5f604051808303815f875af1158015611c26573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611c4d9190810190615a27565b9150915094509492505050565b81515f5b81811015611d40575f848281518110611c7957611c79615780565b602002602001015190505f815f015190508415611cf657604082015160208301517f90355d540c2980efb4c360996dfc5405ee87e812e4f3db843857547cbdb5af65918391611cc9908290615980565b604080519384526001600160801b03928316602085015291169082015260600160405180910390a1611d36565b6020808301515f8381526005909252604090912060010180546001600160801b03909216600160401b02600160401b600160c01b03199092169190911790555b5050600101611c5e565b50505050565b60015460405163468721a760e01b81525f916001600160a01b03169063468721a790611d7c9088908890889088906004016159b0565b6020604051808303815f875af1158015611d98573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611dbc9190615a6a565b90505b949350505050565b60a01c63ffffffff60401b1660609190911b6001600160601b0319161790565b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930080546001600160a01b031981166001600160a01b03848116918217845560405192169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a3505050565b604051634031b16960e11b81525f907361c5b1be435391fdd7bc6703f3740c0d11728a8c9063806362d290611e909086906004016155e4565b5f60405180830381865af4158015611eaa573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611ed19190810190615a85565b90505f611edd82612600565b9050611eeb84518483612719565b5f958652600290960160205250506040909220929092555050565b60015f5260036020525f80516020615efc833981519152546001600160a01b031615611f455760405163dfd49ebd60e01b815260040160405180910390fd5b60015f81905260036020525f80516020615efc83398151915280546001600160a01b0319169091179055565b5f600160d81b60e0836003811115611f8b57611f8b6155ac565b901b1792915050565b5f8080366065811015611fac57505f93849350915050565b5f805f611fb9858561274a565b919450925090505f611fcc6061866158fc565b90505f611fdb8683818a615ab6565b611fe491615add565b90508460ff165f0361206a57826004811080611fff57508281115b1561201557505f998a9950975050505050505050565b845f61202c61202684838c8e615ab6565b86611598565b905061204a82828c8c87908a9261204593929190615ab6565b6127c0565b612055575f80612058565b80825b9b509b50505050505050505050509091565b5f61208061207a84838a8c615ab6565b84611598565b604080515f81526020810180835283905260ff8916918101919091526060810187905260808101869052909150819060019060a0016020604051602081039080840390855afa1580156120d5573d5f803e3d5ffd5b505050602060405103519950995050505050505050509091565b335f908152600360205260408120546001600160a01b03161561211157503390565b5f61211a611f94565b6001600160a01b038082165f908152600360205260409020549193501615905061214357919050565b5f91505090565b5f612153614ce1565b84158015906121625750600485105b1561218057604051632342609160e11b815260040160405180910390fd5b60026001600160a01b0389165f90815260018b01602052604090205460ff1660028111156121b0576121b06155ac565b036122f2575f6121c9896121c4888a61591e565b611dc7565b5f81815260028c01602052604081205491925081900361221b57600360405180604001604052808781526020018a8a90612203919061591e565b6001600160e01b03191681525093509350505061238c565b5f80612226836128a2565b915091505f6122368c8a846128cc565b90505f81601381111561224b5761224b6155ac565b1461227257604080518082019091528881525f6020820152909650945061238c9350505050565b821561229e575f60405180604001604052808a81526020015f801b81525096509650505050505061238c565b505050506122e88a82898960405180608001604052808f6001600160a01b031681526020018e81526020018a81526020018b60018111156122e1576122e16155ac565b9052612980565b925092505061238c565b60016001600160a01b0389165f90815260018b01602052604090205460ff166002811115612322576123226155ac565b03612373576001600160a01b0388165f90815260018a0160205260409020546123569088908690610100900460ff166128cc565b604080518082019091528481525f6020820152909250905061238c565b5050604080518082019091528181525f60208201526002905b97509795505050505050565b5f6123a1614ce1565b60405163c7a7b63560e01b81526001600160a01b038a169063c7a7b635906123d5908a908a908a908a908a90600401615b22565b5f60405180830381865afa92505050801561241157506040513d5f823e601f3d908101601f1916820160405261240e9190810190615b58565b60015b61242e576040516315e649e960e01b815260040160405180910390fd5b5f5b81518110156124cf575f82828151811061244c5761244c615780565b602002602001015190505f816060015190505f82608001518261246f9190615c29565b905061249a8d846020015185604001518d8d8790879261249193929190615ab6565b88518c5161214a565b90975095505f8760138111156124b2576124b26155ac565b146124c157505050505061238c565b836001019350505050612430565b505097509795505050505050565b5f8083604001516001600160401b03165f148061251e5750836040015184608001516125099190615c3c565b6001600160401b0316836001600160401b0316105b15612534575050606082015160808301516125f9565b5f846040015185608001518561254a9190615c5c565b6125549190615c90565b905084602001516001600160801b031685606001516001600160801b031610156125cf57845161258e906001600160401b03831690615cb5565b856060015161259d9190615cd8565b925084602001516001600160801b0316836001600160801b0316106125c65784602001516125c8565b825b92506125d7565b846060015192505b60408501516125e69082615cf8565b85608001516125f59190615c3c565b9150505b9250929050565b5f8061260b836129eb565b905061266d818051602091820120604080516001600160f81b03198185015273ce0042b868300000d44a59004da54a005ffdcf9f60601b60218201525f6035820152605580820193909352815180820390930183526075019052805191012090565b9150813b5f8190036127125760405163257b1f8160e11b815273ce0042b868300000d44a59004da54a005ffdcf9f90634af63f02906126b29085905f90600401615d1b565b6020604051808303815f875af11580156126ce573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906126f29190615d3c565b6001600160a01b0316836001600160a01b0316146127125761271261596c565b5050919050565b5f6001600160a01b03821660e0846003811115612738576127386155ac565b60f087901b911b171790509392505050565b5f8080848461275a6001826158fc565b612765928290615ab6565b61276e91615d57565b60f81c925084846127806041826158fc565b61278b928290615ab6565b61279491615add565b915084846127a36021826158fc565b6127ae928290615ab6565b6127b791615add565b90509250925092565b5f843b8082036127d3575f915050611dbf565b5f866001600160a01b0316631626ba7e60e01b8787876040516024016127fb93929190615d85565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516128399190615d9e565b5f60405180830381855afa9150503d805f8114612871576040519150601f19603f3d011682016040523d82523d5f602084013e612876565b606091505b509150630b135d3f60e11b905061288c82615db9565b6001600160e01b03191614979650505050505050565b600160d81b811615155f60e083901c60ff1660038111156128c5576128c56155ac565b9050915091565b5f80841180156128ee575060018260038111156128eb576128eb6155ac565b14155b801561290c57506003826003811115612909576129096155ac565b14155b15612919575060046116af565b600183600181111561292d5761292d6155ac565b14801561294c57506002826003811115612949576129496155ac565b14155b801561296a57506003826003811115612967576129676155ac565b14155b15612977575060016116af565b505f9392505050565b5f612989614ce1565b5f806129958989612a23565b915091505f6129a5888885612bea565b90505f866040015151116129b957816129c7565b6129c7866040015183612c3f565b60408701526129d9888885848a612f65565b945094505050505b9550959350505050565b6060815160016129fb9190615c29565b82604051602001612a0d929190615df0565b6040516020818303038152906040529050919050565b612a4c6040805160808101909152805f81526020015f81525f6020820152606060409091015290565b5f82815260028401602052604081205460609160f082901c916001600160a01b031690612a788261320b565b90505f80612a868386613283565b915091505f805b8351811015612baa575f848281518110612aa957612aa9615780565b6020026020010151604001519050601c601f811115612aca57612aca6155ac565b81601f811115612adc57612adc6155ac565b10612af157612aea836158e4565b9250612ba1565b600f81601f811115612b0557612b056155ac565b03612ba1576010858381518110612b1e57612b1e615780565b602002602001015160400190601f811115612b3b57612b3b6155ac565b9081601f811115612b4e57612b4e6155ac565b9052505f54604051612b6c916001600160a01b031690602001614e02565b60405160208183030381529060405280519060200120848381518110612b9457612b94615780565b6020026020010181815250505b50600101612a8d565b50612bc08383612bb986613473565b5f8c6135b6565b875f8211612bce5787612bd9565b612bd984848461378c565b975097505050505050509250929050565b612c0c60405180606001604052805f81526020015f8152602001606081525090565b5f612c1683613972565b9050612c2d85856004848560200151515f88613afe565b505f8152602081019290925250919050565b606082515f03612c50575080610887565b81515f03612c5f575081610887565b81518351612c6d9190615c29565b6001600160401b03811115612c8457612c84614ffc565b604051908082528060200260200182016040528015612ccd57816020015b604080516060810182525f80825260208083018290529282015282525f19909201910181612ca25790505b5083519091505f5b81811015612dc357848181518110612cef57612cef615780565b60200260200101515f0151838281518110612d0c57612d0c615780565b60200260200101515f018181525050848181518110612d2d57612d2d615780565b602002602001015160200151838281518110612d4b57612d4b615780565b6020026020010151602001906001600160801b031690816001600160801b031681525050848181518110612d8157612d81615780565b602002602001015160400151838281518110612d9f57612d9f615780565b60209081029190910101516001600160801b03909116604090910152600101612cd5565b505f5b8351811015612f50575f80612df787878581518110612de757612de7615780565b60200260200101515f0151613ca9565b915091508015612e5a57858381518110612e1357612e13615780565b602002602001015160400151858381518110612e3157612e31615780565b6020026020010151604001818151612e499190615cd8565b6001600160801b0316905250612f46565b858381518110612e6c57612e6c615780565b60200260200101515f0151858581518110612e8957612e89615780565b60200260200101515f018181525050858381518110612eaa57612eaa615780565b602002602001015160200151858581518110612ec857612ec8615780565b6020026020010151602001906001600160801b031690816001600160801b031681525050858381518110612efe57612efe615780565b602002602001015160400151858581518110612f1c57612f1c615780565b60209081029190910101516001600160801b0390911660409091015283612f42816158e4565b9450505b5050600101612dc6565b508151811015612f5e578082525b5092915050565b5f612f6e614ce1565b6020850151601081601f811115612f8757612f876155ac565b10156130e1575f81601f811115612fa057612fa06155ac565b03612fc55750506040805180820182529083015181525f6020820181905291506129e1565b600581601f811115612fd957612fd96155ac565b03612ff557612feb8888888888613cfe565b92509250506129e1565b600181601f811115613009576130096155ac565b0361301b57612feb8888888888613e19565b600281601f81111561302f5761302f6155ac565b0361304157612feb8888888888613ee9565b600381601f811115613055576130556155ac565b0361306757612feb8888888888613f71565b600681601f81111561307b5761307b6155ac565b0361308d57612feb8888888888614019565b600781601f8111156130a1576130a16155ac565b036130b357612feb8888888888614110565b600881601f8111156130c7576130c76155ac565b146130d4576130d461596c565b612feb888888888861418f565b601281601f8111156130f5576130f56155ac565b11613127576131068888888861430a565b6040805180820182529086015181525f602082015290935091506129e19050565b601481601f81111561313b5761313b6155ac565b1161314c5761310688888888614411565b601581601f811115613160576131606155ac565b036131715761310688888888614493565b601681601f811115613185576131856155ac565b0361319757612feb888888888861456e565b601c81601f8111156131ab576131ab6155ac565b036131bd57612feb8888888888614653565b601d81601f8111156131d1576131d16155ac565b036131e057612feb868561468d565b601e81601f8111156131f4576131f46155ac565b146132015761320161596c565b612feb86856146d8565b6060813b6001811161321f5761321f61596c565b60015f61322c82846158fc565b9050806001600160401b0381111561324657613246614ffc565b6040519080825280601f01601f191660200182016040528015613270576020820181803683370190505b509350808260208601873c505050919050565b606080826001600160401b0381111561329e5761329e614ffc565b6040519080825280602002602001820160405280156132d757816020015b6132c4614cf8565b8152602001906001900390816132bc5790505b509150826001600160401b038111156132f2576132f2614ffc565b60405190808252806020026020018201604052801561331b578160200160208202803683370190505b5090505f60208161332d600287615e46565b613338906020615c29565b90505f5b8681101561346857878301519350613355600284615c29565b92505f8460f01c90505f87838151811061337157613371615780565b6020908102919091010151600883901c60ff1681529050600582901c60071660068111156133a1576133a16155ac565b816020019060068111156133b7576133b76155ac565b908160068111156133ca576133ca6155ac565b905250601f828116908111156133e2576133e26155ac565b8160400190601f8111156133f8576133f86155ac565b9081601f81111561340b5761340b6155ac565b90525060108160400151601f811115613426576134266155ac565b1061345e5789840151955061343c602085615c29565b93508587848151811061345157613451615780565b6020026020010181815250505b505060010161333c565b505050509250929050565b8051606090806134855761348561596c565b806001600160401b0381111561349d5761349d614ffc565b6040519080825280602002602001820160405280156134ef57816020015b6134dc60405180606001604052805f81526020015f81526020015f81525090565b8152602001906001900390816134bb5790505b5091505f19825f8151811061350657613506615780565b60209081029190910101515260015b81811015612712575f1983828151811061353157613531615780565b60200260200101515f0181815250505f8385838151811061355457613554615780565b60200260200101515f015160ff168151811061357257613572615780565b602002602001015190505f19815f01510361358b578181525b613596826001615c29565b6020820181905281516135a8916158fc565b604090910152600101613515565b5f8583815181106135c9576135c9615780565b602002602001015190508060200151825f019060068111156135ed576135ed6155ac565b90816006811115613600576136006155ac565b90525060408101516020830190601f81111561361e5761361e6155ac565b9081601f811115613631576136316155ac565b8152505084838151811061364757613647615780565b602002602001015182604001818152505083838151811061366a5761366a615780565b6020026020010151604001515f036136825750613785565b5f84848151811061369557613695615780565b60200260200101515f015190505f8585815181106136b5576136b5615780565b6020026020010151604001519050806001600160401b038111156136db576136db614ffc565b60405190808252806020026020018201604052801561373557816020015b6137226040805160808101909152805f81526020015f81525f6020820152606060409091015290565b8152602001906001900390816136f95790505b5060608501525f5b81811015613780576137788989896137558588615c29565b8960600151868151811061376b5761376b615780565b60200260200101516135b6565b60010161373d565b505050505b5050505050565b8251606090826001600160401b038111156137a9576137a9614ffc565b6040519080825280602002602001820160405280156137f257816020015b604080516060810182525f80825260208083018290529282015282525f199092019101816137c75790505b5091505f805b8281101561395c57601c87828151811061381457613814615780565b602002602001015160400151601f811115613831576138316155ac565b1061394c575f86828151811061384957613849615780565b602002602001015190505f61385e8683613ca9565b915050801561386e57505061394c565b8186858151811061388157613881615780565b602090810291909101810151919091525f83815260058252604090819020815160a08101835281546001600160801b038082168352600160801b9091048116948201949094526001909101546001600160401b0380821693830193909352600160401b81049093166060820152600160c01b90920416608082015261390690426124dd565b5086858151811061391957613919615780565b6020026020010151602001816001600160801b03166001600160801b0316815250508380613946906158e4565b94505050505b613955816158e4565b90506137f8565b5083811015613969578083525b50509392505050565b61397a614d20565b60018260200151601f811115613992576139926155ac565b101580156139b6575060038260200151601f8111156139b3576139b36155ac565b11155b156139f5575f826060015151116139cf576139cf61596c565b61088782606001515f815181106139e8576139e8615780565b6020026020010151613972565b815181906006811115613a0a57613a0a6155ac565b90816006811115613a1d57613a1d6155ac565b90525060608201515115613af9575f600483516006811115613a4157613a416155ac565b14613a5157826060015151613a54565b60015b9050806001600160401b03811115613a6e57613a6e614ffc565b604051908082528060200260200182016040528015613aa757816020015b613a94614d20565b815260200190600190039081613a8c5790505b5060208301525f5b8181101561271257613ad0846060015182815181106139e8576139e8615780565b83602001518281518110613ae657613ae6615780565b6020908102919091010152600101613aaf565b919050565b826001600160401b03811115613b1657613b16614ffc565b604051908082528060200260200182016040528015613b6957816020015b613b5660405180606001604052805f81526020015f8152602001606081525090565b815260200190600190039081613b345790505b5060408201525f8215613b9f57613b9c85602001515f81518110613b8f57613b8f615780565b6020026020010151614715565b90505b5f805b85811015613c9d5784613bcb57613bc887602001518281518110613b8f57613b8f615780565b92505b613c2a8a8a613bdd8d8d8d888a6147fb565b8a6020015189613bed5785613bef565b5f5b81518110613bff57613bff615780565b602002602001015188604001518681518110613c1d57613c1d615780565b6020026020010151614838565b5f84604001518281518110613c4157613c41615780565b602002602001015160200151905083613c6457613c5f816020615c29565b613c66565b805b85602001818151613c779190615c29565b90525083613c86576020613c88565b805b613c929084615c29565b925050600101613ba2565b50505050505050505050565b81515f908190815b81811015613cf15784868281518110613ccc57613ccc615780565b60200260200101515f015103613ce9579250600191506125f99050565b600101613cb1565b505f958695509350505050565b5f613d07614ce1565b60408084015182528401515160608601515114613d2757600a91506129e1565b5f5b856060015151811015613e0b57613dc4888888606001518481518110613d5157613d51615780565b602002602001015188604001518581518110613d6f57613d6f615780565b602002602001015160405180608001604052808a5f01516001600160a01b031681526020018a602001518152602001885f015181526020018a606001516001811115613dbd57613dbd6155ac565b9052612f65565b90935091505f836013811115613ddc57613ddc6155ac565b14613e035750604080518082018252908401518152602091820151918101919091526129e1565b600101613d29565b505f91509550959350505050565b5f613e22614ce1565b604083015181525f5b856060015151811015613e0b57613ea2888888606001518481518110613e5357613e53615780565b60200260200101518860405180608001604052808a5f01516001600160a01b031681526020018a602001518152602001885f015181526020018a606001516001811115613dbd57613dbd6155ac565b90935091505f836013811115613eba57613eba6155ac565b14613ee15750604080518082018252908401518152602091820151918101919091526129e1565b600101613e2b565b5f613ef2614ce1565b604083015181525f5b856060015151811015613f4e57613f23888888606001518481518110613e5357613e53615780565b90935091505f836013811115613f3b57613f3b6155ac565b03613f4657506129e1565b600101613efb565b50506040805180820182529201518252505f602082015260059590945092505050565b5f613f7a614ce1565b5f5b856060015151811015613ff657613fb3888888606001518481518110613fa457613fa4615780565b60200260200101518888612f65565b5092505f836013811115613fc957613fc96155ac565b03613fee5750506040805180820182529083015181525f6020820152600691506129e1565b600101613f7c565b50506040805180820182529201518252505f602082018190529590945092505050565b5f614022614ce1565b604083015181526060850151515f5b818110156140ec576140c0898989606001515f8151811061405457614054615780565b60200260200101518960400151858151811061407257614072615780565b602002602001015160405180608001604052808b5f01516001600160a01b031681526020018b602001518152602001895f015181526020018b606001516001811115613dbd57613dbd6155ac565b90945092505f8460138111156140d8576140d86155ac565b036140e45750506129e1565b600101614031565b5050604080518082018252930151835250505f6020820152600c9590945092505050565b5f614119614ce1565b604083015181525f5b846040015151811015613e0b5761414a888888606001515f81518110613d5157613d51615780565b90935091505f836013811115614162576141626155ac565b146141875750506040805180820182529083015181525f6020820152600b91506129e1565b600101614122565b5f614198614ce1565b60408084015182528401515115806141b95750846060015151846040015151115b156141c757600d91506129e1565b5f805b8560400151518110156142fb575f805b8860600151518110156142c0576001811b84165f036142b0575f8061427c8d8d8d60600151868151811061421057614210615780565b60200260200101518d60400151898151811061422e5761422e615780565b602002602001015160405180608001604052808f5f01516001600160a01b031681526020018f6020015181526020018d5f015181526020018f606001516001811115613dbd57613dbd6155ac565b90925090505f826013811115614294576142946155ac565b036142ad57955050600180821b949094179391506142c0565b50505b6142b9816158e4565b90506141da565b50806142ea5750506040805180820182529085015181525f6020820152600d935091506129e19050565b506142f4816158e4565b90506141ca565b505f9250509550959350505050565b602082015160408301515f919082601083601f81111561432c5761432c6155ac565b146143445761433f8888875f01516149d5565b61436e565b6143578888875f01518860200151614a0c565b60405161436592919061590f565b60405180910390205b9050601083601f811115614384576143846155ac565b1480156143915750818114155b156143a25760079350505050611dbf565b601183601f8111156143b6576143b66155ac565b1480156143c35750818111155b156143d45760089350505050611dbf565b601283601f8111156143e8576143e86155ac565b1480156143f55750818110155b156144065760099350505050611dbf565b5f9350505050611dbf565b6020820151604083015182515f929190839061443090899089906149d5565b9050601383601f811115614446576144466155ac565b1480156144535750818113155b156144645760089350505050611dbf565b601483601f811115614478576144786155ac565b1480156143f557508181126144065760099350505050611dbf565b60408201515f90816001855160068111156144b0576144b06155ac565b149050365f6144fc8989856144c65760206144c8565b5f5b89516144d79160ff1690615c29565b866144e35760206144e5565b5f5b60ff168a602001516144f791906158fc565b614a0c565b909250905060f084901c81811061451b57600e95505050505050611dbf565b6001600160881b0319601086901b8116608887901b82165f61453f8686818a615ab6565b61454891615add565b9050818382161461455a57600f61455c565b5f5b9e9d5050505050505050505050505050565b5f614577614ce1565b5f856040015160601c90505f86604001515f1c60a01b90505f80836001600160a01b031663b0acb980885f015189602001518e8e8c606001518e5f01518f602001518b6040518963ffffffff1660e01b81526004016145dd989796959493929190615e5d565b6040805180830381865afa1580156145f7573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061461b9190615ebc565b915091508161462b57601061462d565b5f5b604080518082018252980151885260208801919091529a95995094975050505050505050565b5f61465c614ce1565b5f61466b8888875f01516149d5565b5f1c905061467e81878660400151614a28565b92509250509550959350505050565b5f614696614ce1565b6146a98360200151858560400151614a28565b90925090505f8260138111156146c1576146c16155ac565b146146cd5760136146cf565b5f5b91509250929050565b5f6146e1614ce1565b6146f16001858560400151614a28565b90925090505f826013811115614709576147096155ac565b146146cd5760126146cf565b80515f90600181600681111561472d5761472d6155ac565b0361473b5750600192915050565b600281600681111561474f5761474f6155ac565b148061476c5750600481600681111561476a5761476a6155ac565b145b8061478857506005816006811115614786576147866155ac565b145b806147a4575060068160068111156147a2576147a26155ac565b145b156147b157505f92915050565b6020830151515f5b818110156147f0576147da85602001518281518110613b8f57613b8f615780565b6147e857505f949350505050565b6001016147b9565b506001949350505050565b5f806148078486615c29565b9050821561481657905061482f565b6148218787836149d5565b61482b9086615c29565b9150505b95945050505050565b8151600181600681111561484e5761484e6155ac565b0361485e576020828101526149cb565b6002816006811115614872576148726155ac565b0361489f5761488a6148858787876149d5565b614b5a565b614895906020615c29565b60208301526149cb565b60038160068111156148b3576148b36155ac565b036148d1576148cc868686868760200151515f88613afe565b6149cb565b60048160068111156148e5576148e56155ac565b036149295761490e86866148fa876020615c29565b866149068b8b8b6149d5565b600188613afe565b6020826020018181516149219190615c29565b9052506149cb565b600581600681111561493d5761493d6155ac565b148061495a57506006816006811115614958576149586155ac565b145b156149cb576149ac86866005846006811115614978576149786155ac565b14614983575f614986565b60045b60ff16614994886020615c29565b61499e9190615c29565b868760200151515f88613afe565b6149ba6148858787876149d5565b6149c5906020615c29565b60208301525b5091909152505050565b5f826149e2836020615c29565b1115614a0157604051631d098e2d60e21b815260040160405180910390fd5b509190910135919050565b365f858486614a1b8683615c29565b92611c4d93929190615ab6565b5f614a31614ce1565b5f80614a41858760400151613ca9565b9150915080614a5257614a5261596c565b848281518110614a6457614a64615780565b6020026020010151602001516001600160801b0316858381518110614a8b57614a8b615780565b6020026020010151604001516001600160801b031688614aab9190615c29565b1115614aef5760116040518060400160405280878152602001878581518110614ad657614ad6615780565b60200260200101515f0151815250935093505050614b52565b614af885614b88565b945086858381518110614b0d57614b0d615780565b6020026020010151604001818151614b259190615cd8565b6001600160801b031690525050604080518082019091528481525f6020820181905293509150614b529050565b935093915050565b5f60206001614b698483615c29565b614b7391906158fc565b614b7d9190615ee8565b610887906020615e46565b8051606090806001600160401b03811115614ba557614ba5614ffc565b604051908082528060200260200182016040528015614bee57816020015b604080516060810182525f80825260208083018290529282015282525f19909201910181614bc35790505b5091505f5b8181101561271257838181518110614c0d57614c0d615780565b60200260200101515f0151838281518110614c2a57614c2a615780565b60200260200101515f018181525050838181518110614c4b57614c4b615780565b602002602001015160200151838281518110614c6957614c69615780565b6020026020010151602001906001600160801b031690816001600160801b031681525050838181518110614c9f57614c9f615780565b602002602001015160400151838281518110614cbd57614cbd615780565b60209081029190910101516001600160801b03909116604090910152600101614bf3565b60408051808201909152606081525f602082015290565b60408051608081019091525f808252602082019081526020015f5b8152602001606081525090565b60408051808201909152805f614d13565b6001600160a01b03811681146117e7575f80fd5b5f8060408385031215614d56575f80fd5b823591506020830135614d6881614d31565b809150509250929050565b5f60208284031215614d83575f80fd5b81356116af81614d31565b80356001600160e01b031981168114613af9575f80fd5b5f805f60608486031215614db7575f80fd5b8335614dc281614d31565b9250614dd060208501614d8e565b91506040840135614de081614d31565b809150509250925092565b5f60208284031215614dfb575f80fd5b5035919050565b6001600160a01b0391909116815260200190565b5f8083601f840112614e26575f80fd5b5081356001600160401b03811115614e3c575f80fd5b6020830191508360208285010111156125f9575f80fd5b600281106117e7575f80fd5b80151581146117e7575f80fd5b5f805f805f805f60c0888a031215614e82575f80fd5b8735614e8d81614d31565b96506020880135955060408801356001600160401b03811115614eae575f80fd5b614eba8a828b01614e16565b9096509450506060880135614ece81614e53565b92506080880135915060a0880135614ee581614e5f565b8091505092959891949750929550565b5f5b83811015614f0f578181015183820152602001614ef7565b50505f910152565b5f8151808452614f2e816020860160208601614ef5565b601f01601f19169290920160200192915050565b8215158152604060208201525f611dbf6040830184614f17565b5f805f805f60808688031215614f70575f80fd5b8535614f7b81614d31565b94506020860135935060408601356001600160401b03811115614f9c575f80fd5b614fa888828901614e16565b9094509250506060860135614fbc81614e53565b809150509295509295909350565b5f805f60608486031215614fdc575f80fd5b833592506020840135614fee81614d31565b91506127b760408501614d8e565b634e487b7160e01b5f52604160045260245ffd5b604051608081016001600160401b038111828210171561503257615032614ffc565b60405290565b60405160a081016001600160401b038111828210171561503257615032614ffc565b604051601f8201601f191681016001600160401b038111828210171561508257615082614ffc565b604052919050565b5f6001600160401b038211156150a2576150a2614ffc565b5060051b60200190565b803560208110613af9575f80fd5b5f6001600160401b038211156150d2576150d2614ffc565b50601f01601f191660200190565b5f82601f8301126150ef575f80fd5b81356151026150fd826150ba565b61505a565b818152846020838601011115615116575f80fd5b816020850160208301375f918101602001919091529392505050565b803560048110613af9575f80fd5b5f805f805f60a08688031215615154575f80fd5b853594506151656020870135614d31565b6020860135935061517860408701614d8e565b92506001600160401b0360608701351115615191575f80fd5b6060860135860187601f8201126151a6575f80fd5b6151b36150fd823561508a565b81358082526020808301929160051b8401018a8111156151d1575f80fd5b602084015b81811015615293576001600160401b03813511156151f2575f80fd5b803585016080818e03601f19011215615209575f80fd5b615211615010565b602082013560ff811614615223575f80fd5b60208201358152600760408301351061523a575f80fd5b60408201356020820152615250606083016150ac565b60408201526001600160401b036080830135111561526c575f80fd5b61527f8e602060808501358501016150e0565b6060820152855250602093840193016151d6565b50508094505050506152a760808701615132565b90509295509295909350565b5f805f606084860312156152c5575f80fd5b8335925060208401356152d781614d31565b91506127b760408501615132565b5f80604083850312156152f6575f80fd5b823561530181614d31565b946020939093013593505050565b5f8083601f84011261531f575f80fd5b5081356001600160401b03811115615335575f80fd5b6020830191508360208260051b85010111156125f9575f80fd5b5f805f805f60608688031215615363575f80fd5b853561536e81614d31565b945060208601356001600160401b0380821115615389575f80fd5b61539589838a0161530f565b909650945060408801359150808211156153ad575f80fd5b506153ba8882890161530f565b969995985093965092949392505050565b5f602082840312156153db575f80fd5b81356001600160401b038111156153f0575f80fd5b611dbf848285016150e0565b80356001600160801b0381168114613af9575f80fd5b80356001600160401b0381168114613af9575f80fd5b5f805f805f8060c0878903121561543d575f80fd5b8635955061544d602088016153fc565b945061545b604088016153fc565b9350615469606088016153fc565b925061547760808801615412565b915061548560a08801615412565b90509295509295509295565b5f805f80608085870312156154a4575f80fd5b8435935060208501356154b681614d31565b92506154c460408601614d8e565b91506154d260608601615132565b905092959194509250565b604080825283519082018190525f906020906060840190828701845b8281101561551e5781516001600160a01b0316845292840192908401906001016154f9565b5050506001600160a01b039490941692019190915250919050565b5f805f6040848603121561554b575f80fd5b83356001600160401b03811115615560575f80fd5b61556c86828701614e16565b909790965060209590950135949350505050565b5f8060408385031215615591575f80fd5b823561559c81614d31565b91506020830135614d6881614d31565b634e487b7160e01b5f52602160045260245ffd5b600781106155d0576155d06155ac565b9052565b602081106155d0576155d06155ac565b5f6020808301818452808551808352604092508286019150828160051b8701018488015f5b8381101561567357603f198984030185528151608060ff8251168552888201516156358a8701826155c0565b5087820151615646898701826155d4565b5060609182015191850181905261565f85820183614f17565b968901969450505090860190600101615609565b509098975050505050505050565b600481106155d0576155d06155ac565b5f60a08201878352602060018060a01b03881681850152604063ffffffff60e01b881681860152606060a08187015283885180865260c08801915060c08160051b8901019550848a015f5b828110156157455760bf198a89030184528151608060ff8251168a52888201516157088a8c01826155c0565b5087820151615719898c01826155d4565b5086820151915080878b0152615731818b0183614f17565b9950505092860192908601906001016156dc565b5050505050505080915050611a6d6080830184615681565b8381526001600160a01b038316602082015260608101611dbf6040830184615681565b634e487b7160e01b5f52603260045260245ffd5b5f602082840312156157a4575f80fd5b81356116af81614e5f565b634e487b7160e01b5f52601160045260245ffd5b5f61ffff8083168181036157d9576157d96157af565b6001019392505050565b6001600160a01b0386168152606060208083018290529082018590525f906001600160fb1b03861115615814575f80fd5b8560051b80886080860137830183810360809081016040860152810185905285905f9060a0015b8682101561586457823561584e81614e5f565b151581529183019160019190910190830161583b565b9a9950505050505050505050565b5f805f60608486031215615884575f80fd5b835161588f81614d31565b60208501519093506158a081614d31565b6040850151909250614de081614d31565b8481526001600160a01b03841660208201526001600160e01b0319831660408201526080810161482f6060830184615681565b5f600182016158f5576158f56157af565b5060010190565b81810381811115610887576108876157af565b818382375f9101908152919050565b6001600160e01b031981358181169160048510156159465780818660040360031b1b83161692505b505092915050565b6040810160148410615962576159626155ac565b9281526020015290565b634e487b7160e01b5f52600160045260245ffd5b6001600160801b03828116828216039080821115612f5e57612f5e6157af565b600281106155d0576155d06155ac565b60018060a01b0385168152836020820152608060408201525f6159d66080830185614f17565b905061482f60608301846159a0565b5f82601f8301126159f4575f80fd5b8151615a026150fd826150ba565b818152846020838601011115615a16575f80fd5b611dbf826020830160208701614ef5565b5f8060408385031215615a38575f80fd5b8251615a4381614e5f565b60208401519092506001600160401b03811115615a5e575f80fd5b6125f5858286016159e5565b5f60208284031215615a7a575f80fd5b81516116af81614e5f565b5f60208284031215615a95575f80fd5b81516001600160401b03811115615aaa575f80fd5b611dbf848285016159e5565b5f8085851115615ac4575f80fd5b83861115615ad0575f80fd5b5050820193919092039150565b80356020831015610887575f19602084900360031b1b1692915050565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b60018060a01b0386168152846020820152608060408201525f615b49608083018587615afa565b9050611a6d60608301846159a0565b5f6020808385031215615b69575f80fd5b82516001600160401b03811115615b7e575f80fd5b8301601f81018513615b8e575f80fd5b8051615b9c6150fd8261508a565b81815260a09182028301840191848201919088841115615bba575f80fd5b938501935b838510156113fc5780858a031215615bd6575f8081fd5b615bde615038565b8551615be981614e53565b815285870151615bf881614d31565b8188015260408681015190820152606080870151908201526080808701519082015283529384019391850191615bbf565b80820180821115610887576108876157af565b6001600160401b03818116838216019080821115612f5e57612f5e6157af565b6001600160401b03828116828216039080821115612f5e57612f5e6157af565b634e487b7160e01b5f52601260045260245ffd5b5f6001600160401b0380841680615ca957615ca9615c7c565b92169190910492915050565b6001600160801b03818116838216028082169190828114615946576159466157af565b6001600160801b03818116838216019080821115612f5e57612f5e6157af565b6001600160401b03818116838216028082169190828114615946576159466157af565b604081525f615d2d6040830185614f17565b90508260208301529392505050565b5f60208284031215615d4c575f80fd5b81516116af81614d31565b6001600160f81b031981358181169160018510156159465760019490940360031b84901b1690921692915050565b838152604060208201525f611dbc604083018486615afa565b5f8251615daf818460208701614ef5565b9190910192915050565b805160208201516001600160e01b03198082169291906004831015615de85780818460040360031b1b83161693505b505050919050565b606360f81b815260e083901b6001600160e01b03191660018201526880600e6000396000f360b81b60058201525f600e82018190528251615e3881600f850160208701614ef5565b91909101600f019392505050565b8082028115828204841417610887576108876157af565b60018060a01b038916815287602082015260e060408201525f615e8460e08301888a615afa565b9050615e9360608301876159a0565b608082019490945260a08101929092526001600160a01b03191660c09091015295945050505050565b5f8060408385031215615ecd575f80fd5b8251615ed881614e5f565b6020939093015192949293505050565b5f82615ef657615ef6615c7c565b50049056fea15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054ca2646970667358221220effee86583e9a9dfea71c1020808e6a7f1ab205668c8679fce5a2d2485ca407b64736f6c63430008150033",
      "constructorArgs": {
        "types": [
          "address",
          "address",
          "address"
        ],
        "values": [
          "0x0000000000000000000000000000000000000001",
          "0x0000000000000000000000000000000000000001",
          "0x0000000000000000000000000000000000000001"
        ]
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_avatar",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_target",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "AlreadyDisabledModule",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "AlreadyEnabledModule",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ArraysDifferentLength",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "CalldataOutOfBounds",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "enum PermissionChecker.Status",
              "name": "status",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "info",
              "type": "bytes32"
            }
          ],
          "name": "ConditionViolation",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "FunctionSignatureTooShort",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "HashAlreadyConsumed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidInitialization",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "InvalidModule",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidPageSize",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "MalformedMultiEntrypoint",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ModuleTransactionFailed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NoMembership",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            }
          ],
          "name": "NotAuthorized",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotInitializing",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            }
          ],
          "name": "OwnableInvalidOwner",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "name": "OwnableUnauthorizedAccount",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SetupModulesAlreadyCalled",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "indexed": false,
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "AllowFunction",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "AllowTarget",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes32[]",
              "name": "roleKeys",
              "type": "bytes32[]"
            },
            {
              "indexed": false,
              "internalType": "bool[]",
              "name": "memberOf",
              "type": "bool[]"
            }
          ],
          "name": "AssignRoles",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousAvatar",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newAvatar",
              "type": "address"
            }
          ],
          "name": "AvatarSet",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "allowanceKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "consumed",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "newBalance",
              "type": "uint128"
            }
          ],
          "name": "ConsumeAllowance",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "DisabledModule",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "EnabledModule",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "ExecutionFromModuleFailure",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "ExecutionFromModuleSuccess",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "HashExecuted",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "HashInvalidated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "version",
              "type": "uint64"
            }
          ],
          "name": "Initialized",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousOwner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "OwnershipTransferred",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            }
          ],
          "name": "RevokeFunction",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "RevokeTarget",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "initiator",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "avatar",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "target",
              "type": "address"
            }
          ],
          "name": "RolesModSetup",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "parent",
                  "type": "uint8"
                },
                {
                  "internalType": "enum ParameterType",
                  "name": "paramType",
                  "type": "uint8"
                },
                {
                  "internalType": "enum Operator",
                  "name": "operator",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes",
                  "name": "compValue",
                  "type": "bytes"
                }
              ],
              "indexed": false,
              "internalType": "struct ConditionFlat[]",
              "name": "conditions",
              "type": "tuple[]"
            },
            {
              "indexed": false,
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "ScopeFunction",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "ScopeTarget",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "allowanceKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "name": "SetAllowance",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "defaultRoleKey",
              "type": "bytes32"
            }
          ],
          "name": "SetDefaultRole",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "indexed": false,
              "internalType": "contract ITransactionUnwrapper",
              "name": "adapter",
              "type": "address"
            }
          ],
          "name": "SetUnwrapAdapter",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousTarget",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newTarget",
              "type": "address"
            }
          ],
          "name": "TargetSet",
          "type": "event"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "allowFunction",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "allowTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "allowances",
          "outputs": [
            {
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes32[]",
              "name": "roleKeys",
              "type": "bytes32[]"
            },
            {
              "internalType": "bool[]",
              "name": "memberOf",
              "type": "bool[]"
            }
          ],
          "name": "assignRoles",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "avatar",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "consumed",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "defaultRoles",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "prevModule",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "disableModule",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "enableModule",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Enum.Operation",
              "name": "operation",
              "type": "uint8"
            }
          ],
          "name": "execTransactionFromModule",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Enum.Operation",
              "name": "operation",
              "type": "uint8"
            }
          ],
          "name": "execTransactionFromModuleReturnData",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Enum.Operation",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "bool",
              "name": "shouldRevert",
              "type": "bool"
            }
          ],
          "name": "execTransactionWithRole",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Enum.Operation",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "bool",
              "name": "shouldRevert",
              "type": "bool"
            }
          ],
          "name": "execTransactionWithRoleReturnData",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "start",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "pageSize",
              "type": "uint256"
            }
          ],
          "name": "getModulesPaginated",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "array",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "next",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "hash",
              "type": "bytes32"
            }
          ],
          "name": "invalidate",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_module",
              "type": "address"
            }
          ],
          "name": "isModuleEnabled",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "salt",
              "type": "bytes32"
            }
          ],
          "name": "moduleTxHash",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "renounceOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            }
          ],
          "name": "revokeFunction",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "revokeTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "parent",
                  "type": "uint8"
                },
                {
                  "internalType": "enum ParameterType",
                  "name": "paramType",
                  "type": "uint8"
                },
                {
                  "internalType": "enum Operator",
                  "name": "operator",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes",
                  "name": "compValue",
                  "type": "bytes"
                }
              ],
              "internalType": "struct ConditionFlat[]",
              "name": "conditions",
              "type": "tuple[]"
            },
            {
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "scopeFunction",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "scopeTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "key",
              "type": "bytes32"
            },
            {
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "name": "setAllowance",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_avatar",
              "type": "address"
            }
          ],
          "name": "setAvatar",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            }
          ],
          "name": "setDefaultRole",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_target",
              "type": "address"
            }
          ],
          "name": "setTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "internalType": "contract ITransactionUnwrapper",
              "name": "adapter",
              "type": "address"
            }
          ],
          "name": "setTransactionUnwrapper",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "initParams",
              "type": "bytes"
            }
          ],
          "name": "setUp",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "target",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "transferOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "unwrappers",
          "outputs": [
            {
              "internalType": "contract ITransactionUnwrapper",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/core/Modifier.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport {ExecutionTracker} from \"../signature/ExecutionTracker.sol\";\nimport {IAvatar} from \"../interfaces/IAvatar.sol\";\nimport {Module} from \"./Module.sol\";\nimport {SignatureChecker} from \"../signature/SignatureChecker.sol\";\n\n/// @title Modifier Interface - A contract that sits between a Module and an Avatar and enforce some additional logic.\nabstract contract Modifier is\n  Module,\n  ExecutionTracker,\n  SignatureChecker,\n  IAvatar\n{\n  address internal constant SENTINEL_MODULES = address(0x1);\n  /// Mapping of modules.\n  mapping(address => address) internal modules;\n\n  /// `sender` is not an authorized module.\n  /// @param sender The address of the sender.\n  error NotAuthorized(address sender);\n\n  /// `module` is invalid.\n  error InvalidModule(address module);\n\n  /// `pageSize` is invalid.\n  error InvalidPageSize();\n\n  /// `module` is already disabled.\n  error AlreadyDisabledModule(address module);\n\n  /// `module` is already enabled.\n  error AlreadyEnabledModule(address module);\n\n  /// @dev `setModules()` was already called.\n  error SetupModulesAlreadyCalled();\n\n  /*\n    --------------------------------------------------\n    You must override both of the following virtual functions,\n    execTransactionFromModule() and execTransactionFromModuleReturnData().\n    It is recommended that implementations of both functions make use the \n    onlyModule modifier.\n    */\n\n  /// @dev Passes a transaction to the modifier.\n  /// @notice Can only be called by enabled modules.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction.\n  function execTransactionFromModule(\n    address to,\n    uint256 value,\n    bytes calldata data,\n    Enum.Operation operation\n  ) public virtual returns (bool success);\n\n  /// @dev Passes a transaction to the modifier, expects return data.\n  /// @notice Can only be called by enabled modules.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction.\n  function execTransactionFromModuleReturnData(\n    address to,\n    uint256 value,\n    bytes calldata data,\n    Enum.Operation operation\n  ) public virtual returns (bool success, bytes memory returnData);\n\n  /*\n    --------------------------------------------------\n    */\n\n  modifier moduleOnly() {\n    if (modules[msg.sender] == address(0)) {\n      (bytes32 hash, address signer) = moduleTxSignedBy();\n\n      // is the signer a module?\n      if (modules[signer] == address(0)) {\n        revert NotAuthorized(msg.sender);\n      }\n\n      // is the provided signature fresh?\n      if (consumed[signer][hash]) {\n        revert HashAlreadyConsumed(hash);\n      }\n\n      consumed[signer][hash] = true;\n      emit HashExecuted(hash);\n    }\n\n    _;\n  }\n\n  function sentOrSignedByModule() internal view returns (address) {\n    if (modules[msg.sender] != address(0)) {\n      return msg.sender;\n    }\n\n    (, address signer) = moduleTxSignedBy();\n    if (modules[signer] != address(0)) {\n      return signer;\n    }\n\n    return address(0);\n  }\n\n  /// @dev Disables a module on the modifier.\n  /// @notice This can only be called by the owner.\n  /// @param prevModule Module that pointed to the module to be removed in the linked list.\n  /// @param module Module to be removed.\n  function disableModule(\n    address prevModule,\n    address module\n  ) public override onlyOwner {\n    if (module == address(0) || module == SENTINEL_MODULES)\n      revert InvalidModule(module);\n    if (modules[prevModule] != module) revert AlreadyDisabledModule(module);\n    modules[prevModule] = modules[module];\n    modules[module] = address(0);\n    emit DisabledModule(module);\n  }\n\n  /// @dev Enables a module that can add transactions to the queue\n  /// @param module Address of the module to be enabled\n  /// @notice This can only be called by the owner\n  function enableModule(address module) public override onlyOwner {\n    if (module == address(0) || module == SENTINEL_MODULES)\n      revert InvalidModule(module);\n    if (modules[module] != address(0)) revert AlreadyEnabledModule(module);\n    modules[module] = modules[SENTINEL_MODULES];\n    modules[SENTINEL_MODULES] = module;\n    emit EnabledModule(module);\n  }\n\n  /// @dev Returns if an module is enabled\n  /// @return True if the module is enabled\n  function isModuleEnabled(\n    address _module\n  ) public view override returns (bool) {\n    return SENTINEL_MODULES != _module && modules[_module] != address(0);\n  }\n\n  /// @dev Returns array of modules.\n  ///      If all entries fit into a single page, the next pointer will be 0x1.\n  ///      If another page is present, next will be the last element of the returned array.\n  /// @param start Start of the page. Has to be a module or start pointer (0x1 address)\n  /// @param pageSize Maximum number of modules that should be returned. Has to be > 0\n  /// @return array Array of modules.\n  /// @return next Start of the next page.\n  function getModulesPaginated(\n    address start,\n    uint256 pageSize\n  ) external view override returns (address[] memory array, address next) {\n    if (start != SENTINEL_MODULES && !isModuleEnabled(start)) {\n      revert InvalidModule(start);\n    }\n    if (pageSize == 0) {\n      revert InvalidPageSize();\n    }\n\n    // Init array with max page size\n    array = new address[](pageSize);\n\n    // Populate return array\n    uint256 moduleCount = 0;\n    next = modules[start];\n    while (\n      next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize\n    ) {\n      array[moduleCount] = next;\n      next = modules[next];\n      moduleCount++;\n    }\n\n    // Because of the argument validation we can assume that\n    // the `currentModule` will always be either a module address\n    // or sentinel address (aka the end). If we haven't reached the end\n    // inside the loop, we need to set the next pointer to the last element\n    // because it skipped over to the next module which is neither included\n    // in the current page nor won't be included in the next one\n    // if you pass it as a start.\n    if (next != SENTINEL_MODULES) {\n      next = array[moduleCount - 1];\n    }\n    // Set correct size of returned array\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      mstore(array, moduleCount)\n    }\n  }\n\n  /// @dev Initializes the modules linked list.\n  /// @notice Should be called as part of the `setUp` / initializing function and can only be called once.\n  function setupModules() internal {\n    if (modules[SENTINEL_MODULES] != address(0))\n      revert SetupModulesAlreadyCalled();\n    modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n  }\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/core/Module.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\nimport {FactoryFriendly} from \"../factory/FactoryFriendly.sol\";\nimport {IAvatar} from \"../interfaces/IAvatar.sol\";\n\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\nabstract contract Module is FactoryFriendly {\n  /// @dev Address that will ultimately execute function calls.\n  address public avatar;\n  /// @dev Address that this module will pass transactions to.\n  address public target;\n\n  /// @dev Emitted each time the avatar is set.\n  event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\n  /// @dev Emitted each time the Target is set.\n  event TargetSet(address indexed previousTarget, address indexed newTarget);\n\n  /// @dev Sets the avatar to a new avatar (`newAvatar`).\n  /// @notice Can only be called by the current owner.\n  function setAvatar(address _avatar) public onlyOwner {\n    address previousAvatar = avatar;\n    avatar = _avatar;\n    emit AvatarSet(previousAvatar, _avatar);\n  }\n\n  /// @dev Sets the target to a new target (`newTarget`).\n  /// @notice Can only be called by the current owner.\n  function setTarget(address _target) public onlyOwner {\n    address previousTarget = target;\n    target = _target;\n    emit TargetSet(previousTarget, _target);\n  }\n\n  /// @dev Passes a transaction to be executed by the avatar.\n  /// @notice Can only be called by this contract.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function exec(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) internal virtual returns (bool success) {\n    return\n      IAvatar(target).execTransactionFromModule(to, value, data, operation);\n  }\n\n  /// @dev Passes a transaction to be executed by the target and returns data.\n  /// @notice Can only be called by this contract.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execAndReturnData(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) internal virtual returns (bool success, bytes memory returnData) {\n    return\n      IAvatar(target).execTransactionFromModuleReturnData(\n        to,\n        value,\n        data,\n        operation\n      );\n  }\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\npragma solidity >=0.7.0 <0.9.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract FactoryFriendly is OwnableUpgradeable {\n  function setUp(bytes memory initializeParams) public virtual;\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n  event EnabledModule(address module);\n  event DisabledModule(address module);\n  event ExecutionFromModuleSuccess(address indexed module);\n  event ExecutionFromModuleFailure(address indexed module);\n\n  /// @dev Enables a module on the avatar.\n  /// @notice Can only be called by the avatar.\n  /// @notice Modules should be stored as a linked list.\n  /// @notice Must emit EnabledModule(address module) if successful.\n  /// @param module Module to be enabled.\n  function enableModule(address module) external;\n\n  /// @dev Disables a module on the avatar.\n  /// @notice Can only be called by the avatar.\n  /// @notice Must emit DisabledModule(address module) if successful.\n  /// @param prevModule Address that pointed to the module to be removed in the linked list\n  /// @param module Module to be removed.\n  function disableModule(address prevModule, address module) external;\n\n  /// @dev Allows a Module to execute a transaction.\n  /// @notice Can only be called by an enabled module.\n  /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n  /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execTransactionFromModule(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) external returns (bool success);\n\n  /// @dev Allows a Module to execute a transaction and return data\n  /// @notice Can only be called by an enabled module.\n  /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n  /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execTransactionFromModuleReturnData(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Enum.Operation operation\n  ) external returns (bool success, bytes memory returnData);\n\n  /// @dev Returns if an module is enabled\n  /// @return True if the module is enabled\n  function isModuleEnabled(address module) external view returns (bool);\n\n  /// @dev Returns array of modules.\n  /// @param start Start of the page.\n  /// @param pageSize Maximum number of modules that should be returned.\n  /// @return array Array of modules.\n  /// @return next Start of the next page.\n  function getModulesPaginated(\n    address start,\n    uint256 pageSize\n  ) external view returns (address[] memory array, address next);\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/signature/ExecutionTracker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n/// @title ExecutionTracker - A contract that keeps track of executed and invalidated hashes\ncontract ExecutionTracker {\n  error HashAlreadyConsumed(bytes32);\n\n  event HashExecuted(bytes32);\n  event HashInvalidated(bytes32);\n\n  mapping(address => mapping(bytes32 => bool)) public consumed;\n\n  function invalidate(bytes32 hash) external {\n    consumed[msg.sender][hash] = true;\n    emit HashInvalidated(hash);\n  }\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/signature/IERC1271.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC1271 {\n  /**\n   * @notice EIP1271 method to validate a signature.\n   * @param hash Hash of the data signed on the behalf of address(this).\n   * @param signature Signature byte array associated with _data.\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */\n  function isValidSignature(\n    bytes32 hash,\n    bytes memory signature\n  ) external view returns (bytes4);\n}\n"
          },
          "@gnosis.pm/zodiac/contracts/signature/SignatureChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IERC1271} from \"./IERC1271.sol\";\n\n/// @title SignatureChecker - A contract that retrieves and validates signatures appended to transaction calldata.\n/// @dev currently supports eip-712 and eip-1271 signatures\nabstract contract SignatureChecker {\n  /**\n   * @notice Searches for a signature, validates it, and returns the signer's address.\n   * @dev When signature not found or invalid, zero address is returned\n   * @return The address of the signer.\n   */\n  function moduleTxSignedBy() internal view returns (bytes32, address) {\n    bytes calldata data = msg.data;\n\n    /*\n     * The idea is to extend `onlyModule` and provide signature checking\n     * without code changes to inheriting contracts (Modifiers).\n     *\n     * Since it's a generic mechanism, there is no way to conclusively\n     * identify the trailing bytes as a signature. We simply slice those\n     * and recover signer.\n     *\n     * As a result, we impose a minimum calldata length equal to a function\n     * selector plus salt, plus a signature (i.e., 4 + 32 + 65 bytes), any\n     * shorter and calldata it guaranteed to not contain a signature.\n     */\n    if (data.length < 4 + 32 + 65) {\n      return (bytes32(0), address(0));\n    }\n\n    (uint8 v, bytes32 r, bytes32 s) = _splitSignature(data);\n\n    uint256 end = data.length - (32 + 65);\n    bytes32 salt = bytes32(data[end:]);\n\n    /*\n     * When handling contract signatures:\n     *  v - is zero\n     *  r - contains the signer\n     *  s - contains the offset within calldata where the signer specific\n     *      signature is located\n     *\n     * We detect contract signatures by checking:\n     *  1- `v` is zero\n     *  2- `s` points within the buffer, is after selector, is before\n     *      salt and delimits a non-zero length buffer\n     */\n    if (v == 0) {\n      uint256 start = uint256(s);\n      if (start < 4 || start > end) {\n        return (bytes32(0), address(0));\n      }\n      address signer = address(uint160(uint256(r)));\n\n      bytes32 hash = moduleTxHash(data[:start], salt);\n      return\n        _isValidContractSignature(signer, hash, data[start:end])\n          ? (hash, signer)\n          : (bytes32(0), address(0));\n    } else {\n      bytes32 hash = moduleTxHash(data[:end], salt);\n      return (hash, ecrecover(hash, v, r, s));\n    }\n  }\n\n  /**\n   * @notice Hashes the transaction EIP-712 data structure.\n   * @dev The produced hash is intended to be signed.\n   * @param data The current transaction's calldata.\n   * @param salt The salt value.\n   * @return The 32-byte hash that is to be signed.\n   */\n  function moduleTxHash(\n    bytes calldata data,\n    bytes32 salt\n  ) public view returns (bytes32) {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this)\n    );\n    bytes memory moduleTxData = abi.encodePacked(\n      bytes1(0x19),\n      bytes1(0x01),\n      domainSeparator,\n      keccak256(abi.encode(MODULE_TX_TYPEHASH, keccak256(data), salt))\n    );\n    return keccak256(moduleTxData);\n  }\n\n  /**\n   * @dev Extracts signature from calldata, and divides it into `uint8 v, bytes32 r, bytes32 s`.\n   * @param data The current transaction's calldata.\n   * @return v The ECDSA v value\n   * @return r The ECDSA r value\n   * @return s The ECDSA s value\n   */\n  function _splitSignature(\n    bytes calldata data\n  ) private pure returns (uint8 v, bytes32 r, bytes32 s) {\n    v = uint8(bytes1(data[data.length - 1:]));\n    r = bytes32(data[data.length - 65:]);\n    s = bytes32(data[data.length - 33:]);\n  }\n\n  /**\n   * @dev Calls the signer contract, and validates the contract signature.\n   * @param signer The address of the signer contract.\n   * @param hash Hash of the data signed\n   * @param signature The contract signature.\n   * @return result Indicates whether the signature is valid.\n   */\n  function _isValidContractSignature(\n    address signer,\n    bytes32 hash,\n    bytes calldata signature\n  ) internal view returns (bool result) {\n    uint256 size;\n    // eslint-disable-line no-inline-assembly\n    assembly {\n      size := extcodesize(signer)\n    }\n    if (size == 0) {\n      return false;\n    }\n\n    (, bytes memory returnData) = signer.staticcall(\n      abi.encodeWithSelector(\n        IERC1271.isValidSignature.selector,\n        hash,\n        signature\n      )\n    );\n\n    return bytes4(returnData) == EIP1271_MAGIC_VALUE;\n  }\n\n  // keccak256(\n  //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n  // );\n  bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n    0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n  // keccak256(\n  //     \"ModuleTx(bytes data,bytes32 salt)\"\n  // );\n  bytes32 private constant MODULE_TX_TYPEHASH =\n    0x2939aeeda3ca260200c9f7b436b19e13207547ccc65cfedc857751c5ea6d91d4;\n\n  // bytes4(keccak256(\n  //     \"isValidSignature(bytes32,bytes)\"\n  // ));\n  bytes4 private constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
          },
          "contracts/adapters/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IMultiSend {\n    function multiSend(bytes memory transactions) external payable;\n}\n\nstruct UnwrappedTransaction {\n    Enum.Operation operation;\n    address to;\n    uint256 value;\n    // We wanna deal in calldata slices. We return location, let invoker slice\n    uint256 dataLocation;\n    uint256 dataSize;\n}\n\ninterface ITransactionUnwrapper {\n    function unwrap(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external view returns (UnwrappedTransaction[] memory result);\n}\n\ninterface ICustomCondition {\n    function check(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 location,\n        uint256 size,\n        bytes12 extra\n    ) external view returns (bool success, bytes32 reason);\n}\n"
          },
          "contracts/AllowanceTracker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Core.sol\";\n\n/**\n * @title AllowanceTracker - a component of the Zodiac Roles Mod that is\n * responsible for loading and calculating allowance balances. Persists\n * consumptions back to storage.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\nabstract contract AllowanceTracker is Core {\n    event ConsumeAllowance(\n        bytes32 allowanceKey,\n        uint128 consumed,\n        uint128 newBalance\n    );\n\n    function _accruedAllowance(\n        Allowance memory allowance,\n        uint64 blockTimestamp\n    ) internal pure override returns (uint128 balance, uint64 timestamp) {\n        if (\n            allowance.period == 0 ||\n            blockTimestamp < (allowance.timestamp + allowance.period)\n        ) {\n            return (allowance.balance, allowance.timestamp);\n        }\n\n        uint64 elapsedIntervals = (blockTimestamp - allowance.timestamp) /\n            allowance.period;\n\n        if (allowance.balance < allowance.maxRefill) {\n            balance = allowance.balance + allowance.refill * elapsedIntervals;\n\n            balance = balance < allowance.maxRefill\n                ? balance\n                : allowance.maxRefill;\n        } else {\n            balance = allowance.balance;\n        }\n\n        timestamp = allowance.timestamp + elapsedIntervals * allowance.period;\n    }\n\n    /**\n     * @dev Flushes the consumption of allowances back into storage, before\n     * execution. This flush is not final\n     * @param consumptions The array of consumption structs containing\n     * information about allowances and consumed amounts.\n     */\n    function _flushPrepare(Consumption[] memory consumptions) internal {\n        uint256 count = consumptions.length;\n\n        for (uint256 i; i < count; ) {\n            Consumption memory consumption = consumptions[i];\n\n            bytes32 key = consumption.allowanceKey;\n            uint128 consumed = consumption.consumed;\n\n            // Retrieve the allowance and calculate its current updated balance\n            // and next refill timestamp.\n            Allowance storage allowance = allowances[key];\n            (uint128 balance, uint64 timestamp) = _accruedAllowance(\n                allowance,\n                uint64(block.timestamp)\n            );\n\n            assert(balance == consumption.balance);\n            assert(consumed <= balance);\n            // Flush\n            allowance.balance = balance - consumed;\n            allowance.timestamp = timestamp;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Finalizes or reverts the flush of allowances, after transaction\n     * execution\n     * @param consumptions The array of consumption structs containing\n     * information about allowances and consumed amounts.\n     * @param success a boolean that indicates whether transaction execution\n     * was successful\n     */\n    function _flushCommit(\n        Consumption[] memory consumptions,\n        bool success\n    ) internal {\n        uint256 count = consumptions.length;\n        for (uint256 i; i < count; ) {\n            Consumption memory consumption = consumptions[i];\n            bytes32 key = consumption.allowanceKey;\n            if (success) {\n                emit ConsumeAllowance(\n                    key,\n                    consumption.consumed,\n                    consumption.balance - consumption.consumed\n                );\n            } else {\n                allowances[key].balance = consumption.balance;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
          },
          "contracts/Consumptions.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Types.sol\";\n\n/**\n * @title Consumptions - a library that provides helper functions for dealing\n * with collection of Consumptions.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Consumptions {\n    function clone(\n        Consumption[] memory consumptions\n    ) internal pure returns (Consumption[] memory result) {\n        uint256 length = consumptions.length;\n\n        result = new Consumption[](length);\n        for (uint256 i; i < length; ) {\n            result[i].allowanceKey = consumptions[i].allowanceKey;\n            result[i].balance = consumptions[i].balance;\n            result[i].consumed = consumptions[i].consumed;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function find(\n        Consumption[] memory consumptions,\n        bytes32 key\n    ) internal pure returns (uint256, bool) {\n        uint256 length = consumptions.length;\n\n        for (uint256 i; i < length; ) {\n            if (consumptions[i].allowanceKey == key) {\n                return (i, true);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (0, false);\n    }\n\n    function merge(\n        Consumption[] memory c1,\n        Consumption[] memory c2\n    ) internal pure returns (Consumption[] memory result) {\n        if (c1.length == 0) return c2;\n        if (c2.length == 0) return c1;\n\n        result = new Consumption[](c1.length + c2.length);\n\n        uint256 length = c1.length;\n\n        for (uint256 i; i < length; ) {\n            result[i].allowanceKey = c1[i].allowanceKey;\n            result[i].balance = c1[i].balance;\n            result[i].consumed = c1[i].consumed;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < c2.length; ) {\n            (uint256 index, bool found) = find(c1, c2[i].allowanceKey);\n            if (found) {\n                result[index].consumed += c2[i].consumed;\n            } else {\n                result[length].allowanceKey = c2[i].allowanceKey;\n                result[length].balance = c2[i].balance;\n                result[length].consumed = c2[i].consumed;\n                length++;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (length < result.length) {\n            assembly {\n                mstore(result, length)\n            }\n        }\n    }\n}\n"
          },
          "contracts/Core.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/zodiac/contracts/core/Modifier.sol\";\nimport \"./Types.sol\";\n\n/**\n * @title Core is the base contract for the Zodiac Roles Mod, which defines\n * the common abstract connection points between Builder, Loader, and Checker.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nabstract contract Core is Modifier {\n    mapping(bytes32 => Role) internal roles;\n    mapping(bytes32 => Allowance) public allowances;\n\n    function _store(\n        Role storage role,\n        bytes32 key,\n        ConditionFlat[] memory conditions,\n        ExecutionOptions options\n    ) internal virtual;\n\n    function _load(\n        Role storage role,\n        bytes32 key\n    ) internal view virtual returns (Condition memory, Consumption[] memory);\n\n    function _accruedAllowance(\n        Allowance memory allowance,\n        uint64 blockTimestamp\n    ) internal pure virtual returns (uint128 balance, uint64 timestamp);\n\n    function _key(\n        address targetAddress,\n        bytes4 selector\n    ) internal pure returns (bytes32) {\n        /*\n         * Unoptimized version:\n         * bytes32(abi.encodePacked(targetAddress, selector))\n         */\n        return bytes32(bytes20(targetAddress)) | (bytes32(selector) >> 160);\n    }\n}\n"
          },
          "contracts/Decoder.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\n\n/**\n * @title Decoder - a library that discovers parameter locations in calldata\n * from a list of conditions.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Decoder {\n    error CalldataOutOfBounds();\n\n    /**\n     * @dev Maps the location and size of parameters in the encoded transaction data.\n     * @param data The encoded transaction data.\n     * @param condition The condition of the parameters.\n     * @return result The mapped location and size of parameters in the encoded transaction data.\n     */\n    function inspect(\n        bytes calldata data,\n        Condition memory condition\n    ) internal pure returns (ParameterPayload memory result) {\n        /*\n         * In the parameter encoding area, there is a region called the head\n         * that is divided into 32-byte chunks. Each parameter has its own\n         * corresponding chunk in the head region:\n         * - Static parameters are encoded inline.\n         * - Dynamic parameters have an offset to the tail, which is the start\n         *   of the actual encoding for the dynamic parameter. Note that the\n         *   offset does not include the 4-byte function signature.\"\n         *\n         */\n        Topology.TypeTree memory node = Topology.typeTree(condition);\n        __block__(data, 4, node, node.children.length, false, result);\n        result.location = 0;\n        result.size = data.length;\n    }\n\n    /**\n     * @dev Walks through a parameter encoding tree and maps their location and\n     * size within calldata.\n     * @param data The encoded transaction data.\n     * @param location The current offset within the calldata buffer.\n     * @param node The current node being traversed within the parameter tree.\n     * @param result The location and size of the parameter within calldata.\n     */\n    function _walk(\n        bytes calldata data,\n        uint256 location,\n        Topology.TypeTree memory node,\n        ParameterPayload memory result\n    ) private pure {\n        ParameterType paramType = node.paramType;\n\n        if (paramType == ParameterType.Static) {\n            result.size = 32;\n        } else if (paramType == ParameterType.Dynamic) {\n            result.size = 32 + _ceil32(uint256(word(data, location)));\n        } else if (paramType == ParameterType.Tuple) {\n            __block__(\n                data,\n                location,\n                node,\n                node.children.length,\n                false,\n                result\n            );\n        } else if (paramType == ParameterType.Array) {\n            __block__(\n                data,\n                location + 32,\n                node,\n                uint256(word(data, location)),\n                true,\n                result\n            );\n            result.size += 32;\n        } else if (\n            paramType == ParameterType.Calldata ||\n            paramType == ParameterType.AbiEncoded\n        ) {\n            __block__(\n                data,\n                location + 32 + (paramType == ParameterType.Calldata ? 4 : 0),\n                node,\n                node.children.length,\n                false,\n                result\n            );\n            result.size = 32 + _ceil32(uint256(word(data, location)));\n        }\n        result.location = location;\n    }\n\n    /**\n     * @dev Recursively walk through the TypeTree to decode a block of parameters.\n     * @param data The encoded transaction data.\n     * @param location The current location of the parameter block being processed.\n     * @param node The current TypeTree node being processed.\n     * @param length The number of parts in the block.\n     * @param template whether first child is type descriptor for all parts.\n     * @param result The decoded ParameterPayload.\n     */\n    function __block__(\n        bytes calldata data,\n        uint256 location,\n        Topology.TypeTree memory node,\n        uint256 length,\n        bool template,\n        ParameterPayload memory result\n    ) private pure {\n        result.children = new ParameterPayload[](length);\n        bool isInline;\n        if (template) isInline = Topology.isInline(node.children[0]);\n\n        uint256 offset;\n        for (uint256 i; i < length; ) {\n            if (!template) isInline = Topology.isInline(node.children[i]);\n\n            _walk(\n                data,\n                _locationInBlock(data, location, offset, isInline),\n                node.children[template ? 0 : i],\n                result.children[i]\n            );\n\n            uint256 childSize = result.children[i].size;\n            result.size += isInline ? childSize : childSize + 32;\n            offset += isInline ? childSize : 32;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the location of a block part, which may be located inline\n     * within the block - at the HEAD - or at an offset relative to the start\n     * of the block - at the TAIL.\n     *\n     * @param data The encoded transaction data.\n     * @param location The location of the block within the calldata buffer.\n     * @param offset The offset of the block part, relative to the start of the block.\n     * @param isInline Whether the block part is located inline within the block.\n     *\n     * @return The location of the block part within the calldata buffer.\n     */\n    function _locationInBlock(\n        bytes calldata data,\n        uint256 location,\n        uint256 offset,\n        bool isInline\n    ) private pure returns (uint256) {\n        uint256 headLocation = location + offset;\n        if (isInline) {\n            return headLocation;\n        } else {\n            return location + uint256(word(data, headLocation));\n        }\n    }\n\n    /**\n     * @dev Plucks a slice of bytes from calldata.\n     * @param data The calldata to pluck the slice from.\n     * @param location The starting location of the slice.\n     * @param size The size of the slice.\n     * @return A slice of bytes from calldata.\n     */\n    function pluck(\n        bytes calldata data,\n        uint256 location,\n        uint256 size\n    ) internal pure returns (bytes calldata) {\n        return data[location:location + size];\n    }\n\n    /**\n     * @dev Loads a word from calldata.\n     * @param data The calldata to load the word from.\n     * @param location The starting location of the slice.\n     * @return result 32 byte word from calldata.\n     */\n    function word(\n        bytes calldata data,\n        uint256 location\n    ) internal pure returns (bytes32 result) {\n        if (location + 32 > data.length) {\n            revert CalldataOutOfBounds();\n        }\n        assembly {\n            result := calldataload(add(data.offset, location))\n        }\n    }\n\n    function _ceil32(uint256 size) private pure returns (uint256) {\n        // pad size. Source: http://www.cs.nott.ac.uk/~psarb2/G51MPC/slides/NumberLogic.pdf\n        return ((size + 32 - 1) / 32) * 32;\n    }\n}\n"
          },
          "contracts/Integrity.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\n\n/**\n * @title Integrity, A library that validates condition integrity, and\n * adherence to the expected input structure and rules.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Integrity {\n    error UnsuitableRootNode();\n\n    error NotBFS();\n\n    error UnsuitableParameterType(uint256 index);\n\n    error UnsuitableCompValue(uint256 index);\n\n    error UnsupportedOperator(uint256 index);\n\n    error UnsuitableParent(uint256 index);\n\n    error UnsuitableChildCount(uint256 index);\n\n    error UnsuitableChildTypeTree(uint256 index);\n\n    function enforce(ConditionFlat[] memory conditions) external pure {\n        _root(conditions);\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            _node(conditions[i], i);\n        }\n        _tree(conditions);\n    }\n\n    function _root(ConditionFlat[] memory conditions) private pure {\n        uint256 count;\n\n        for (uint256 i; i < conditions.length; ++i) {\n            if (conditions[i].parent == i) ++count;\n        }\n        if (count != 1 || conditions[0].parent != 0) {\n            revert UnsuitableRootNode();\n        }\n    }\n\n    function _node(ConditionFlat memory condition, uint256 index) private pure {\n        Operator operator = condition.operator;\n        ParameterType paramType = condition.paramType;\n        bytes memory compValue = condition.compValue;\n        if (operator == Operator.Pass) {\n            if (condition.compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator >= Operator.And && operator <= Operator.Nor) {\n            if (paramType != ParameterType.None) {\n                revert UnsuitableParameterType(index);\n            }\n            if (condition.compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.Matches) {\n            if (\n                paramType != ParameterType.Tuple &&\n                paramType != ParameterType.Array &&\n                paramType != ParameterType.Calldata &&\n                paramType != ParameterType.AbiEncoded\n            ) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (\n            operator == Operator.ArraySome ||\n            operator == Operator.ArrayEvery ||\n            operator == Operator.ArraySubset\n        ) {\n            if (paramType != ParameterType.Array) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.EqualToAvatar) {\n            if (paramType != ParameterType.Static) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.EqualTo) {\n            if (\n                paramType != ParameterType.Static &&\n                paramType != ParameterType.Dynamic &&\n                paramType != ParameterType.Tuple &&\n                paramType != ParameterType.Array\n            ) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length == 0 || compValue.length % 32 != 0) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (\n            operator == Operator.GreaterThan ||\n            operator == Operator.LessThan ||\n            operator == Operator.SignedIntGreaterThan ||\n            operator == Operator.SignedIntLessThan\n        ) {\n            if (paramType != ParameterType.Static) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.Bitmask) {\n            if (\n                paramType != ParameterType.Static &&\n                paramType != ParameterType.Dynamic\n            ) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.Custom) {\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (operator == Operator.WithinAllowance) {\n            if (paramType != ParameterType.Static) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else if (\n            operator == Operator.EtherWithinAllowance ||\n            operator == Operator.CallWithinAllowance\n        ) {\n            if (paramType != ParameterType.None) {\n                revert UnsuitableParameterType(index);\n            }\n            if (compValue.length != 32) {\n                revert UnsuitableCompValue(index);\n            }\n        } else {\n            revert UnsupportedOperator(index);\n        }\n    }\n\n    function _tree(ConditionFlat[] memory conditions) private pure {\n        uint256 length = conditions.length;\n        // check BFS\n        for (uint256 i = 1; i < length; ++i) {\n            if (conditions[i - 1].parent > conditions[i].parent) {\n                revert NotBFS();\n            }\n        }\n\n        for (uint256 i = 0; i < length; ++i) {\n            if (\n                (conditions[i].operator == Operator.EtherWithinAllowance ||\n                    conditions[i].operator == Operator.CallWithinAllowance) &&\n                conditions[conditions[i].parent].paramType !=\n                ParameterType.Calldata\n            ) {\n                revert UnsuitableParent(i);\n            }\n        }\n\n        Topology.Bounds[] memory childrenBounds = Topology.childrenBounds(\n            conditions\n        );\n\n        for (uint256 i = 0; i < conditions.length; i++) {\n            ConditionFlat memory condition = conditions[i];\n            Topology.Bounds memory childBounds = childrenBounds[i];\n\n            if (condition.paramType == ParameterType.None) {\n                if (\n                    (condition.operator == Operator.EtherWithinAllowance ||\n                        condition.operator == Operator.CallWithinAllowance) &&\n                    childBounds.length != 0\n                ) {\n                    revert UnsuitableChildCount(i);\n                }\n                if (\n                    (condition.operator >= Operator.And &&\n                        condition.operator <= Operator.Nor)\n                ) {\n                    if (childBounds.length == 0) {\n                        revert UnsuitableChildCount(i);\n                    }\n                }\n            } else if (\n                condition.paramType == ParameterType.Static ||\n                condition.paramType == ParameterType.Dynamic\n            ) {\n                if (childBounds.length != 0) {\n                    revert UnsuitableChildCount(i);\n                }\n            } else if (\n                condition.paramType == ParameterType.Tuple ||\n                condition.paramType == ParameterType.Calldata ||\n                condition.paramType == ParameterType.AbiEncoded\n            ) {\n                if (childBounds.length == 0) {\n                    revert UnsuitableChildCount(i);\n                }\n            } else {\n                assert(condition.paramType == ParameterType.Array);\n\n                if (childBounds.length == 0) {\n                    revert UnsuitableChildCount(i);\n                }\n\n                if (\n                    (condition.operator == Operator.ArraySome ||\n                        condition.operator == Operator.ArrayEvery) &&\n                    childBounds.length != 1\n                ) {\n                    revert UnsuitableChildCount(i);\n                } else if (\n                    condition.operator == Operator.ArraySubset &&\n                    childBounds.length > 256\n                ) {\n                    revert UnsuitableChildCount(i);\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < conditions.length; i++) {\n            ConditionFlat memory condition = conditions[i];\n            if (\n                ((condition.operator >= Operator.And &&\n                    condition.operator <= Operator.Nor) ||\n                    condition.paramType == ParameterType.Array) &&\n                childrenBounds[i].length > 1\n            ) {\n                _compatibleSiblingTypes(conditions, i, childrenBounds);\n            }\n        }\n\n        Topology.TypeTree memory typeTree = Topology.typeTree(\n            conditions,\n            0,\n            childrenBounds\n        );\n\n        if (typeTree.paramType != ParameterType.Calldata) {\n            revert UnsuitableRootNode();\n        }\n    }\n\n    function _compatibleSiblingTypes(\n        ConditionFlat[] memory conditions,\n        uint256 index,\n        Topology.Bounds[] memory childrenBounds\n    ) private pure {\n        uint256 start = childrenBounds[index].start;\n        uint256 end = childrenBounds[index].end;\n\n        for (uint256 j = start + 1; j < end; ++j) {\n            if (\n                !_isTypeMatch(conditions, start, j, childrenBounds) &&\n                !_isTypeEquivalent(conditions, start, j, childrenBounds)\n            ) {\n                revert UnsuitableChildTypeTree(index);\n            }\n        }\n    }\n\n    function _isTypeMatch(\n        ConditionFlat[] memory conditions,\n        uint256 i,\n        uint256 j,\n        Topology.Bounds[] memory childrenBounds\n    ) private pure returns (bool) {\n        return\n            typeTreeId(Topology.typeTree(conditions, i, childrenBounds)) ==\n            typeTreeId(Topology.typeTree(conditions, j, childrenBounds));\n    }\n\n    function _isTypeEquivalent(\n        ConditionFlat[] memory conditions,\n        uint256 i,\n        uint256 j,\n        Topology.Bounds[] memory childrenBounds\n    ) private pure returns (bool) {\n        ParameterType leftParamType = Topology\n            .typeTree(conditions, i, childrenBounds)\n            .paramType;\n        return\n            (leftParamType == ParameterType.Calldata ||\n                leftParamType == ParameterType.AbiEncoded) &&\n            Topology.typeTree(conditions, j, childrenBounds).paramType ==\n            ParameterType.Dynamic;\n    }\n\n    function typeTreeId(\n        Topology.TypeTree memory node\n    ) private pure returns (bytes32) {\n        uint256 childCount = node.children.length;\n        if (childCount > 0) {\n            bytes32[] memory ids = new bytes32[](node.children.length);\n            for (uint256 i = 0; i < childCount; ++i) {\n                ids[i] = typeTreeId(node.children[i]);\n            }\n\n            return keccak256(abi.encodePacked(node.paramType, \"-\", ids));\n        } else {\n            return bytes32(uint256(node.paramType));\n        }\n    }\n}\n"
          },
          "contracts/packers/BufferPacker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../Types.sol\";\n\n/**\n * @title BufferPacker a library that provides packing and unpacking functions\n * for conditions. It allows packing externally provided ConditionsFlat[] into\n * a storage-optimized buffer, and later unpack it into memory.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary BufferPacker {\n    // HEADER (stored as a single word in storage)\n    // 2   bytes -> count (Condition count)\n    // 1   bytes -> options (ExecutionOptions)\n    // 1   bytes -> isWildcarded\n    // 8   bytes -> unused\n    // 20  bytes -> pointer (address containining packed conditions)\n    uint256 private constant OFFSET_COUNT = 240;\n    uint256 private constant OFFSET_OPTIONS = 224;\n    uint256 private constant OFFSET_IS_WILDCARDED = 216;\n    uint256 private constant MASK_COUNT = 0xffff << OFFSET_COUNT;\n    uint256 private constant MASK_OPTIONS = 0xff << OFFSET_OPTIONS;\n    uint256 private constant MASK_IS_WILDCARDED = 0x1 << OFFSET_IS_WILDCARDED;\n    // CONDITION (stored as runtimeBytecode at pointer address kept in header)\n    // 8    bits -> parent\n    // 3    bits -> type\n    // 5    bits -> operator\n    uint256 private constant BYTES_PER_CONDITION = 2;\n    uint16 private constant OFFSET_PARENT = 8;\n    uint16 private constant OFFSET_PARAM_TYPE = 5;\n    uint16 private constant OFFSET_OPERATOR = 0;\n    uint16 private constant MASK_PARENT = uint16(0xff << OFFSET_PARENT);\n    uint16 private constant MASK_PARAM_TYPE = uint16(0x07 << OFFSET_PARAM_TYPE);\n    uint16 private constant MASK_OPERATOR = uint16(0x1f << OFFSET_OPERATOR);\n\n    function packedSize(\n        ConditionFlat[] memory conditions\n    ) internal pure returns (uint256 result) {\n        uint256 count = conditions.length;\n\n        result = count * BYTES_PER_CONDITION;\n        for (uint256 i; i < count; ++i) {\n            if (conditions[i].operator >= Operator.EqualTo) {\n                result += 32;\n            }\n        }\n    }\n\n    function packHeader(\n        uint256 count,\n        ExecutionOptions options,\n        address pointer\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(count << OFFSET_COUNT) |\n            (bytes32(uint256(options)) << OFFSET_OPTIONS) |\n            bytes32(uint256(uint160(pointer)));\n    }\n\n    function packHeaderAsWildcarded(\n        ExecutionOptions options\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(uint256(options) << OFFSET_OPTIONS) |\n            bytes32(MASK_IS_WILDCARDED);\n    }\n\n    function unpackHeader(\n        bytes32 header\n    ) internal pure returns (uint256 count, address pointer) {\n        count = (uint256(header) & MASK_COUNT) >> OFFSET_COUNT;\n        pointer = address(bytes20(uint160(uint256(header))));\n    }\n\n    function unpackOptions(\n        bytes32 header\n    ) internal pure returns (bool isWildcarded, ExecutionOptions options) {\n        isWildcarded = uint256(header) & MASK_IS_WILDCARDED != 0;\n        options = ExecutionOptions(\n            (uint256(header) & MASK_OPTIONS) >> OFFSET_OPTIONS\n        );\n    }\n\n    function packCondition(\n        bytes memory buffer,\n        uint256 index,\n        ConditionFlat memory condition\n    ) internal pure {\n        uint256 offset = index * BYTES_PER_CONDITION;\n        buffer[offset] = bytes1(condition.parent);\n        buffer[offset + 1] = bytes1(\n            (uint8(condition.paramType) << uint8(OFFSET_PARAM_TYPE)) |\n                uint8(condition.operator)\n        );\n    }\n\n    function packCompValue(\n        bytes memory buffer,\n        uint256 offset,\n        ConditionFlat memory condition\n    ) internal pure {\n        bytes32 word = condition.operator == Operator.EqualTo\n            ? keccak256(condition.compValue)\n            : bytes32(condition.compValue);\n\n        assembly {\n            mstore(add(buffer, offset), word)\n        }\n    }\n\n    function unpackBody(\n        bytes memory buffer,\n        uint256 count\n    )\n        internal\n        pure\n        returns (ConditionFlat[] memory result, bytes32[] memory compValues)\n    {\n        result = new ConditionFlat[](count);\n        compValues = new bytes32[](count);\n\n        bytes32 word;\n        uint256 offset = 32;\n        uint256 compValueOffset = 32 + count * BYTES_PER_CONDITION;\n\n        for (uint256 i; i < count; ) {\n            assembly {\n                word := mload(add(buffer, offset))\n            }\n            offset += BYTES_PER_CONDITION;\n\n            uint16 bits = uint16(bytes2(word));\n            ConditionFlat memory condition = result[i];\n            condition.parent = uint8((bits & MASK_PARENT) >> OFFSET_PARENT);\n            condition.paramType = ParameterType(\n                (bits & MASK_PARAM_TYPE) >> OFFSET_PARAM_TYPE\n            );\n            condition.operator = Operator(bits & MASK_OPERATOR);\n\n            if (condition.operator >= Operator.EqualTo) {\n                assembly {\n                    word := mload(add(buffer, compValueOffset))\n                }\n                compValueOffset += 32;\n                compValues[i] = word;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
          },
          "contracts/packers/Packer.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/zodiac/contracts/core/Modifier.sol\";\n\nimport \"./BufferPacker.sol\";\n\n/**\n * @title Packer - a library that coordinates the process of packing\n * conditionsFlat into a storage optimized buffer.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Packer {\n    function pack(\n        ConditionFlat[] memory conditionsFlat\n    ) external pure returns (bytes memory buffer) {\n        _removeExtraneousOffsets(conditionsFlat);\n\n        buffer = new bytes(BufferPacker.packedSize(conditionsFlat));\n\n        uint256 count = conditionsFlat.length;\n        uint256 offset = 32 + count * 2;\n        for (uint256 i; i < count; ++i) {\n            BufferPacker.packCondition(buffer, i, conditionsFlat[i]);\n            if (conditionsFlat[i].operator >= Operator.EqualTo) {\n                BufferPacker.packCompValue(buffer, offset, conditionsFlat[i]);\n                offset += 32;\n            }\n        }\n    }\n\n    /**\n     * @dev This function removes unnecessary offsets from compValue fields of\n     * the `conditions` array. Its purpose is to ensure a consistent API where\n     * every `compValue` provided for use in `Operations.EqualsTo` is obtained\n     * by calling `abi.encode` directly.\n     *\n     * By removing the leading extraneous offsets this function makes\n     * abi.encode(...) match the output produced by Decoder inspection.\n     * Without it, the encoded fields would need to be patched externally\n     * depending on whether the payload is fully encoded inline or not.\n     *\n     * @param conditionsFlat Array of ConditionFlat structs to remove extraneous\n     * offsets from\n     */\n    function _removeExtraneousOffsets(\n        ConditionFlat[] memory conditionsFlat\n    ) private pure {\n        uint256 count = conditionsFlat.length;\n        for (uint256 i; i < count; ++i) {\n            if (\n                conditionsFlat[i].operator == Operator.EqualTo &&\n                !_isInline(conditionsFlat, i)\n            ) {\n                bytes memory compValue = conditionsFlat[i].compValue;\n                uint256 length = compValue.length;\n                assembly {\n                    compValue := add(compValue, 32)\n                    mstore(compValue, sub(length, 32))\n                }\n                conditionsFlat[i].compValue = compValue;\n            }\n        }\n    }\n\n    function _isInline(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure returns (bool) {\n        ParameterType paramType = conditions[index].paramType;\n        if (paramType == ParameterType.Static) {\n            return true;\n        } else if (\n            paramType == ParameterType.Dynamic ||\n            paramType == ParameterType.Array ||\n            paramType == ParameterType.Calldata ||\n            paramType == ParameterType.AbiEncoded\n        ) {\n            return false;\n        } else {\n            uint256 length = conditions.length;\n\n            for (uint256 j = index + 1; j < length; ++j) {\n                uint8 parent = conditions[j].parent;\n                if (parent < index) {\n                    continue;\n                }\n\n                if (parent > index) {\n                    break;\n                }\n\n                if (!_isInline(conditions, j)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n"
          },
          "contracts/Periphery.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./adapters/Types.sol\";\n\n/**\n * @title Periphery - a coordinating component that facilitates plug-and-play\n * functionality for the Zodiac Roles Mod through the use of adapters.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nabstract contract Periphery is OwnableUpgradeable {\n    event SetUnwrapAdapter(\n        address to,\n        bytes4 selector,\n        ITransactionUnwrapper adapter\n    );\n\n    mapping(bytes32 => ITransactionUnwrapper) public unwrappers;\n\n    function setTransactionUnwrapper(\n        address to,\n        bytes4 selector,\n        ITransactionUnwrapper adapter\n    ) external onlyOwner {\n        unwrappers[bytes32(bytes20(to)) | (bytes32(selector) >> 160)] = adapter;\n        emit SetUnwrapAdapter(to, selector, adapter);\n    }\n\n    function getTransactionUnwrapper(\n        address to,\n        bytes4 selector\n    ) internal view returns (ITransactionUnwrapper) {\n        return unwrappers[bytes32(bytes20(to)) | (bytes32(selector) >> 160)];\n    }\n}\n"
          },
          "contracts/PermissionBuilder.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Core.sol\";\nimport \"./Integrity.sol\";\n\nimport \"./packers/BufferPacker.sol\";\n\n/**\n * @title PermissionBuilder - a component of the Zodiac Roles Mod that is\n * responsible for constructing, managing, granting, and revoking all types\n * of permission data.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\nabstract contract PermissionBuilder is Core {\n    event AllowTarget(\n        bytes32 roleKey,\n        address targetAddress,\n        ExecutionOptions options\n    );\n    event RevokeTarget(bytes32 roleKey, address targetAddress);\n    event ScopeTarget(bytes32 roleKey, address targetAddress);\n\n    event AllowFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        ExecutionOptions options\n    );\n    event RevokeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector\n    );\n    event ScopeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        ConditionFlat[] conditions,\n        ExecutionOptions options\n    );\n\n    event SetAllowance(\n        bytes32 allowanceKey,\n        uint128 balance,\n        uint128 maxRefill,\n        uint128 refill,\n        uint64 period,\n        uint64 timestamp\n    );\n\n    /// @dev Allows transactions to a target address.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param options designates if a transaction can send ether and/or delegatecall to target.\n    function allowTarget(\n        bytes32 roleKey,\n        address targetAddress,\n        ExecutionOptions options\n    ) external onlyOwner {\n        roles[roleKey].targets[targetAddress] = TargetAddress({\n            clearance: Clearance.Target,\n            options: options\n        });\n        emit AllowTarget(roleKey, targetAddress, options);\n    }\n\n    /// @dev Removes transactions to a target address.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    function revokeTarget(\n        bytes32 roleKey,\n        address targetAddress\n    ) external onlyOwner {\n        roles[roleKey].targets[targetAddress] = TargetAddress({\n            clearance: Clearance.None,\n            options: ExecutionOptions.None\n        });\n        emit RevokeTarget(roleKey, targetAddress);\n    }\n\n    /// @dev Designates only specific functions can be called.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    function scopeTarget(\n        bytes32 roleKey,\n        address targetAddress\n    ) external onlyOwner {\n        roles[roleKey].targets[targetAddress] = TargetAddress({\n            clearance: Clearance.Function,\n            options: ExecutionOptions.None\n        });\n        emit ScopeTarget(roleKey, targetAddress);\n    }\n\n    /// @dev Specifies the functions that can be called.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param selector 4 byte function selector.\n    /// @param options designates if a transaction can send ether and/or delegatecall to target.\n    function allowFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        ExecutionOptions options\n    ) external onlyOwner {\n        roles[roleKey].scopeConfig[_key(targetAddress, selector)] = BufferPacker\n            .packHeaderAsWildcarded(options);\n\n        emit AllowFunction(roleKey, targetAddress, selector, options);\n    }\n\n    /// @dev Removes the functions that can be called.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param selector 4 byte function selector.\n    function revokeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector\n    ) external onlyOwner {\n        delete roles[roleKey].scopeConfig[_key(targetAddress, selector)];\n        emit RevokeFunction(roleKey, targetAddress, selector);\n    }\n\n    /// @dev Sets conditions to enforce on calls to the specified target.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param selector 4 byte function selector.\n    /// @param conditions The conditions to enforce.\n    /// @param options designates if a transaction can send ether and/or delegatecall to target.\n    function scopeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        ConditionFlat[] memory conditions,\n        ExecutionOptions options\n    ) external onlyOwner {\n        Integrity.enforce(conditions);\n\n        _store(\n            roles[roleKey],\n            _key(targetAddress, selector),\n            conditions,\n            options\n        );\n\n        emit ScopeFunction(\n            roleKey,\n            targetAddress,\n            selector,\n            conditions,\n            options\n        );\n    }\n\n    function setAllowance(\n        bytes32 key,\n        uint128 balance,\n        uint128 maxRefill,\n        uint128 refill,\n        uint64 period,\n        uint64 timestamp\n    ) external onlyOwner {\n        maxRefill = maxRefill != 0 ? maxRefill : type(uint128).max;\n        timestamp = timestamp != 0 ? timestamp : uint64(block.timestamp);\n\n        allowances[key] = Allowance({\n            refill: refill,\n            maxRefill: maxRefill,\n            period: period,\n            timestamp: timestamp,\n            balance: balance\n        });\n        emit SetAllowance(key, balance, maxRefill, refill, period, timestamp);\n    }\n}\n"
          },
          "contracts/PermissionChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\nimport \"./Consumptions.sol\";\nimport \"./Core.sol\";\nimport \"./Decoder.sol\";\nimport \"./Periphery.sol\";\n\nimport \"./packers/BufferPacker.sol\";\n\n/**\n * @title PermissionChecker - a component of Zodiac Roles Mod responsible\n * for enforcing and authorizing actions performed on behalf of a role.\n *\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\nabstract contract PermissionChecker is Core, Periphery {\n    function _authorize(\n        bytes32 roleKey,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) internal moduleOnly returns (Consumption[] memory) {\n        // We never authorize the zero role, as it could clash with the\n        // unassigned default role\n        if (roleKey == 0) {\n            revert NoMembership();\n        }\n\n        Role storage role = roles[roleKey];\n        if (!role.members[sentOrSignedByModule()]) {\n            revert NoMembership();\n        }\n\n        ITransactionUnwrapper adapter = getTransactionUnwrapper(\n            to,\n            bytes4(data)\n        );\n\n        Status status;\n        Result memory result;\n        if (address(adapter) == address(0)) {\n            (status, result) = _transaction(\n                role,\n                to,\n                value,\n                data,\n                operation,\n                result.consumptions\n            );\n        } else {\n            (status, result) = _multiEntrypoint(\n                ITransactionUnwrapper(adapter),\n                role,\n                to,\n                value,\n                data,\n                operation\n            );\n        }\n        if (status != Status.Ok) {\n            revert ConditionViolation(status, result.info);\n        }\n\n        return result.consumptions;\n    }\n\n    function _multiEntrypoint(\n        ITransactionUnwrapper adapter,\n        Role storage role,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) private view returns (Status status, Result memory result) {\n        try adapter.unwrap(to, value, data, operation) returns (\n            UnwrappedTransaction[] memory transactions\n        ) {\n            for (uint256 i; i < transactions.length; ) {\n                UnwrappedTransaction memory transaction = transactions[i];\n                uint256 left = transaction.dataLocation;\n                uint256 right = left + transaction.dataSize;\n                (status, result) = _transaction(\n                    role,\n                    transaction.to,\n                    transaction.value,\n                    data[left:right],\n                    transaction.operation,\n                    result.consumptions\n                );\n                if (status != Status.Ok) {\n                    return (status, result);\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } catch {\n            revert MalformedMultiEntrypoint();\n        }\n    }\n\n    /// @dev Inspects an individual transaction and performs checks based on permission scoping.\n    /// Wildcarded indicates whether params need to be inspected or not. When true, only ExecutionOptions are checked.\n    /// @param role Role to check for.\n    /// @param to Destination address of transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function _transaction(\n        Role storage role,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        Consumption[] memory consumptions\n    ) private view returns (Status, Result memory) {\n        if (data.length != 0 && data.length < 4) {\n            revert FunctionSignatureTooShort();\n        }\n\n        if (role.targets[to].clearance == Clearance.Function) {\n            bytes32 key = _key(to, bytes4(data));\n            {\n                bytes32 header = role.scopeConfig[key];\n                if (header == 0) {\n                    return (\n                        Status.FunctionNotAllowed,\n                        Result({\n                            consumptions: consumptions,\n                            info: bytes32(bytes4(data))\n                        })\n                    );\n                }\n\n                (bool isWildcarded, ExecutionOptions options) = BufferPacker\n                    .unpackOptions(header);\n\n                Status status = _executionOptions(value, operation, options);\n                if (status != Status.Ok) {\n                    return (\n                        status,\n                        Result({consumptions: consumptions, info: 0})\n                    );\n                }\n\n                if (isWildcarded) {\n                    return (\n                        Status.Ok,\n                        Result({consumptions: consumptions, info: 0})\n                    );\n                }\n            }\n\n            return\n                _scopedFunction(\n                    role,\n                    key,\n                    data,\n                    Context({\n                        to: to,\n                        value: value,\n                        operation: operation,\n                        consumptions: consumptions\n                    })\n                );\n        } else if (role.targets[to].clearance == Clearance.Target) {\n            return (\n                _executionOptions(value, operation, role.targets[to].options),\n                Result({consumptions: consumptions, info: 0})\n            );\n        } else {\n            return (\n                Status.TargetAddressNotAllowed,\n                Result({consumptions: consumptions, info: 0})\n            );\n        }\n    }\n\n    /// @dev Examines the ether value and operation for a given role target.\n    /// @param value Ether value of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    /// @param options Determines if a transaction can send ether and/or delegatecall to target.\n    function _executionOptions(\n        uint256 value,\n        Enum.Operation operation,\n        ExecutionOptions options\n    ) private pure returns (Status) {\n        // isSend && !canSend\n        if (\n            value > 0 &&\n            options != ExecutionOptions.Send &&\n            options != ExecutionOptions.Both\n        ) {\n            return Status.SendNotAllowed;\n        }\n\n        // isDelegateCall && !canDelegateCall\n        if (\n            operation == Enum.Operation.DelegateCall &&\n            options != ExecutionOptions.DelegateCall &&\n            options != ExecutionOptions.Both\n        ) {\n            return Status.DelegateCallNotAllowed;\n        }\n\n        return Status.Ok;\n    }\n\n    function _scopedFunction(\n        Role storage role,\n        bytes32 key,\n        bytes calldata data,\n        Context memory context\n    ) private view returns (Status, Result memory) {\n        (Condition memory condition, Consumption[] memory consumptions) = _load(\n            role,\n            key\n        );\n        ParameterPayload memory payload = Decoder.inspect(data, condition);\n\n        context.consumptions = context.consumptions.length > 0\n            ? Consumptions.merge(context.consumptions, consumptions)\n            : consumptions;\n\n        return _walk(data, condition, payload, context);\n    }\n\n    function _walk(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status, Result memory) {\n        Operator operator = condition.operator;\n\n        if (operator < Operator.EqualTo) {\n            if (operator == Operator.Pass) {\n                return (\n                    Status.Ok,\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            } else if (operator == Operator.Matches) {\n                return _matches(data, condition, payload, context);\n            } else if (operator == Operator.And) {\n                return _and(data, condition, payload, context);\n            } else if (operator == Operator.Or) {\n                return _or(data, condition, payload, context);\n            } else if (operator == Operator.Nor) {\n                return _nor(data, condition, payload, context);\n            } else if (operator == Operator.ArraySome) {\n                return _arraySome(data, condition, payload, context);\n            } else if (operator == Operator.ArrayEvery) {\n                return _arrayEvery(data, condition, payload, context);\n            } else {\n                assert(operator == Operator.ArraySubset);\n                return _arraySubset(data, condition, payload, context);\n            }\n        } else {\n            if (operator <= Operator.LessThan) {\n                return (\n                    _compare(data, condition, payload),\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            } else if (operator <= Operator.SignedIntLessThan) {\n                return (\n                    _compareSignedInt(data, condition, payload),\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            } else if (operator == Operator.Bitmask) {\n                return (\n                    _bitmask(data, condition, payload),\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            } else if (operator == Operator.Custom) {\n                return _custom(data, condition, payload, context);\n            } else if (operator == Operator.WithinAllowance) {\n                return _withinAllowance(data, condition, payload, context);\n            } else if (operator == Operator.EtherWithinAllowance) {\n                return _etherWithinAllowance(condition, context);\n            } else {\n                assert(operator == Operator.CallWithinAllowance);\n                return _callWithinAllowance(condition, context);\n            }\n        }\n    }\n\n    function _matches(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status status, Result memory result) {\n        result.consumptions = context.consumptions;\n\n        if (condition.children.length != payload.children.length) {\n            return (Status.ParameterNotAMatch, result);\n        }\n\n        for (uint256 i; i < condition.children.length; ) {\n            (status, result) = _walk(\n                data,\n                condition.children[i],\n                payload.children[i],\n                Context({\n                    to: context.to,\n                    value: context.value,\n                    operation: context.operation,\n                    consumptions: result.consumptions\n                })\n            );\n            if (status != Status.Ok) {\n                return (\n                    status,\n                    Result({\n                        consumptions: context.consumptions,\n                        info: result.info\n                    })\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (Status.Ok, result);\n    }\n\n    function _and(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status status, Result memory result) {\n        result.consumptions = context.consumptions;\n\n        for (uint256 i; i < condition.children.length; ) {\n            (status, result) = _walk(\n                data,\n                condition.children[i],\n                payload,\n                Context({\n                    to: context.to,\n                    value: context.value,\n                    operation: context.operation,\n                    consumptions: result.consumptions\n                })\n            );\n            if (status != Status.Ok) {\n                return (\n                    status,\n                    Result({\n                        consumptions: context.consumptions,\n                        info: result.info\n                    })\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (Status.Ok, result);\n    }\n\n    function _or(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status status, Result memory result) {\n        result.consumptions = context.consumptions;\n\n        for (uint256 i; i < condition.children.length; ) {\n            (status, result) = _walk(\n                data,\n                condition.children[i],\n                payload,\n                Context({\n                    to: context.to,\n                    value: context.value,\n                    operation: context.operation,\n                    consumptions: result.consumptions\n                })\n            );\n            if (status == Status.Ok) {\n                return (status, result);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (\n            Status.OrViolation,\n            Result({consumptions: context.consumptions, info: 0})\n        );\n    }\n\n    function _nor(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status status, Result memory) {\n        for (uint256 i; i < condition.children.length; ) {\n            (status, ) = _walk(data, condition.children[i], payload, context);\n            if (status == Status.Ok) {\n                return (\n                    Status.NorViolation,\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (\n            Status.Ok,\n            Result({consumptions: context.consumptions, info: 0})\n        );\n    }\n\n    function _arraySome(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status status, Result memory result) {\n        result.consumptions = context.consumptions;\n\n        uint256 length = condition.children.length;\n        for (uint256 i; i < length; ) {\n            (status, result) = _walk(\n                data,\n                condition.children[0],\n                payload.children[i],\n                Context({\n                    to: context.to,\n                    value: context.value,\n                    operation: context.operation,\n                    consumptions: result.consumptions\n                })\n            );\n            if (status == Status.Ok) {\n                return (status, result);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (\n            Status.NoArrayElementPasses,\n            Result({consumptions: context.consumptions, info: 0})\n        );\n    }\n\n    function _arrayEvery(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status status, Result memory result) {\n        result.consumptions = context.consumptions;\n\n        for (uint256 i; i < payload.children.length; ) {\n            (status, result) = _walk(\n                data,\n                condition.children[0],\n                payload.children[i],\n                Context({\n                    to: context.to,\n                    value: context.value,\n                    operation: context.operation,\n                    consumptions: result.consumptions\n                })\n            );\n            if (status != Status.Ok) {\n                return (\n                    Status.NotEveryArrayElementPasses,\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (Status.Ok, result);\n    }\n\n    function _arraySubset(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status, Result memory result) {\n        result.consumptions = context.consumptions;\n\n        if (\n            payload.children.length == 0 ||\n            payload.children.length > condition.children.length\n        ) {\n            return (Status.ParameterNotSubsetOfAllowed, result);\n        }\n\n        uint256 taken;\n        for (uint256 i; i < payload.children.length; ++i) {\n            bool found = false;\n            for (uint256 j; j < condition.children.length; ++j) {\n                if (taken & (1 << j) != 0) continue;\n\n                (Status status, Result memory _result) = _walk(\n                    data,\n                    condition.children[j],\n                    payload.children[i],\n                    Context({\n                        to: context.to,\n                        value: context.value,\n                        operation: context.operation,\n                        consumptions: result.consumptions\n                    })\n                );\n                if (status == Status.Ok) {\n                    found = true;\n                    taken |= 1 << j;\n                    result = _result;\n                    break;\n                }\n            }\n            if (!found) {\n                return (\n                    Status.ParameterNotSubsetOfAllowed,\n                    Result({consumptions: context.consumptions, info: 0})\n                );\n            }\n        }\n\n        return (Status.Ok, result);\n    }\n\n    function _compare(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload\n    ) private pure returns (Status) {\n        Operator operator = condition.operator;\n        bytes32 compValue = condition.compValue;\n        bytes32 value = operator == Operator.EqualTo\n            ? keccak256(Decoder.pluck(data, payload.location, payload.size))\n            : Decoder.word(data, payload.location);\n\n        if (operator == Operator.EqualTo && value != compValue) {\n            return Status.ParameterNotAllowed;\n        } else if (operator == Operator.GreaterThan && value <= compValue) {\n            return Status.ParameterLessThanAllowed;\n        } else if (operator == Operator.LessThan && value >= compValue) {\n            return Status.ParameterGreaterThanAllowed;\n        } else {\n            return Status.Ok;\n        }\n    }\n\n    function _compareSignedInt(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload\n    ) private pure returns (Status) {\n        Operator operator = condition.operator;\n        int256 compValue = int256(uint256(condition.compValue));\n        int256 value = int256(uint256(Decoder.word(data, payload.location)));\n\n        if (operator == Operator.SignedIntGreaterThan && value <= compValue) {\n            return Status.ParameterLessThanAllowed;\n        } else if (\n            operator == Operator.SignedIntLessThan && value >= compValue\n        ) {\n            return Status.ParameterGreaterThanAllowed;\n        } else {\n            return Status.Ok;\n        }\n    }\n\n    /**\n     * Applies a shift and bitmask on the payload bytes and compares the\n     * result to the expected value. The shift offset, bitmask, and expected\n     * value are specified in the compValue parameter, which is tightly\n     * packed as follows:\n     * <2 bytes shift offset><15 bytes bitmask><15 bytes expected value>\n     */\n    function _bitmask(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload\n    ) private pure returns (Status) {\n        bytes32 compValue = condition.compValue;\n        bool isInline = condition.paramType == ParameterType.Static;\n        bytes calldata value = Decoder.pluck(\n            data,\n            payload.location + (isInline ? 0 : 32),\n            payload.size - (isInline ? 0 : 32)\n        );\n\n        uint256 shift = uint16(bytes2(compValue));\n        if (shift >= value.length) {\n            return Status.BitmaskOverflow;\n        }\n\n        bytes32 rinse = bytes15(0xffffffffffffffffffffffffffffff);\n        bytes32 mask = (compValue << 16) & rinse;\n        // while its necessary to apply the rinse to the mask its not strictly\n        // necessary to do so for the expected value, since we get remaining\n        // 15 bytes anyway (shifting the word by 17 bytes)\n        bytes32 expected = (compValue << (16 + 15 * 8)) & rinse;\n        bytes32 slice = bytes32(value[shift:]);\n\n        return\n            (slice & mask) == expected ? Status.Ok : Status.BitmaskNotAllowed;\n    }\n\n    function _custom(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private view returns (Status, Result memory) {\n        // 20 bytes on the left\n        ICustomCondition adapter = ICustomCondition(\n            address(bytes20(condition.compValue))\n        );\n        // 12 bytes on the right\n        bytes12 extra = bytes12(uint96(uint256(condition.compValue)));\n\n        (bool success, bytes32 info) = adapter.check(\n            context.to,\n            context.value,\n            data,\n            context.operation,\n            payload.location,\n            payload.size,\n            extra\n        );\n        return (\n            success ? Status.Ok : Status.CustomConditionViolation,\n            Result({consumptions: context.consumptions, info: info})\n        );\n    }\n\n    function _withinAllowance(\n        bytes calldata data,\n        Condition memory condition,\n        ParameterPayload memory payload,\n        Context memory context\n    ) private pure returns (Status, Result memory) {\n        uint256 value = uint256(Decoder.word(data, payload.location));\n        return __consume(value, condition, context.consumptions);\n    }\n\n    function _etherWithinAllowance(\n        Condition memory condition,\n        Context memory context\n    ) private pure returns (Status status, Result memory result) {\n        (status, result) = __consume(\n            context.value,\n            condition,\n            context.consumptions\n        );\n        return (\n            status == Status.Ok ? Status.Ok : Status.EtherAllowanceExceeded,\n            result\n        );\n    }\n\n    function _callWithinAllowance(\n        Condition memory condition,\n        Context memory context\n    ) private pure returns (Status status, Result memory result) {\n        (status, result) = __consume(1, condition, context.consumptions);\n        return (\n            status == Status.Ok ? Status.Ok : Status.CallAllowanceExceeded,\n            result\n        );\n    }\n\n    function __consume(\n        uint256 value,\n        Condition memory condition,\n        Consumption[] memory consumptions\n    ) private pure returns (Status, Result memory) {\n        (uint256 index, bool found) = Consumptions.find(\n            consumptions,\n            condition.compValue\n        );\n        assert(found);\n\n        if (\n            value + consumptions[index].consumed > consumptions[index].balance\n        ) {\n            return (\n                Status.AllowanceExceeded,\n                Result({\n                    consumptions: consumptions,\n                    info: consumptions[index].allowanceKey\n                })\n            );\n        } else {\n            consumptions = Consumptions.clone(consumptions);\n            consumptions[index].consumed += uint128(value);\n            return (Status.Ok, Result({consumptions: consumptions, info: 0}));\n        }\n    }\n\n    struct Context {\n        address to;\n        uint256 value;\n        Consumption[] consumptions;\n        Enum.Operation operation;\n    }\n\n    struct Result {\n        Consumption[] consumptions;\n        bytes32 info;\n    }\n\n    enum Status {\n        Ok,\n        /// Role not allowed to delegate call to target address\n        DelegateCallNotAllowed,\n        /// Role not allowed to call target address\n        TargetAddressNotAllowed,\n        /// Role not allowed to call this function on target address\n        FunctionNotAllowed,\n        /// Role not allowed to send to target address\n        SendNotAllowed,\n        /// Or conition not met\n        OrViolation,\n        /// Nor conition not met\n        NorViolation,\n        /// Parameter value is not equal to allowed\n        ParameterNotAllowed,\n        /// Parameter value less than allowed\n        ParameterLessThanAllowed,\n        /// Parameter value greater than maximum allowed by role\n        ParameterGreaterThanAllowed,\n        /// Parameter value does not match\n        ParameterNotAMatch,\n        /// Array elements do not meet allowed criteria for every element\n        NotEveryArrayElementPasses,\n        /// Array elements do not meet allowed criteria for at least one element\n        NoArrayElementPasses,\n        /// Parameter value not a subset of allowed\n        ParameterNotSubsetOfAllowed,\n        /// Bitmask exceeded value length\n        BitmaskOverflow,\n        /// Bitmask not an allowed value\n        BitmaskNotAllowed,\n        CustomConditionViolation,\n        AllowanceExceeded,\n        CallAllowanceExceeded,\n        EtherAllowanceExceeded\n    }\n\n    /// Sender is not a member of the role\n    error NoMembership();\n\n    /// Function signature too short\n    error FunctionSignatureTooShort();\n\n    /// Calldata unwrapping failed\n    error MalformedMultiEntrypoint();\n\n    error ConditionViolation(Status status, bytes32 info);\n}\n"
          },
          "contracts/PermissionLoader.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/zodiac/contracts/core/Modifier.sol\";\nimport \"./Consumptions.sol\";\nimport \"./Core.sol\";\nimport \"./Topology.sol\";\nimport \"./WriteOnce.sol\";\n\nimport \"./packers/Packer.sol\";\n\n/**\n * @title PermissionLoader - a component of the Zodiac Roles Mod that handles\n * the writing and reading of permission data to and from storage.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\nabstract contract PermissionLoader is Core {\n    function _store(\n        Role storage role,\n        bytes32 key,\n        ConditionFlat[] memory conditions,\n        ExecutionOptions options\n    ) internal override {\n        bytes memory buffer = Packer.pack(conditions);\n        address pointer = WriteOnce.store(buffer);\n\n        role.scopeConfig[key] = BufferPacker.packHeader(\n            conditions.length,\n            options,\n            pointer\n        );\n    }\n\n    function _load(\n        Role storage role,\n        bytes32 key\n    )\n        internal\n        view\n        override\n        returns (Condition memory condition, Consumption[] memory consumptions)\n    {\n        (uint256 count, address pointer) = BufferPacker.unpackHeader(\n            role.scopeConfig[key]\n        );\n        bytes memory buffer = WriteOnce.load(pointer);\n        (\n            ConditionFlat[] memory conditionsFlat,\n            bytes32[] memory compValues\n        ) = BufferPacker.unpackBody(buffer, count);\n\n        uint256 allowanceCount;\n\n        for (uint256 i; i < conditionsFlat.length; ) {\n            Operator operator = conditionsFlat[i].operator;\n            if (operator >= Operator.WithinAllowance) {\n                ++allowanceCount;\n            } else if (operator == Operator.EqualToAvatar) {\n                // patch Operator.EqualToAvatar which in reality works as\n                // a placeholder\n                conditionsFlat[i].operator = Operator.EqualTo;\n                compValues[i] = keccak256(abi.encode(avatar));\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        _conditionTree(\n            conditionsFlat,\n            compValues,\n            Topology.childrenBounds(conditionsFlat),\n            0,\n            condition\n        );\n\n        return (\n            condition,\n            allowanceCount > 0\n                ? _consumptions(conditionsFlat, compValues, allowanceCount)\n                : consumptions\n        );\n    }\n\n    function _conditionTree(\n        ConditionFlat[] memory conditionsFlat,\n        bytes32[] memory compValues,\n        Topology.Bounds[] memory childrenBounds,\n        uint256 index,\n        Condition memory treeNode\n    ) private pure {\n        // This function populates a buffer received as an argument instead of\n        // instantiating a result object. This is an important gas optimization\n\n        ConditionFlat memory conditionFlat = conditionsFlat[index];\n        treeNode.paramType = conditionFlat.paramType;\n        treeNode.operator = conditionFlat.operator;\n        treeNode.compValue = compValues[index];\n\n        if (childrenBounds[index].length == 0) {\n            return;\n        }\n\n        uint256 start = childrenBounds[index].start;\n        uint256 length = childrenBounds[index].length;\n\n        treeNode.children = new Condition[](length);\n        for (uint j; j < length; ) {\n            _conditionTree(\n                conditionsFlat,\n                compValues,\n                childrenBounds,\n                start + j,\n                treeNode.children[j]\n            );\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    function _consumptions(\n        ConditionFlat[] memory conditions,\n        bytes32[] memory compValues,\n        uint256 maxAllowanceCount\n    ) private view returns (Consumption[] memory result) {\n        uint256 count = conditions.length;\n        result = new Consumption[](maxAllowanceCount);\n\n        uint256 insert;\n\n        for (uint256 i; i < count; ++i) {\n            if (conditions[i].operator < Operator.WithinAllowance) {\n                continue;\n            }\n\n            bytes32 key = compValues[i];\n            (, bool contains) = Consumptions.find(result, key);\n            if (contains) {\n                continue;\n            }\n\n            result[insert].allowanceKey = key;\n            (result[insert].balance, ) = _accruedAllowance(\n                allowances[key],\n                uint64(block.timestamp)\n            );\n            insert++;\n        }\n\n        if (insert < maxAllowanceCount) {\n            assembly {\n                mstore(result, insert)\n            }\n        }\n    }\n}\n"
          },
          "contracts/Roles.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./AllowanceTracker.sol\";\nimport \"./PermissionBuilder.sol\";\nimport \"./PermissionChecker.sol\";\nimport \"./PermissionLoader.sol\";\n\n/**\n * @title Zodiac Roles Mod - granular, role-based, access control for your\n * on-chain avatar accounts (like Safe).\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n * @author Auryn Macmillan    - <auryn.macmillan@gnosis.io>\n * @author Nathan Ginnever    - <nathan.ginnever@gnosis.io>\n */\ncontract Roles is\n    Modifier,\n    AllowanceTracker,\n    PermissionBuilder,\n    PermissionChecker,\n    PermissionLoader\n{\n    mapping(address => bytes32) public defaultRoles;\n\n    event AssignRoles(address module, bytes32[] roleKeys, bool[] memberOf);\n    event RolesModSetup(\n        address indexed initiator,\n        address indexed owner,\n        address indexed avatar,\n        address target\n    );\n    event SetDefaultRole(address module, bytes32 defaultRoleKey);\n\n    error ArraysDifferentLength();\n\n    /// Sender is allowed to make this call, but the internal transaction failed\n    error ModuleTransactionFailed();\n\n    /// @param _owner Address of the owner\n    /// @param _avatar Address of the avatar (e.g. a Gnosis Safe)\n    /// @param _target Address of the contract that will call exec function\n    constructor(address _owner, address _avatar, address _target) {\n        bytes memory initParams = abi.encode(_owner, _avatar, _target);\n        setUp(initParams);\n    }\n\n    /// @dev There is no zero address check as solidty will check for\n    /// missing arguments and the space of invalid addresses is too large\n    /// to check. Invalid avatar or target address can be reset by owner.\n    function setUp(bytes memory initParams) public override initializer {\n        (address _owner, address _avatar, address _target) = abi.decode(\n            initParams,\n            (address, address, address)\n        );\n        _transferOwnership(_owner);\n        avatar = _avatar;\n        target = _target;\n\n        setupModules();\n\n        emit RolesModSetup(msg.sender, _owner, _avatar, _target);\n    }\n\n    /// @dev Assigns and revokes roles to a given module.\n    /// @param module Module on which to assign/revoke roles.\n    /// @param roleKeys Roles to assign/revoke.\n    /// @param memberOf Assign (true) or revoke (false) corresponding roleKeys.\n    function assignRoles(\n        address module,\n        bytes32[] calldata roleKeys,\n        bool[] calldata memberOf\n    ) external onlyOwner {\n        if (roleKeys.length != memberOf.length) {\n            revert ArraysDifferentLength();\n        }\n        for (uint16 i; i < roleKeys.length; ++i) {\n            roles[roleKeys[i]].members[module] = memberOf[i];\n        }\n        if (!isModuleEnabled(module)) {\n            enableModule(module);\n        }\n        emit AssignRoles(module, roleKeys, memberOf);\n    }\n\n    /// @dev Sets the default role used for a module if it calls execTransactionFromModule() or execTransactionFromModuleReturnData().\n    /// @param module Address of the module on which to set default role.\n    /// @param roleKey Role to be set as default.\n    function setDefaultRole(\n        address module,\n        bytes32 roleKey\n    ) external onlyOwner {\n        defaultRoles[module] = roleKey;\n        emit SetDefaultRole(module, roleKey);\n    }\n\n    /// @dev Passes a transaction to the modifier.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @notice Can only be called by enabled modules\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) public override returns (bool success) {\n        Consumption[] memory consumptions = _authorize(\n            defaultRoles[msg.sender],\n            to,\n            value,\n            data,\n            operation\n        );\n        _flushPrepare(consumptions);\n        success = exec(to, value, data, operation);\n        _flushCommit(consumptions, success);\n    }\n\n    /// @dev Passes a transaction to the modifier, expects return data.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @notice Can only be called by enabled modules\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) public override returns (bool success, bytes memory returnData) {\n        Consumption[] memory consumptions = _authorize(\n            defaultRoles[msg.sender],\n            to,\n            value,\n            data,\n            operation\n        );\n        _flushPrepare(consumptions);\n        (success, returnData) = execAndReturnData(to, value, data, operation);\n        _flushCommit(consumptions, success);\n    }\n\n    /// @dev Passes a transaction to the modifier assuming the specified role.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @param roleKey Identifier of the role to assume for this transaction\n    /// @param shouldRevert Should the function revert on inner execution returning success false?\n    /// @notice Can only be called by enabled modules\n    function execTransactionWithRole(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        bytes32 roleKey,\n        bool shouldRevert\n    ) public returns (bool success) {\n        Consumption[] memory consumptions = _authorize(\n            roleKey,\n            to,\n            value,\n            data,\n            operation\n        );\n        _flushPrepare(consumptions);\n        success = exec(to, value, data, operation);\n        if (shouldRevert && !success) {\n            revert ModuleTransactionFailed();\n        }\n        _flushCommit(consumptions, success);\n    }\n\n    /// @dev Passes a transaction to the modifier assuming the specified role. Expects return data.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @param roleKey Identifier of the role to assume for this transaction\n    /// @param shouldRevert Should the function revert on inner execution returning success false?\n    /// @notice Can only be called by enabled modules\n    function execTransactionWithRoleReturnData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        bytes32 roleKey,\n        bool shouldRevert\n    ) public returns (bool success, bytes memory returnData) {\n        Consumption[] memory consumptions = _authorize(\n            roleKey,\n            to,\n            value,\n            data,\n            operation\n        );\n        _flushPrepare(consumptions);\n        (success, returnData) = execAndReturnData(to, value, data, operation);\n        if (shouldRevert && !success) {\n            revert ModuleTransactionFailed();\n        }\n        _flushCommit(consumptions, success);\n    }\n}\n"
          },
          "contracts/Topology.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Types.sol\";\n\n/**\n * @title Topology - a library that provides helper functions for dealing with\n * the flat representation of conditions.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n */\nlibrary Topology {\n    struct TypeTree {\n        ParameterType paramType;\n        TypeTree[] children;\n    }\n\n    struct Bounds {\n        uint256 start;\n        uint256 end;\n        uint256 length;\n    }\n\n    function childrenBounds(\n        ConditionFlat[] memory conditions\n    ) internal pure returns (Bounds[] memory result) {\n        uint256 count = conditions.length;\n        assert(count > 0);\n\n        // parents are breadth-first\n        result = new Bounds[](count);\n        result[0].start = type(uint256).max;\n\n        // first item is the root\n        for (uint256 i = 1; i < count; ) {\n            result[i].start = type(uint256).max;\n            Bounds memory parentBounds = result[conditions[i].parent];\n            if (parentBounds.start == type(uint256).max) {\n                parentBounds.start = i;\n            }\n            parentBounds.end = i + 1;\n            parentBounds.length = parentBounds.end - parentBounds.start;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function isInline(TypeTree memory node) internal pure returns (bool) {\n        ParameterType paramType = node.paramType;\n        if (paramType == ParameterType.Static) {\n            return true;\n        } else if (\n            paramType == ParameterType.Dynamic ||\n            paramType == ParameterType.Array ||\n            paramType == ParameterType.Calldata ||\n            paramType == ParameterType.AbiEncoded\n        ) {\n            return false;\n        } else {\n            uint256 length = node.children.length;\n\n            for (uint256 i; i < length; ) {\n                if (!isInline(node.children[i])) {\n                    return false;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n            return true;\n        }\n    }\n\n    function typeTree(\n        Condition memory condition\n    ) internal pure returns (TypeTree memory result) {\n        if (\n            condition.operator >= Operator.And &&\n            condition.operator <= Operator.Nor\n        ) {\n            assert(condition.children.length > 0);\n            return typeTree(condition.children[0]);\n        }\n\n        result.paramType = condition.paramType;\n        if (condition.children.length > 0) {\n            uint256 length = condition.paramType == ParameterType.Array\n                ? 1\n                : condition.children.length;\n            result.children = new TypeTree[](length);\n\n            for (uint256 i; i < length; ) {\n                result.children[i] = typeTree(condition.children[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    function typeTree(\n        ConditionFlat[] memory conditions,\n        uint256 index,\n        Bounds[] memory bounds\n    ) internal pure returns (TypeTree memory result) {\n        ConditionFlat memory condition = conditions[index];\n        if (\n            condition.operator >= Operator.And &&\n            condition.operator <= Operator.Nor\n        ) {\n            assert(bounds[index].length > 0);\n            return typeTree(conditions, bounds[index].start, bounds);\n        }\n\n        result.paramType = condition.paramType;\n        if (bounds[index].length > 0) {\n            uint256 start = bounds[index].start;\n            uint256 end = condition.paramType == ParameterType.Array\n                ? bounds[index].start + 1\n                : bounds[index].end;\n            result.children = new TypeTree[](end - start);\n            for (uint256 i = start; i < end; ) {\n                result.children[i - start] = typeTree(conditions, i, bounds);\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}\n"
          },
          "contracts/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\n/**\n * @title Types - a file that contains all of the type definitions used throughout\n * the Zodiac Roles Mod.\n * @author Cristóvão Honorato - <cristovao.honorato@gnosis.io>\n * @author Jan-Felix Schwarz  - <jan-felix.schwarz@gnosis.io>\n */\n\nenum ParameterType {\n    None,\n    Static,\n    Dynamic,\n    Tuple,\n    Array,\n    Calldata,\n    AbiEncoded\n}\n\nenum Operator {\n    // 00:    EMPTY EXPRESSION (default, always passes)\n    //          paramType: Static / Dynamic / Tuple / Array\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          🚫 compValue\n    /* 00: */ Pass,\n    // ------------------------------------------------------------\n    // 01-04: LOGICAL EXPRESSIONS\n    //          paramType: None\n    //          ✅ children\n    //          🚫 compValue\n    /* 01: */ And,\n    /* 02: */ Or,\n    /* 03: */ Nor,\n    /* 04: */ _Placeholder04,\n    // ------------------------------------------------------------\n    // 05-14: COMPLEX EXPRESSIONS\n    //          paramType: Calldata / AbiEncoded / Tuple / Array,\n    //          ✅ children\n    //          🚫 compValue\n    /* 05: */ Matches,\n    /* 06: */ ArraySome,\n    /* 07: */ ArrayEvery,\n    /* 08: */ ArraySubset,\n    /* 09: */ _Placeholder09,\n    /* 10: */ _Placeholder10,\n    /* 11: */ _Placeholder11,\n    /* 12: */ _Placeholder12,\n    /* 13: */ _Placeholder13,\n    /* 14: */ _Placeholder14,\n    // ------------------------------------------------------------\n    // 15:    SPECIAL COMPARISON (without compValue)\n    //          paramType: Static\n    //          🚫 children\n    //          🚫 compValue\n    /* 15: */ EqualToAvatar,\n    // ------------------------------------------------------------\n    // 16-31: COMPARISON EXPRESSIONS\n    //          paramType: Static / Dynamic / Tuple / Array\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          ✅ compValue\n    /* 16: */ EqualTo, // paramType: Static / Dynamic / Tuple / Array\n    /* 17: */ GreaterThan, // paramType: Static\n    /* 18: */ LessThan, // paramType: Static\n    /* 19: */ SignedIntGreaterThan, // paramType: Static\n    /* 20: */ SignedIntLessThan, // paramType: Static\n    /* 21: */ Bitmask, // paramType: Static / Dynamic\n    /* 22: */ Custom, // paramType: Static / Dynamic / Tuple / Array\n    /* 23: */ _Placeholder23,\n    /* 24: */ _Placeholder24,\n    /* 25: */ _Placeholder25,\n    /* 26: */ _Placeholder26,\n    /* 27: */ _Placeholder27,\n    /* 28: */ WithinAllowance, // paramType: Static\n    /* 29: */ EtherWithinAllowance, // paramType: None\n    /* 30: */ CallWithinAllowance, // paramType: None\n    /* 31: */ _Placeholder31\n}\n\nenum ExecutionOptions {\n    None,\n    Send,\n    DelegateCall,\n    Both\n}\n\nenum Clearance {\n    None,\n    Target,\n    Function\n}\n\n// This struct is a flattened version of Condition\n// used for ABI encoding a scope config tree\n// (ABI does not support recursive types)\nstruct ConditionFlat {\n    uint8 parent;\n    ParameterType paramType;\n    Operator operator;\n    bytes compValue;\n}\n\nstruct Condition {\n    ParameterType paramType;\n    Operator operator;\n    bytes32 compValue;\n    Condition[] children;\n}\nstruct ParameterPayload {\n    uint256 location;\n    uint256 size;\n    ParameterPayload[] children;\n}\n\nstruct TargetAddress {\n    Clearance clearance;\n    ExecutionOptions options;\n}\n\nstruct Role {\n    mapping(address => bool) members;\n    mapping(address => TargetAddress) targets;\n    mapping(bytes32 => bytes32) scopeConfig;\n}\n\n/// @notice The order of members in the `Allowance` struct is significant; members updated during accrual (`balance` and `timestamp`) should be stored in the same word.\n/// @custom:member refill Amount added to balance after each period elapses.\n/// @custom:member maxRefill Refilling stops when balance reaches this value.\n/// @custom:member period Duration, in seconds, before a refill occurs. If set to 0, the allowance is for one-time use and won't be replenished.\n/// @custom:member balance Remaining allowance available for use. Decreases with usage and increases after each refill by the specified refill amount.\n/// @custom:member timestamp Timestamp when the last refill occurred.\nstruct Allowance {\n    uint128 refill;\n    uint128 maxRefill;\n    uint64 period;\n    uint128 balance;\n    uint64 timestamp;\n}\n\nstruct Consumption {\n    bytes32 allowanceKey;\n    uint128 balance;\n    uint128 consumed;\n}\n"
          },
          "contracts/WriteOnce.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\ninterface ISingletonFactory {\n    function deploy(\n        bytes memory initCode,\n        bytes32 salt\n    ) external returns (address);\n}\n\nlibrary WriteOnce {\n    address public constant SINGLETON_FACTORY =\n        0xce0042B868300000d44A59004Da54A005ffdcf9f;\n\n    bytes32 public constant SALT =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /**\n    @notice Stores `data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `data` as code\n    @param data to be written\n    @return pointer Pointer to the written `data`\n  */\n    function store(bytes memory data) internal returns (address pointer) {\n        bytes memory creationBytecode = creationBytecodeFor(data);\n        pointer = addressFor(creationBytecode);\n\n        uint256 size;\n        assembly {\n            size := extcodesize(pointer)\n        }\n\n        if (size == 0) {\n            assert(\n                pointer ==\n                    ISingletonFactory(SINGLETON_FACTORY).deploy(\n                        creationBytecode,\n                        SALT\n                    )\n            );\n        }\n    }\n\n    /**\n    @notice Reads the contents of the `pointer` code as data, skips the first byte\n    @dev The function is intended for reading pointers generated by `store`\n    @param pointer to be read\n    @return runtimeBytecode read from `pointer` contract\n  */\n    function load(\n        address pointer\n    ) internal view returns (bytes memory runtimeBytecode) {\n        uint256 rawSize;\n        assembly {\n            rawSize := extcodesize(pointer)\n        }\n        assert(rawSize > 1);\n\n        // jump over the prepended 00\n        uint256 offset = 1;\n        // don't count with the 00\n        uint256 size = rawSize - 1;\n\n        runtimeBytecode = new bytes(size);\n        assembly {\n            extcodecopy(pointer, add(runtimeBytecode, 32), offset, size)\n        }\n    }\n\n    function addressFor(\n        bytes memory creationBytecode\n    ) private pure returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                SINGLETON_FACTORY,\n                SALT,\n                keccak256(creationBytecode)\n            )\n        );\n        // get the right most 20 bytes\n        return address(uint160(uint256(hash)));\n    }\n\n    /**\n    @notice Generate a creation code that results on a contract with `data` as bytecode\n    @param data the buffer to be stored\n    @return creationBytecode (constructor) for new contract\n    */\n    function creationBytecodeFor(\n        bytes memory data\n    ) private pure returns (bytes memory) {\n        /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(data.length + 1),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                // Prepend 00 to data so contract can't be called\n                hex\"00\",\n                data\n            );\n    }\n}\n"
          }
        },
        "settings": {
          "evmVersion": "shanghai",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "evm.bytecode",
                "evm.deployedBytecode",
                "devdoc",
                "userdoc",
                "metadata",
                "abi"
              ]
            }
          },
          "libraries": {
            "contracts/Integrity.sol": {
              "Integrity": "0x6a6af4b16458bc39817e4019fb02bd3b26d41049"
            },
            "contracts/packers/Packer.sol": {
              "Packer": "0x61c5b1be435391fdd7bc6703f3740c0d11728a8c"
            }
          }
        }
      }
    },
    "3.0.0": {
      "contractName": "Roles",
      "sourceName": "contracts/Roles.sol",
      "contractVersion": "3.0.0",
      "compilerVersion": "v0.8.30+commit.73712a01",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x80f47a9097D4812c2FFa56111504c049c8FE1f0e",
      "bytecode": "0x608060405234801561000f575f5ffd5b5060405161638938038061638983398101604081905261002e91610329565b604080516001600160a01b03858116602083015284811682840152831660608083019190915282518083039091018152608090910190915261006f81610078565b505050506103b7565b5f54610100900460ff161580801561009657505f54600160ff909116105b806100af5750303b1580156100af57505f5460ff166001145b6101165760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840160405180910390fd5b5f805460ff191660011790558015610137575f805461ff0019166101001790555b5f5f5f8480602001905181019061014e9190610329565b9194509250905061015e83610256565b606580546001600160a01b038085166001600160a01b03199283161790925560668054928416929091169190911790556101966102a7565b816001600160a01b0316836001600160a01b0316336001600160a01b03167f71d740fcd2b4a7ab76df6fe093ae985960dabcc06cf64811bc538bcfb695e61284604051806040016040528060058152602001640332e302e360dc1b815250604051610202929190610373565b60405180910390a45050508015610252575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b60015f5260686020525f5160206163695f395f51905f52546001600160a01b0316156102e65760405163dfd49ebd60e01b815260040160405180910390fd5b60015f81905260686020525f5160206163695f395f51905f5280546001600160a01b0319169091179055565b6001600160a01b0381168114610326575f5ffd5b50565b5f5f5f6060848603121561033b575f5ffd5b835161034681610312565b602085015190935061035781610312565b604085015190925061036881610312565b809150509250925092565b60018060a01b0383168152604060208201525f82518060408401528060208501606085015e5f606082850101526060601f19601f8301168401019150509392505050565b615fa5806103c45f395ff3fe608060405234801561000f575f5ffd5b506004361061020a575f3560e01c8063715018a61161011b578063c6fe8747116100b4578063e29dfba811610079578063e29dfba8146105a0578063f1637e57146105cd578063f2fde38b146105e0578063f394e965146105f3578063ffa1ad7414610606575f5ffd5b8063c6fe874714610533578063cc2f845214610546578063d4b8399214610567578063d8afba761461057a578063e009cfde1461058d575f5ffd5b8063715018a614610495578063776d1a011461049d5780638bb9c5bf146104b05780638da5cb5b146104c3578063946d364e146104d4578063957ed2b3146104e7578063a4f9edbf146104fa578063a8ec43ee1461050d578063bbb0d2ec14610520575f5ffd5b80632d3c2547116101a75780635aef7de61161016c5780635aef7de6146103b15780635e7c9fe8146103c4578063610b59251461045c57806366523f7d1461046f57806369ecc3cf14610482575f5ffd5b80632d3c2547146103015780632d9ad53d1461032e578063468721a714610351578063478a8a71146103645780635229073f1461039e575f5ffd5b80624825f71461020e5780630172a43a14610223578063086cfca8146102365780630c6c76b814610249578063185ea8441461025c578063208dd1ff146102855780632916a9af146102985780632959513c146102ab5780632b99e506146102e0575b5f5ffd5b61022161021c366004614c26565b61062a565b005b610221610231366004614c84565b6106f8565b610221610244366004614cb2565b61076a565b610221610257366004614c84565b6107c3565b61026f61026a366004614e03565b61082c565b60405161027c9190614f4d565b60405180910390f35b610221610293366004614f5f565b6108b6565b6102216102a6366004614fa0565b610901565b6102d36102b9366004614fe6565b606b6020525f90815260409020546001600160a01b031681565b60405161027c9190614ffd565b6102f36102ee366004615067565b6109a6565b60405161027c9291906150f0565b61032061030f366004614cb2565b606c6020525f908152604090205481565b60405190815260200161027c565b61034161033c366004614cb2565b610acd565b604051901515815260200161027c565b61034161035f36600461510a565b610b03565b610377610372366004614fe6565b610b49565b604080516001600160801b0390931683526001600160401b0390911660208301520161027c565b6102f36103ac36600461510a565b610b5e565b6065546102d3906001600160a01b031681565b61041d6103d2366004614fe6565b606a6020525f9081526040902080546001909101546001600160801b0380831692600160801b90048116916001600160401b0380821692600160401b83041691600160c01b90041685565b604080516001600160801b03968716815294861660208601526001600160401b039384169085015293166060830152909116608082015260a00161027c565b61022161046a366004614cb2565b610ba9565b61022161047d366004615178565b610cb8565b610221610490366004614fe6565b610d42565b610221610d94565b6102216104ab366004614cb2565b610da7565b6102216104be366004614fe6565b610e00565b6033546001600160a01b03166102d3565b6102216104e2366004614f5f565b610e3a565b6102216104f53660046151ea565b610e92565b61022161050836600461526a565b610f19565b61022161051b36600461529b565b6110ee565b61022161052e366004615312565b6112ae565b610341610541366004615067565b61139a565b610559610554366004614f5f565b6114b9565b60405161027c929190615387565b6066546102d3906001600160a01b031681565b6103206105883660046153e9565b611649565b61022161059b366004615430565b611767565b6103416105ae366004614f5f565b606760209081525f928352604080842090915290825290205460ff1681565b6102216105db36600461545c565b61185e565b6102216105ee366004614cb2565b611954565b6102216106013660046154ac565b6119cd565b61026f604051806040016040528060058152602001640332e302e360dc1b81525081565b610632611af4565b826001600160801b03165f0361064f576001600160801b03610651565b825b5f858152606a6020526040908190206001810180546001600160801b03808616600160801b02888216179093556001600160401b0386811667ffffffffffffffff198316179092559251939650600160c01b83041692600160401b90920416907f63d7ec44a20b176da1d60d75259d264ee67b3d8213706afa71a28f69ed8ebece906106e890889084908990899089908990615506565b60405180910390a1505050505050565b610700611af4565b5f8281526069602090815260408083206001600160a01b038516845260010190915290819020805460ff19169055517f3ccf62aacc3286173cedf5c20ec550071636a2faf0a3b28d93841736a43f822b9061075e9084908490615544565b60405180910390a15050565b610772611af4565b606580546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f52ae88b092de36f87fb43fe794eb1381023b9c1bce563a871154022c63dce342905f90a35050565b6107cb611af4565b5f8281526069602090815260408083206001600160a01b038516845260010190915290819020805460ff19166002179055517f277465b84f512b759d745fab70327b693ee21ce592fca91a3f491739a25fa76a9061075e9084908490615544565b8051606090156108b157604051634031b16960e11b81527377172caa8409e651a74627013b77cedb00e53d5c9063806362d29061086d90859060040161556f565b5f60405180830381865af4158015610887573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526108ae9190810190615672565b90505b919050565b6108be611af4565b5f8181526069602090815260408083206001600160a01b038616845290915280822091909155515f516020615f505f395f51905f529061075e9083908590615544565b610909611af4565b60a082901c63ffffffff60401b16606084811b6001600160601b031916919091175f908152606b602090815260409182902080546001600160a01b0319166001600160a01b03868116918217909255835191881682526001600160e01b0319871692820192909252918201527f1330d96b64c7e86736f77e027ca34223dd3d1d08049281281c9d597d8098ed5991015b60405180910390a1505050565b5f606060ff825c16156109cc5760405163558a1e0360e11b815260040160405180910390fd5b60015f805c60ff19168217905d505f5f6109e586611b4e565b915091505f6109f8878d8d8d8d8d611d6f565b606654604051635229073f60e01b81529192506001600160a01b031690635229073f90610a31908f908f908f908f908f906004016156df565b5f604051808303815f875af1158015610a4c573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a739190810190615715565b9095509350858015610a83575084155b15610aa15760405163d27b44a960e01b815260040160405180910390fd5b8415610ab357610ab383888484611f2a565b505f91505060ff19815c16815d5097509795505050505050565b5f60016001600160a01b038316148015906108ae5750506001600160a01b039081165f9081526068602052604090205416151590565b5f610b3d8686868686606c5f610b1761208f565b6001600160a01b03166001600160a01b031681526020019081526020015f20545f61139a565b90505b95945050505050565b5f5f610b5583426120ea565b91509150915091565b5f6060610b9a8787878787606c5f610b7461208f565b6001600160a01b03166001600160a01b031681526020019081526020015f20545f6109a6565b915091505b9550959350505050565b610bb1611af4565b6001600160a01b0381161580610bd057506001600160a01b0381166001145b15610bf95780604051635c93ff2f60e11b8152600401610bf09190614ffd565b60405180910390fd5b6001600160a01b038181165f908152606860205260409020541615610c335780604051632061897360e01b8152600401610bf09190614ffd565b60686020525f516020615f305f395f51905f5280546001600160a01b038381165f81815260408082208054949095166001600160a01b03199485161790945560019052835490911617909155517fecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f844090610cad908390614ffd565b60405180910390a150565b610cc0611af4565b5f83815260696020526040812060020190610cdb84846122be565b81526020019081526020015f205f90557f32a3a599b308fc900a0e6513db2ad40bf0c94367da90048a4b308d8c6b2dd6ea838383604051610999939291909283526001600160a01b039190911660208301526001600160e01b031916604082015260600190565b335f908152606760209081526040808320848452825291829020805460ff1916600117905590518281527f89a77869d7b8125ba16e08a92ddc8cc26fb1fa47241971167954489a5e66c2559101610cad565b610d9c611af4565b610da55f6122e3565b565b610daf611af4565b606680546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f90cc2f570a6eb594b1580ea3e41247d2d73a55281889e86bd4ec2fc29c7e62d6905f90a35050565b5f8181526069602090815260408083203380855292528083209290925590515f516020615f505f395f51905f5291610cad91849190615544565b610e42611af4565b6001600160a01b0382165f818152606c6020908152604091829020849055815192835282018390527f60c85b61661a191efceebca036d48b290e04a1f08dd96472b920adbdd50c64e8910161075e565b610e9a611af4565b5f5b83811015610f11575f858583818110610eb757610eb7615762565b905060200201359050838383818110610ed257610ed2615762565b9050602002016020810190610ee79190615776565b15610efe57610ef987825f5f5f61185e565b610f08565b610f0887826108b6565b50600101610e9c565b505050505050565b5f54610100900460ff1615808015610f3757505f54600160ff909116105b80610f505750303b158015610f5057505f5460ff166001145b610fb35760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610bf0565b5f805460ff191660011790558015610fd4575f805461ff0019166101001790555b5f5f5f84806020019051810190610feb9190615791565b925092509250610ffa836122e3565b606580546001600160a01b038085166001600160a01b0319928316179092556066805492841692909116919091179055611032612334565b816001600160a01b0316836001600160a01b0316336001600160a01b03167f71d740fcd2b4a7ab76df6fe093ae985960dabcc06cf64811bc538bcfb695e61284604051806040016040528060058152602001640332e302e360dc1b81525060405161109e9291906157d0565b60405180910390a450505080156110ea575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200161075e565b5050565b6110f6611af4565b836001600160801b03165f03611113576001600160801b03611115565b835b9350806001600160401b03165f0361112d574261112f565b805b90506040518060a00160405280846001600160801b03168152602001856001600160801b03168152602001836001600160401b03168152602001866001600160801b03168152602001826001600160401b0316815250606a5f8881526020019081526020015f205f820151815f015f6101000a8154816001600160801b0302191690836001600160801b031602179055506020820151815f0160106101000a8154816001600160801b0302191690836001600160801b031602179055506040820151816001015f6101000a8154816001600160401b0302191690836001600160401b0316021790555060608201518160010160086101000a8154816001600160801b0302191690836001600160801b0316021790555060808201518160010160186101000a8154816001600160401b0302191690836001600160401b031602179055509050507f63d7ec44a20b176da1d60d75259d264ee67b3d8213706afa71a28f69ed8ebece8686868686866040516106e896959493929190615506565b6112b6611af4565b5f6112c185856122be565b90507377172caa8409e651a74627013b77cedb00e53d5c63deccf5c56112e68561239f565b846040518363ffffffff1660e01b8152600401611304929190615803565b602060405180830381865af415801561131f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113439190615824565b5f8781526069602090815260408083208584526002019091529081902091909155517f26a44757465171eb4f80c373b9af082102799426e142527100e9ff4d6f4959e8906106e8908890889088908890889061583b565b5f60ff815c16156113be5760405163558a1e0360e11b815260040160405180910390fd5b60015f805c60ff19168217905d505f5f6113d785611b4e565b915091505f6113ea868c8c8c8c8c611d6f565b60665460405163468721a760e01b81529192506001600160a01b03169063468721a790611423908e908e908e908e908e906004016156df565b6020604051808303815f875af115801561143f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906114639190615883565b9350848015611470575083155b1561148e5760405163d27b44a960e01b815260040160405180910390fd5b83156114a0576114a083878484611f2a565b505f91505060ff19815c16815d50979650505050505050565b60605f6001600160a01b0384166001148015906114dc57506114da84610acd565b155b156114fc5783604051635c93ff2f60e11b8152600401610bf09190614ffd565b825f0361151c576040516372dbed9760e11b815260040160405180910390fd5b826001600160401b0381111561153457611534614ccd565b60405190808252806020026020018201604052801561155d578160200160208202803683370190505b506001600160a01b038086165f90815260686020526040812054929450911691505b6001600160a01b038216158015906115a157506001600160a01b038216600114155b80156115ac57508381105b1561160657818382815181106115c4576115c4615762565b6001600160a01b039283166020918202929092018101919091529281165f908152606890935260409092205490911690806115fe816158b2565b91505061157f565b6001600160a01b03821660011461163e57826116236001836158ca565b8151811061163357611633615762565b602002602001015191505b808352509250929050565b604080517f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218602082015246918101919091523060608201525f9081906080016040516020818303038152906040528051906020012090505f601960f81b600160f81b837f2939aeeda3ca260200c9f7b436b19e13207547ccc65cfedc857751c5ea6d91d45f1b89896040516116df9291906158dd565b6040805191829003822060208301939093528101919091526060810188905260800160408051808303601f190181529082905280516020918201206001600160f81b0319958616918301919091529290931660218401526022830152604282015260620160408051601f198184030181529190528051602090910120925050505b9392505050565b61176f611af4565b6001600160a01b038116158061178e57506001600160a01b0381166001145b156117ae5780604051635c93ff2f60e11b8152600401610bf09190614ffd565b6001600160a01b038281165f908152606860205260409020548116908216146117ec5780604051638b4189ff60e01b8152600401610bf09190614ffd565b6001600160a01b038181165f81815260686020526040808220805487861684528284208054919096166001600160a01b0319918216179095559290915281549092169055517faab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace40542769061075e908390614ffd565b611866611af4565b816001600160401b03165f03611883576001600160401b03611885565b815b9150806001600160801b03165f036118a4576001600160801b036118a6565b805b5f8581526069602090815260408083206001600160a01b038a16845290915290206001600160c01b031960c086901b1667ffffffffffffffff60801b608086901b16176001600160801b038316179055905061190185610acd565b61190e5761190e85610ba9565b7fc219bba489e694cb40935d0de27d36ecbe6f1e1b68a2b10c4cbf425a13b864ff84868585856040516119459594939291906158ec565b60405180910390a15050505050565b61195c611af4565b6001600160a01b0381166119c15760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610bf0565b6119ca816122e3565b50565b6119d5611af4565b5f8481526069602090815260408083206001600160a01b03871684526001908101909252909120805460ff191690911790556001600160601b03606084901b6001600160601b031916177377172caa8409e651a74627013b77cedb00e53d5c63deccf5c5611a428561239f565b846040518363ffffffff1660e01b8152600401611a60929190615803565b602060405180830381865af4158015611a7b573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611a9f9190615824565b5f8681526069602090815260408083208584526002019091529081902091909155517fcb2de7cf74f9a284fba57b728e12df91b3a78b370e52654fac00370219f63cef9061194590879087908790879061592a565b6033546001600160a01b03163314610da55760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610bf0565b335f9081526068602052604081205481906001600160a01b0316611c5d575f5f611b7661242b565b6001600160a01b038082165f9081526068602052604090205492945090925016611bb55733604051634a0bfec160e01b8152600401610bf09190614ffd565b6001600160a01b0381165f90815260676020908152604080832085845290915290205460ff1615611bfc57604051639e1dc0c560e01b815260048101839052602401610bf0565b6001600160a01b0381165f908152606760209081526040808320858452825291829020805460ff1916600117905590518381527f8c8e19e7e8e193118a05465d7676e82215052d3cb150628fbf598105dc2bb6ab910160405180910390a150505b5f839003611c7e57604051631fb1d3e560e31b815260040160405180910390fd5b611c8661208f565b5f8481526069602090815260408083206001600160a01b0385168452909152812054919350819003611ccb57604051631fb1d3e560e31b815260040160405180910390fd5b60c081901c421015611cf057604051631f4cbe2760e11b815260040160405180910390fd5b608081901c6001600160401b0316421115611d1d5760405162bc3e2b60e21b815260040160405180910390fd5b801960801b5f03611d3257505f199050915091565b6001600160801b038116836001821115611d6257611d516001836158ca565b6001600160801b0319841617611d64565b5f5b935093505050915091565b60605f606b81611d8889611d83888a615962565b6122be565b815260208101919091526040015f20546001600160a01b0316905080611df057611de88886868560405180606001604052808d6001600160a01b031681526020018c8152602001896001811115611de157611de161555b565b9052612586565b915050611f20565b60405163c7a7b63560e01b81526001600160a01b0382169063c7a7b63590611e24908a908a908a908a908a906004016156df565b5f60405180830381865afa925050508015611e6057506040513d5f823e601f3d908101601f19168201604052611e5d919081019061599a565b60015b611e7d576040516315e649e960e01b815260040160405180910390fd5b5f5b8151811015611f1b575f828281518110611e9b57611e9b615762565b60200260200101519050611f108b898984606001519085608001518660600151611ec59190615a79565b92611ed293929190615a8c565b88604051806060016040528087602001516001600160a01b0316815260200187604001518152602001875f01516001811115611de157611de161555b565b945050600101611e7f565b50505b505b9695505050505050565b80515f5b81811015611fe4575f838281518110611f4957611f49615762565b6020026020010151905080602001516001600160801b031681604001516001600160801b03161115611f7d57611f7d615ab3565b5f611f8782612887565b825160408085015181519283526001600160801b0390811660208401528316908201529091507f90355d540c2980efb4c360996dfc5405ee87e812e4f3db843857547cbdb5af659060600160405180910390a15050600101611f2e565b505f198303611ff35750612089565b5f8481526069602090815260408083206001600160a01b038916845290915290208390558215612069577fe9f3098d0a491e82485da5966eeb7d30e88f44596b8251c34539c8dceffc35cf848660c086901c608087901c8760405161205c9594939291906158ec565b60405180910390a1612087565b5f516020615f505f395f51905f528486604051611945929190615544565b505b50505050565b335f908152606860205260408120546001600160a01b0316156120b157503390565b5f6120ba61242b565b6001600160a01b038082165f90815260686020526040902054919350161590506120e357919050565b5f91505090565b5f5f5f61217d856040805160a0810182525f80825260208201819052918101829052606081018290526080810191909152505f908152606a60209081526040918290208054600190910154835160a0810185526001600160801b038084168252608093841c948201949094526001600160401b038216818601529381901c909216606084015260c09190911c9082015290565b905080604001516001600160401b03165f036121a7578060600151816080015192509250506122b7565b5f816040015182608001516121bc9190615ac7565b9050806001600160401b0316856001600160401b031610156121ed57816060015182608001519350935050506122b7565b5f82604001518360800151876122039190615ae6565b61220d9190615b19565b905082604001518161221f9190615b46565b836080015161222e9190615ac7565b935082602001516001600160801b031683606001516001600160801b03161061225e5750506060015191506122b7565b82515f90612276906001600160401b03841690615b68565b84606001516122859190615b8a565b905083602001516001600160801b0316816001600160801b0316106122ae5783602001516122b0565b805b9550505050505b9250929050565b6001600160601b0319606083901b1663ffffffff60401b60a083901c16175b92915050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b60015f5260686020525f516020615f305f395f51905f52546001600160a01b0316156123735760405163dfd49ebd60e01b815260040160405180910390fd5b60015f81905260686020525f516020615f305f395f51905f5280546001600160a01b0319169091179055565b606081515f03612427576040805160018082528183019092527377172caa8409e651a74627013b77cedb00e53d5c9163806362d29190816020015b604080516080810182525f80825260208083018290529282015260608082015282525f199092019101816123da579050506040518263ffffffff1660e01b815260040161086d919061556f565b5090565b5f808036606581101561244357505f93849350915050565b5f5f5f61245085856128d5565b919450925090505f6124636061866158ca565b90505f6124728683818a615a8c565b61247b91615ba9565b90508460ff165f036125015782600481108061249657508281115b156124ac57505f998a9950975050505050505050565b845f6124c36124bd84838c8e615a8c565b86611649565b90506124e182828c8c87908a926124dc93929190615a8c565b61294b565b6124ec575f806124ef565b80825b9b509b50505050505050505050509091565b5f61251761251184838a8c615a8c565b84611649565b604080515f81526020810180835283905260ff8916918101919091526060810187905260808101869052909150819060019060a0016020604051602081039080840390855afa15801561256c573d5f5f3e3d5ffd5b505050602060405103519950995050505050505050509091565b606083158015906125975750600484105b156125b557604051632342609160e11b815260040160405180910390fd5b5f86815260696020908152604080832085516001600160a01b0316845260018101909252822054909160ff909116908160028111156125f6576125f661555b565b03612617578351604051631408a22760e31b8152610bf09190600401614ffd565b5f80600183600281111561262d5761262d61555b565b1461264f5760a061263e898b615962565b6001600160e01b031916901c612658565b6001600160601b035b865160601b6001600160601b031916175f81815260028601602052604081205493509091508290036126c4578551612690898b615962565b604051636e916cdb60e11b81526001600160a01b0390921660048301526001600160e01b0319166024820152604401610bf0565b5060a081901c600181161580156126de57505f8660200151115b156126ff5785516040516305c5128b60e21b8152610bf09190600401614ffd565b6002811615801561272557506001866040015160018111156127235761272361555b565b145b156127465785516040516317645e7d60e21b8152610bf09190600401614ffd565b505f5f61275283612a2f565b915091505f6128318b8b5f868d6040518060a001604052808f5f01516001600160a01b031681526020018f6020015181526020018f60400151600181111561279c5761279c61555b565b8152602001896001600160401b038111156127b9576127b9614ccd565b6040519080825280602002602001820160405280156127e2578160200160208202803683370190505b508152602001896001600160401b0381111561280057612800614ccd565b604051908082528060200260200182016040528015612829578160200160208202803683370190505b509052612a4e565b90505f8151601b8111156128475761284761555b565b146128745780516020820151604080840151905163fba1422160e01b8152610bf093929190600401615bc6565b606001519b9a5050505050505050505050565b80516060820151604083015160208401515f9392916128a591615bee565b9250815f52606a602052600160405f20016001600160401b038154168460401b8360c01b17178155505050919050565b5f808084846128e56001826158ca565b6128f0928290615a8c565b6128f991615c0d565b60f81c9250848461290b6041826158ca565b612916928290615a8c565b61291f91615ba9565b9150848461292e6021826158ca565b612939928290615a8c565b61294291615ba9565b90509250925092565b5f843b80820361295e575f915050612a27565b5f866001600160a01b0316631626ba7e60e01b87878760405160240161298693929190615c43565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516129c49190615c5c565b5f60405180830381855afa9150503d805f81146129fc576040519150601f19603f3d011682016040523d82523d5f602084013e612a01565b606091505b509150630b135d3f60e11b9050612a1782615c72565b6001600160e01b03191614925050505b949350505050565b612a37614b91565b5f8281612a4382612dba565b9050611d6481612dea565b612a56614bd4565b6040840151601081601f811115612a6f57612a6f61555b565b1015612c40575f81601f811115612a8857612a8861555b565b03612a9657611de884612e8f565b600581601f811115612aaa57612aaa61555b565b03612af8575f86118015612ad35750600585602001516006811115612ad157612ad161555b565b145b612add5785612ae8565b612ae8866020615a79565b9550611de8888888888888612ebe565b600181601f811115612b0c57612b0c61555b565b03612b1f57611de8888888888888613031565b600281601f811115612b3357612b3361555b565b03612b4657611de88888888888886130a7565b600d81601f811115612b5a57612b5a61555b565b03612b6d57611de888888888888861312a565b600e81601f811115612b8157612b8161555b565b03612b9457611de88888888888886131e5565b600481601f811115612ba857612ba861555b565b03612bc757611de88715612bbd576017612bbf565b5f5b5f8787613290565b600681601f811115612bdb57612bdb61555b565b1480612bf85750600781601f811115612bf657612bf661555b565b145b15612c0b57611de88888888888886132c9565b600881601f811115612c1f57612c1f61555b565b03612c3257611de88888888888886133ec565b611de88888888888886134ec565b601481601f811115612c5457612c5461555b565b11612cbc575f5f612c688a8a8a8a89613689565b91509150612cb281612ca757601284601f811115612c8857612c8861555b565b1115612c9d57612c98838961379a565b612caa565b612c9883896137fe565b60145b898989613290565b9350505050611f20565b601581601f811115612cd057612cd061555b565b03612cf557611de8612ced89898989606001518a60a001516138a6565b878787613290565b601c81601f811115612d0957612d0961555b565b03612d3f575f5f612d1d8a8a8a8a89613689565b915091508015612d3357612cb2601489896139af565b612cb2828989896139f6565b601e81601f811115612d5357612d5361555b565b03612d6557611de860018787876139f6565b601781601f811115612d7957612d7961555b565b03612d9357611de8612ced86606001518560600151613a1f565b611de8612ced8660600151855f015186602001518c8c89604001518d8d8c60600151613af6565b60606001823b03601f19601f82011660405192508183528060208401016040525080600160208401853c50919050565b612df2614b91565b5f80612dfd84615cb0565b60e881901c91505f9060f01c6001600160401b03811115612e2057612e20614ccd565b604051908082528060200260200182016040528015612e5957816020015b612e46614b91565b815260200190600190039081612e3e5790505b509050612e668582613b7c565b805f81518110612e7857612e78615762565b602002602001015193508160ff1692505050915091565b612e97614bd4565b6040805160808101909152805f81525f602082018190526040820152606001929092525090565b612ec6614bd4565b5f8460600151516020612ed991906158ca565b90506020811015612f515786612ef08260206158ca565b612efa9088615a79565b1115612f0c57611de8601487876139af565b5f818660600151612f1c90615ce9565b901c90505f82612f2e8a8a818e615a8c565b612f3791615ba9565b901c9050808214612f4e57612cb2601889896139af565b50505b5f5f612f6e8a8a8960e001518b612f689190615a79565b8a613d66565b915091508015612f8457612cb2601489896139af565b815187608001515114612f9d57612cb2600589896139af565b606084018690525f5b825181101561302357612ff78b8b858481518110612fc657612fc6615762565b60200260200101518b608001518581518110612fe457612fe4615762565b602002602001015189606001518b612a4e565b94505f8551601b81111561300d5761300d61555b565b1461301b5750505050611f20565b600101612fa6565b505050509695505050505050565b613039614bd4565b606081018390525f5b846080015151811015611f1e5761307e8888888860800151858151811061306b5761306b615762565b6020026020010151866060015188612a4e565b91505f8251601b8111156130945761309461555b565b1461309f5750611f20565b600101613042565b6130af614bd4565b5f5b846080015151811015613112576130e9888888886080015185815181106130da576130da615762565b60200260200101518888612a4e565b91505f8251601b8111156130ff576130ff61555b565b0361310a5750611f20565b6001016130b1565b5061311f600186866139af565b979650505050505050565b613132614bd4565b5f846060015161314190615d0c565b60f01c90505f856060015160028151811061315e5761315e615762565b602001015160f81c60f81b60f81c90505f86608001515f8151811061318557613185615762565b602002602001015190508160ff168160c00181815250506131d78a8a8561ffff168a60a001516131b65760206131b8565b5f5b6131c59060ff168d615a79565b6131cf9190615a79565b848a8a612a4e565b9a9950505050505050505050565b6131ed614bd4565b5f5f6131fc8989898988613689565b91509150801561321b57613212601488886139af565b92505050611f20565b5f86606001515f8151811061323257613232615762565b01602001516080860151805160f89290921c925089918390811061325857613258615762565b602002602001018181525050828560600151828151811061327b5761327b615762565b6020026020010181815250506131d786612e8f565b613298614bd4565b5f85601b8111156132ab576132ab61555b565b146132c0576132bb8585856139af565b610b40565b610b4082612e8f565b6132d1614bd4565b5f60078560400151601f8111156132ea576132ea61555b565b1490505f5f6132fb8a8a8a8a613d66565b91509150801561331157612cb2601489896139af565b606084018690525f5b82518110156133d5576133778b8b85848151811061333a5761333a615762565b60200260200101518b608001515f8151811061335857613358615762565b60200260200101518861336b578b613371565b89606001515b8b612a4e565b945083156133ab575f8551601b8111156133935761339361555b565b146133a65750506006835250611f209050565b6133cd565b5f8551601b8111156133bf576133bf61555b565b036133cd5750505050611f20565b60010161331a565b5082611f1b576133e7600789896139af565b6131d7565b6133f4614bd4565b5f5f61340289898989613d66565b91509150801561341857613212601488886139af565b60808601515182518181101561343f5761343460058a8a6139af565b945050505050611f20565b5f61344a83836158ca565b6060870189905290505f5b838110156134dc576134ae8d8d8861346d8587615a79565b8151811061347d5761347d615762565b60200260200101518d60800151858151811061349b5761349b615762565b60200260200101518b606001518d612a4e565b96505f8751601b8111156134c4576134c461555b565b146134d457505050505050611f20565b600101613455565b5050505050509695505050505050565b6134f4614bd4565b5f600b8560400151601f81111561350d5761350d61555b565b1490505f5f5f61351f8b8b8a89613f14565b919450925090505f81601b8111156135395761353961555b565b1461354957613434818a8a6139af565b5f88608001515f8151811061356057613560615762565b60200260200101516080015190508786606001819052505f5b83811015613660578561358e57606087018990525b60015f5b8351811015613623576135f88f8f8984815181106135b2576135b2615762565b602002602001015186815181106135cb576135cb615762565b60200260200101518785815181106135e5576135e5615762565b60200260200101518d606001518f612a4e565b98505f8951601b81111561360e5761360e61555b565b1461361b575f9150613623565b600101613592565b5086156136455780613640575050601b865250611f209350505050565b613657565b80156136575750505050505050611f20565b50600101613579565b508461367757613672601a8b8b6139af565b613679565b855b9c9b505050505050505050505050565b5f8080846020015160068111156136a2576136a261555b565b036136b457505060208101515f610b9f565b5f8460c001515f036136d1576136cc888888886140e0565b6136d7565b8460c001515b9050866136e48288615a79565b11156136f757505f915060019050610b9f565b8060200361370c57505050848301355f610b9f565b602081101561375b576137208160206158ca565b61372b906008615d46565b8887896137388583615a79565b9261374593929190615a8c565b61374e91615ba9565b901c5f9250925050610b9f565b8786886137688483615a79565b9261377593929190615a8c565b6040516137839291906158dd565b604051908190039020985f98509650505050505050565b60608101515f90839082906137ae90615ce9565b905060138460400151601f8111156137c8576137c861555b565b036137e6578082136137db5760036137dd565b5f5b925050506122dd565b8082126137f4576004610b40565b5f95945050505050565b5f5f60208360600151511161382057826060015161381b90615ce9565b61382d565b8260600151805190602001205b905060108360400151601f8111156138475761384761555b565b036138645780841461385a57600261385c565b5f5b9150506122dd565b60118360400151601f81111561387c5761387c61555b565b0361388f5780841161385a57600361385c565b80841061389d576004612a27565b5f949350505050565b5f806138b184615d0c565b60f01c61ffff1690505f60028086516138ca91906158ca565b6138d49190615d5d565b90505f846138e35760206138e5565b5f5b6138f29060ff1688615a79565b9050876138ff82826158ca565b6139098486615a79565b111561391c576008945050505050610b40565b365f61392a8b85818f615a8c565b915091505f5b8581101561399d576022818b018101518783018c01909101518883018501355f61396261395d868c6158ca565b61430a565b90508084831616818416146139855760099b505050505050505050505050610b40565b505050506020816139969190615a79565b9050613930565b505f9c9b505050505050505050505050565b6139b7614bd4565b6060604051806080016040528086601b8111156139d6576139d661555b565b815284516020820152604081018690526060019190915290509392505050565b6139fe614bd4565b5f5f613a0f8488876060015161433c565b9150915061311f82878784613290565b5f5f613a2a8461454a565b90505f5f5f613a398487614610565b919450925090505f83601b811115613a5357613a5361555b565b14613a6457829450505050506122dd565b5f82613a7261271084615d46565b613a7c9190615d5d565b9050846080015163ffffffff165f14158015613aa15750846080015163ffffffff1681105b15613ab4576015955050505050506122dd565b60a085015163ffffffff1615801590613ad657508460a0015163ffffffff1681115b15613ae9576016955050505050506122dd565b505f979650505050505050565b5f80613b018b615d70565b60601c90505f8460c001515f03613b2357613b1e898988886140e0565b613b29565b8460c001515b9050606060148d511115613b595760148d510360405191508060400182016040528082528060348f01602084015e505b613b6b838d8d8d8d8d8d89898e61470a565b9d9c50505050505050505050505050565b8051602380840191600402840101604083015f5b8451811015610f11575f845160e01c90506004850194505f868381518110613bba57613bba615762565b602002602001015190505f601d83901c905080600603613bd757505f5b8382526103ff600e84901c16611fff600185901c16826006811115613bfe57613bfe61555b565b84602001906006811115613c1457613c1461555b565b90816006811115613c2757613c2761555b565b81525050601885901c601f16601f811115613c4457613c4461555b565b8460400190601f811115613c5a57613c5a61555b565b9081601f811115613c6d57613c6d61555b565b90525080151560a085015260c084018190526001851615613cd957875160029098019760f01c6005849003613cb157885160f01c60e0860152600290980197600119015b8015613cd757604051816020820101604052818152818a602083015e6060860152978801975b505b8115613d0457602082026040518160208201016040528381528189602083015e608086015296909601955b600f8460400151601f811115613d1c57613d1c61555b565b03613d565760106040850181905250606554604051613d3f908290602001614ffd565b60408051601f198184030181529190526060860152505b5050505050806001019050613b90565b6080810151516060905f9081600485602001516006811115613d8a57613d8a61555b565b1490508015613dc55786613d9f876020615a79565b1115613db1575060019150613f0b9050565b878601359150613dc2602087615a79565b95505b5f826001600160401b03811115613dde57613dde614ccd565b604051908082528060200260200182016040528015613e07578160200160208202803683370190505b5090505f5f5b84811015613f00575f886080015185613e265782613e28565b5f5b81518110613e3857613e38615762565b602002602001015190508060a0015115613e8957613e56838b615a79565b848381518110613e6857613e68615762565b602090810291909101015260c0810151613e829084615a79565b9250613ec3565b613e958c8c8c86614825565b848381518110613ea757613ea7615762565b602002602001018181525050602083613ec09190615a79565b92505b8b8b9050848381518110613ed957613ed9615762565b60200260200101511115613ef7575060019550613f0b945050505050565b50600101613e0d565b509094505f93505050505b94509492505050565b60605f5f5f85608001515f81518110613f2f57613f2f615762565b6020026020010151608001519050613f45614b91565b6004602082018190525060408051600180825281830190925290816020015b613f6c614b91565b815260200190600190039081613f64575050608082015281516001600160401b03811115613f9c57613f9c614ccd565b604051908082528060200260200182016040528015613fcf57816020015b6060815260200190600190039081613fba5790505b5094505f5b82518110156140d257828181518110613fef57613fef615762565b602002602001015182608001515f8151811061400d5761400d615762565b60200260200101819052505f5f6140648c8c8b608001518d60600151878151811061403a5761403a615762565b0160200151815160f89190911c90811061405657614056615762565b602002602001015187613d66565b91509150801561408057505f9550601494506140d69350505050565b825f0361409057815196506140aa565b815187146140aa57505f9550601994506140d69350505050565b818884815181106140bd576140bd615762565b60209081029190910101525050600101613fd4565b5050505b9450945094915050565b60208101515f9060018160068111156140fb576140fb61555b565b0361410a576020915050612a27565b84614116856020615a79565b111561412f57614127856001615a79565b915050612a27565b8584013560028260068111156141475761414761555b565b1480614164575060058260068111156141625761416261555b565b145b1561418c57601f1961417782601f615a79565b61418391166020615a79565b92505050612a27565b6080840151515f8360068111156141a5576141a561555b565b0361421a575f5b81811015614204576141dd898989896080015185815181106141d0576141d0615762565b60200260200101516140e0565b94505f851180156141ee5750878511155b156141fc5750505050612a27565b6001016141ac565b50614210876001615a79565b9350505050612a27565b5f600484600681111561422f5761422f61555b565b149050801561424d57829150614246602088615a79565b9650602094505b5f5f5b838110156142fc575f886080015184614269578261426b565b5f5b8151811061427b5761427b615762565b602002602001015190508060a00151156142b75760c081015161429e9089615a79565b97508060c00151836142b09190615a79565b92506142f3565b6142ce8c8c6142c88f8f8f89614825565b846140e0565b6142d9906020615a79565b6142e39089615a79565b97506142f0602084615a79565b92505b50600101614250565b505050505050949350505050565b5f5f601f83116143245761431f8360206158ca565b614326565b5f5b614331906008615d46565b5f19901b9392505050565b5f60608161434984615ce9565b9050614355858561489d565b955092505f83601b81111561436c5761436c61555b565b1461437a5750849050614542565b5f5b86518110156143b1578187828151811061439857614398615762565b60200260200101515f015103156143b15760010161437c565b604080516080810182525f808252602082018190529181018290526060810191909152875182101561447757604051806080016040528084815260200189848151811061440057614400615762565b6020026020010151602001516001600160801b0316815260200189848151811061442c5761442c615762565b6020026020010151604001516001600160801b0316815260200189848151811061445857614458615762565b6020026020010151606001516001600160401b031681525090506144b8565b5f5f61448385426120ea565b604080516080810182528881526001600160801b0390931660208401525f908301526001600160401b03166060820152925050505b60408101516001600160801b03906144d39089908316615a79565b11156144e85760138894509450505050614542565b86816040018181516144fa9190615b8a565b6001600160801b039081169091526020830151604084015190821691161115905061452e5760128894509450505050614542565b5f61453a898385614973565b945094505050505b935093915050565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290529061459383615ce9565b60f881901c835260ff60f082901c811660208086019190915260e883901c8216604086015260e083901c909116606085015260c082811c63ffffffff908116608087015260a084811c909116908601526001600160a01b038316908501528451919250101561460a57604083015160601c60e08301525b50919050565b5f5f5f5f856060015160ff16866020015160ff1611614633578560600151614639565b85602001515b60ff16905061467685875f015160ff168151811061465957614659615762565b60200260200101515f1c876020015160ff16838960c001516149e6565b90945092505f84601b81111561468e5761468e61555b565b1461469f57505f9150819050614703565b6146d885876040015160ff16815181106146bb576146bb615762565b60200260200101515f1c876060015160ff16838960e001516149e6565b90945091505f84601b8111156146f0576146f061555b565b1461470157505f9150819050614703565b505b9250925092565b5f8a3b80820361471e57600b9150506131d7565b5f5f8d6001600160a01b03168d8d8d8d8d8d8d8d8d60405160240161474b99989796959493929190615daa565b60408051601f198184030181529181526020820180516001600160e01b0316634668d9c760e01b179052516147809190615c5c565b5f60405180830381855afa9150503d805f81146147b8576040519150601f19603f3d011682016040523d82523d5f602084013e6147bd565b606091505b5091509150816147d357600c93505050506131d7565b80516020146147e857600d93505050506131d7565b5f818060200190518101906147fd9190615883565b90508061481157600a9450505050506131d7565b505f9e9d5050505050505050505050505050565b5f836148318385615a79565b61483c906020615a79565b11156148545761484d846001615a79565b9050612a27565b82820185013582811161486c57614127856001615a79565b846148778286615a79565b614882906020615a79565b111561489357614127856001615a79565b611f208185615a79565b5f5f82516020036148b257505f9050826122b7565b5f836020815181106148c6576148c6615762565b602001015160f81c60f81b60f81c60ff1690505f846021815181106148ed576148ed615762565b016020015160f81c90508082106149245761490881836158ca565b61491390600a615f24565b61491d9087615d46565b9550614946565b61492e82826158ca565b61493990600a615f24565b6149439087615d5d565b95505b5f60228651111561495b5750604285015160601c5b6149658782614a1d565b945094505050509250929050565b82516060905f838214614986575f614989565b60015b6149969060ff1683615a79565b905060405192506020600182010283016040528083526020830160208701602084028082845e505050848385815181106149d2576149d2615762565b602002602001018190525050509392505050565b5f80614a106149f586866158ca565b614a0090600a615f24565b614a0a9088615d46565b84614a1d565b9150915094509492505050565b5f5f5f5f614a2a85614a80565b90925090505f82601b811115614a4257614a4261555b565b14614a52575091505f90506122b7565b5f614a5f6012600a615f24565b614a698389615d46565b614a739190615d5d565b9350935050509250929050565b5f806001600160a01b038316614a9d575f610b556012600a615f24565b823b5f819003614ab35750600e935f9350915050565b60408051600481526024810182526020810180516001600160e01b0316634c6afee560e11b17905290515f9182916001600160a01b03881691614af591615c5c565b5f60405180830381855afa9150503d805f8114614b2d576040519150601f19603f3d011682016040523d82523d5f602084013e614b32565b606091505b509150915081614b4a5750600f955f95509350505050565b8051602014614b6157506010955f95509350505050565b5f614b6b82615ce9565b90505f819003614b8457506011965f9650945050505050565b5f97909650945050505050565b6040805161010081019091525f808252602082019081526020015f815260200160608152602001606081526020015f151581526020015f81526020015f81525090565b6040805160808101909152805f81526020015f81526020015f8152602001606081525090565b80356001600160801b03811681146108b1575f5ffd5b80356001600160401b03811681146108b1575f5ffd5b5f5f5f5f60808587031215614c39575f5ffd5b84359350614c4960208601614bfa565b9250614c5760408601614bfa565b9150614c6560608601614c10565b905092959194509250565b6001600160a01b03811681146119ca575f5ffd5b5f5f60408385031215614c95575f5ffd5b823591506020830135614ca781614c70565b809150509250929050565b5f60208284031215614cc2575f5ffd5b813561176081614c70565b634e487b7160e01b5f52604160045260245ffd5b604051608081016001600160401b0381118282101715614d0357614d03614ccd565b60405290565b60405160a081016001600160401b0381118282101715614d0357614d03614ccd565b604051601f8201601f191681016001600160401b0381118282101715614d5357614d53614ccd565b604052919050565b5f6001600160401b03821115614d7357614d73614ccd565b5060051b60200190565b8035602081106108b1575f5ffd5b5f6001600160401b03821115614da357614da3614ccd565b50601f01601f191660200190565b5f82601f830112614dc0575f5ffd5b8135614dd3614dce82614d8b565b614d2b565b818152846020838601011115614de7575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60208284031215614e13575f5ffd5b81356001600160401b03811115614e28575f5ffd5b8201601f81018413614e38575f5ffd5b8035614e46614dce82614d5b565b8082825260208201915060208360051b850101925086831115614e67575f5ffd5b602084015b83811015611f1e5780356001600160401b03811115614e89575f5ffd5b85016080818a03601f19011215614e9e575f5ffd5b614ea6614ce1565b602082013561ffff81168114614eba575f5ffd5b8152604082013560078110614ecd575f5ffd5b6020820152614ede60608301614d7d565b604082015260808201356001600160401b03811115614efb575f5ffd5b614f0a8b602083860101614db1565b60608301525084525060209283019201614e6c565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6117606020830184614f1f565b5f5f60408385031215614f70575f5ffd5b8235614f7b81614c70565b946020939093013593505050565b80356001600160e01b0319811681146108b1575f5ffd5b5f5f5f60608486031215614fb2575f5ffd5b8335614fbd81614c70565b9250614fcb60208501614f89565b91506040840135614fdb81614c70565b809150509250925092565b5f60208284031215614ff6575f5ffd5b5035919050565b6001600160a01b0391909116815260200190565b5f5f83601f840112615021575f5ffd5b5081356001600160401b03811115615037575f5ffd5b6020830191508360208285010111156122b7575f5ffd5b600281106119ca575f5ffd5b80151581146119ca575f5ffd5b5f5f5f5f5f5f5f60c0888a03121561507d575f5ffd5b873561508881614c70565b96506020880135955060408801356001600160401b038111156150a9575f5ffd5b6150b58a828b01615011565b90965094505060608801356150c98161504e565b92506080880135915060a08801356150e08161505a565b8091505092959891949750929550565b8215158152604060208201525f612a276040830184614f1f565b5f5f5f5f5f6080868803121561511e575f5ffd5b853561512981614c70565b94506020860135935060408601356001600160401b0381111561514a575f5ffd5b61515688828901615011565b909450925050606086013561516a8161504e565b809150509295509295909350565b5f5f5f6060848603121561518a575f5ffd5b83359250602084013561519c81614c70565b915061294260408501614f89565b5f5f83601f8401126151ba575f5ffd5b5081356001600160401b038111156151d0575f5ffd5b6020830191508360208260051b85010111156122b7575f5ffd5b5f5f5f5f5f606086880312156151fe575f5ffd5b853561520981614c70565b945060208601356001600160401b03811115615223575f5ffd5b61522f888289016151aa565b90955093505060408601356001600160401b0381111561524d575f5ffd5b615259888289016151aa565b969995985093965092949392505050565b5f6020828403121561527a575f5ffd5b81356001600160401b0381111561528f575f5ffd5b612a2784828501614db1565b5f5f5f5f5f5f60c087890312156152b0575f5ffd5b863595506152c060208801614bfa565b94506152ce60408801614bfa565b93506152dc60608801614bfa565b92506152ea60808801614c10565b91506152f860a08801614c10565b90509295509295509295565b8035600481106108b1575f5ffd5b5f5f5f5f5f60a08688031215615326575f5ffd5b85359450602086013561533881614c70565b935061534660408701614f89565b925060608601356001600160401b03811115615360575f5ffd5b61536c88828901614db1565b92505061537b60808701615304565b90509295509295909350565b604080825283519082018190525f9060208501906060840190835b818110156153c95783516001600160a01b03168352602093840193909201916001016153a2565b50506001600160a01b039490941660209390930192909252509092915050565b5f5f5f604084860312156153fb575f5ffd5b83356001600160401b03811115615410575f5ffd5b61541c86828701615011565b909790965060209590950135949350505050565b5f5f60408385031215615441575f5ffd5b823561544c81614c70565b91506020830135614ca781614c70565b5f5f5f5f5f60a08688031215615470575f5ffd5b853561547b81614c70565b94506020860135935061549060408701614c10565b925061549e60608701614c10565b915061537b60808701614bfa565b5f5f5f5f608085870312156154bf575f5ffd5b8435935060208501356154d181614c70565b925060408501356001600160401b038111156154eb575f5ffd5b6154f787828801614db1565b925050614c6560608601615304565b9586526001600160801b0394851660208701529284166040860152921660608401526001600160401b0391821660808401521660a082015260c00190565b9182526001600160a01b0316602082015260400190565b634e487b7160e01b5f52602160045260245ffd5b5f602082016020835280845180835260408501915060408160051b8601019250602086015f5b8281101561561957868503603f190184528151805161ffff1686526020810151600781106155c5576155c561555b565b806020880152506040810151602081106155e1576155e161555b565b8060408801525060608101519050608060608701526156036080870182614f1f565b9550506020938401939190910190600101615595565b50929695505050505050565b5f82601f830112615634575f5ffd5b8151615642614dce82614d8b565b818152846020838601011115615656575f5ffd5b8160208501602083015e5f918101602001919091529392505050565b5f60208284031215615682575f5ffd5b81516001600160401b03811115615697575f5ffd5b612a2784828501615625565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b600281106156db576156db61555b565b9052565b60018060a01b0386168152846020820152608060408201525f6157066080830185876156a3565b9050611f2060608301846156cb565b5f5f60408385031215615726575f5ffd5b82516157318161505a565b60208401519092506001600160401b0381111561574c575f5ffd5b61575885828601615625565b9150509250929050565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215615786575f5ffd5b81356117608161505a565b5f5f5f606084860312156157a3575f5ffd5b83516157ae81614c70565b60208501519093506157bf81614c70565b6040850151909250614fdb81614c70565b6001600160a01b03831681526040602082018190525f90612a2790830184614f1f565b600481106156db576156db61555b565b604081525f6158156040830185614f1f565b905061176060208301846157f3565b5f60208284031215615834575f5ffd5b5051919050565b8581526001600160a01b03851660208201526001600160e01b03198416604082015260a0606082018190525f9061587490830185614f1f565b9050611f2060808301846157f3565b5f60208284031215615893575f5ffd5b81516117608161505a565b634e487b7160e01b5f52601160045260245ffd5b5f600182016158c3576158c361589e565b5060010190565b818103818111156122dd576122dd61589e565b818382375f9101908152919050565b9485526001600160a01b039390931660208501526001600160401b0391821660408501521660608301526001600160801b0316608082015260a00190565b8481526001600160a01b03841660208201526080604082018190525f9061595390830185614f1f565b9050610b4060608301846157f3565b80356001600160e01b03198116906004841015615993576001600160e01b0319600485900360031b81901b82161691505b5092915050565b5f602082840312156159aa575f5ffd5b81516001600160401b038111156159bf575f5ffd5b8201601f810184136159cf575f5ffd5b80516159dd614dce82614d5b565b80828252602082019150602060a084028501019250868311156159fe575f5ffd5b6020840193505b82841015611f205760a08488031215615a1c575f5ffd5b615a24614d09565b8451615a2f8161504e565b81526020850151615a3f81614c70565b60208281019190915260408681015190830152606080870151908301526080808701519083015290835260a0909401939190910190615a05565b808201808211156122dd576122dd61589e565b5f5f85851115615a9a575f5ffd5b83861115615aa6575f5ffd5b5050820193919092039150565b634e487b7160e01b5f52600160045260245ffd5b6001600160401b0381811683821601908111156122dd576122dd61589e565b6001600160401b0382811682821603908111156122dd576122dd61589e565b634e487b7160e01b5f52601260045260245ffd5b5f6001600160401b03831680615b3157615b31615b05565b806001600160401b0384160491505092915050565b6001600160401b0381811683821602908116908181146159935761599361589e565b6001600160801b0381811683821602908116908181146159935761599361589e565b6001600160801b0381811683821601908111156122dd576122dd61589e565b803560208310156122dd575f19602084900360031b1b1692915050565b60608101601c8510615bda57615bda61555b565b938152602081019290925260409091015290565b6001600160801b0382811682821603908111156122dd576122dd61589e565b80356001600160f81b03198116906001841015615993576001600160f81b031960019490940360031b84901b1690921692915050565b838152604060208201525f610b406040830184866156a3565b5f82518060208501845e5f920191825250919050565b805160208201516001600160e01b0319811691906004821015615ca9576001600160e01b0319600483900360031b81901b82161692505b5050919050565b805160208201516001600160e81b0319811691906003821015615ca9576001600160e81b0319600392830390921b82901b161692915050565b8051602080830151919081101561460a575f1960209190910360031b1b16919050565b805160208201516001600160f01b0319811691906002821015615ca9576001600160f01b031960029290920360031b82901b161692915050565b80820281158282048414176122dd576122dd61589e565b5f82615d6b57615d6b615b05565b500490565b805160208201516001600160601b0319811691906014821015615ca9576001600160601b031960149290920360031b82901b161692915050565b60018060a01b038a16815288602082015261010060408201525f615dd36101008301898b6156a3565b615de060608401896156cb565b8660808401528560a084015282810360c0840152615dfe8186614f1f565b83810360e0850152845180825260208087019350909101905f5b81811015615e36578351835260209384019390920191600101615e18565b50909d9c50505050505050505050505050565b6001815b600184111561454257808504811115615e6857615e6861589e565b6001841615615e7657908102905b60019390931c928002615e4d565b5f82615e92575060016122dd565b81615e9e57505f6122dd565b8160018114615eb45760028114615ebe57615eda565b60019150506122dd565b60ff841115615ecf57615ecf61589e565b50506001821b6122dd565b5060208310610133831016604e8410600b8410161715615efd575081810a6122dd565b615f095f198484615e49565b805f1904821115615f1c57615f1c61589e565b029392505050565b5f6117608383615e8456fe82eaf0fca2207f91f5027fcf68136c84edb7e928c081c42aa5bbc2a771c7d37676e6093c136cd7faa5a6d92b2b633f3b4595abd4a529b7a13917398355fea694a2646970667358221220f8c51b80d6ef85a00a8c75bf40548b396fad90a4ee1d8ab4ded32e1fb15e7a2d64736f6c634300081e003382eaf0fca2207f91f5027fcf68136c84edb7e928c081c42aa5bbc2a771c7d376",
      "constructorArgs": {
        "types": [
          "address",
          "address",
          "address"
        ],
        "values": [
          "0x0000000000000000000000000000000000000001",
          "0x0000000000000000000000000000000000000001",
          "0x0000000000000000000000000000000000000001"
        ]
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_avatar",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_target",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "AllowanceDecimalsExceedMax",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "AlreadyDisabledModule",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "AlreadyEnabledModule",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "CalldataOutOfBounds",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "enum Status",
              "name": "status",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "violatedNodeIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "location",
              "type": "uint256"
            }
          ],
          "name": "ConditionViolation",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            }
          ],
          "name": "DelegateCallNotAllowed",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            }
          ],
          "name": "FunctionNotAllowed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "FunctionSignatureTooShort",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "HashAlreadyConsumed",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "InvalidModule",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidPageSize",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "LeafNodeCannotHaveChildren",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "MalformedMultiEntrypoint",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "MembershipExpired",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "MembershipNotYetValid",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ModuleTransactionFailed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NoMembership",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            }
          ],
          "name": "NotAuthorized",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotBFS",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "pluckIndex",
              "type": "uint8"
            }
          ],
          "name": "PluckNotVisitedBeforeRef",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "Reentrancy",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            }
          ],
          "name": "SendNotAllowed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SetupModulesAlreadyCalled",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "SliceChildNotStatic",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            }
          ],
          "name": "TargetAddressNotAllowed",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableChildCount",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableChildTypeTree",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableCompValue",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableParameterType",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableParent",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "UnsuitableRootNode",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsupportedOperator",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "WithinRatioNoRatioProvided",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "WithinRatioTargetNotStatic",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "indexed": false,
              "internalType": "bytes",
              "name": "conditions",
              "type": "bytes"
            },
            {
              "indexed": false,
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "AllowFunction",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes",
              "name": "conditions",
              "type": "bytes"
            },
            {
              "indexed": false,
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "AllowTarget",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousAvatar",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newAvatar",
              "type": "address"
            }
          ],
          "name": "AvatarSet",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "allowanceKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "consumed",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "newBalance",
              "type": "uint128"
            }
          ],
          "name": "ConsumeAllowance",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "DisabledModule",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "EnabledModule",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "ExecutionFromModuleFailure",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "ExecutionFromModuleSuccess",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "start",
              "type": "uint64"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "end",
              "type": "uint64"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "usesLeft",
              "type": "uint128"
            }
          ],
          "name": "GrantRole",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "HashExecuted",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "HashInvalidated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            }
          ],
          "name": "Initialized",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousOwner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "OwnershipTransferred",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            }
          ],
          "name": "RevokeFunction",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "RevokeRole",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "RevokeTarget",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "initiator",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "avatar",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "string",
              "name": "version",
              "type": "string"
            }
          ],
          "name": "RolesModSetup",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "ScopeTarget",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "allowanceKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "name": "SetAllowance",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "defaultRoleKey",
              "type": "bytes32"
            }
          ],
          "name": "SetDefaultRole",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "adapter",
              "type": "address"
            }
          ],
          "name": "SetUnwrapAdapter",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousTarget",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newTarget",
              "type": "address"
            }
          ],
          "name": "TargetSet",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "start",
              "type": "uint64"
            },
            {
              "indexed": false,
              "internalType": "uint64",
              "name": "end",
              "type": "uint64"
            },
            {
              "indexed": false,
              "internalType": "uint128",
              "name": "usesLeft",
              "type": "uint128"
            }
          ],
          "name": "UpdateRole",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "VERSION",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "allowanceKey",
              "type": "bytes32"
            }
          ],
          "name": "accruedAllowance",
          "outputs": [
            {
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "internalType": "bytes",
              "name": "packedConditions",
              "type": "bytes"
            },
            {
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "allowFunction",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "packedConditions",
              "type": "bytes"
            },
            {
              "internalType": "enum ExecutionOptions",
              "name": "options",
              "type": "uint8"
            }
          ],
          "name": "allowTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "allowances",
          "outputs": [
            {
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes32[]",
              "name": "roleKeys",
              "type": "bytes32[]"
            },
            {
              "internalType": "bool[]",
              "name": "memberOf",
              "type": "bool[]"
            }
          ],
          "name": "assignRoles",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "avatar",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "consumed",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "defaultRoles",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "prevModule",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "disableModule",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "name": "enableModule",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Operation",
              "name": "operation",
              "type": "uint8"
            }
          ],
          "name": "execTransactionFromModule",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Operation",
              "name": "operation",
              "type": "uint8"
            }
          ],
          "name": "execTransactionFromModuleReturnData",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Operation",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "bool",
              "name": "shouldRevert",
              "type": "bool"
            }
          ],
          "name": "execTransactionWithRole",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Operation",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "bool",
              "name": "shouldRevert",
              "type": "bool"
            }
          ],
          "name": "execTransactionWithRoleReturnData",
          "outputs": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "start",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "pageSize",
              "type": "uint256"
            }
          ],
          "name": "getModulesPaginated",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "array",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "next",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "startTimestamp",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "endTimestamp",
              "type": "uint64"
            },
            {
              "internalType": "uint128",
              "name": "usesLeft",
              "type": "uint128"
            }
          ],
          "name": "grantRole",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "hash",
              "type": "bytes32"
            }
          ],
          "name": "invalidate",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_module",
              "type": "address"
            }
          ],
          "name": "isModuleEnabled",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "salt",
              "type": "bytes32"
            }
          ],
          "name": "moduleTxHash",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "parent",
                  "type": "uint16"
                },
                {
                  "internalType": "enum Encoding",
                  "name": "paramType",
                  "type": "uint8"
                },
                {
                  "internalType": "enum Operator",
                  "name": "operator",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes",
                  "name": "compValue",
                  "type": "bytes"
                }
              ],
              "internalType": "struct ConditionFlat[]",
              "name": "conditions",
              "type": "tuple[]"
            }
          ],
          "name": "packConditions",
          "outputs": [
            {
              "internalType": "bytes",
              "name": "buffer",
              "type": "bytes"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "renounceOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            }
          ],
          "name": "renounceRole",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            }
          ],
          "name": "revokeFunction",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            }
          ],
          "name": "revokeRole",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "revokeTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "targetAddress",
              "type": "address"
            }
          ],
          "name": "scopeTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "key",
              "type": "bytes32"
            },
            {
              "internalType": "uint128",
              "name": "balance",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "timestamp",
              "type": "uint64"
            }
          ],
          "name": "setAllowance",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_avatar",
              "type": "address"
            }
          ],
          "name": "setAvatar",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "roleKey",
              "type": "bytes32"
            }
          ],
          "name": "setDefaultRole",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_target",
              "type": "address"
            }
          ],
          "name": "setTarget",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "selector",
              "type": "bytes4"
            },
            {
              "internalType": "address",
              "name": "adapter",
              "type": "address"
            }
          ],
          "name": "setTransactionUnwrapper",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "initParams",
              "type": "bytes"
            }
          ],
          "name": "setUp",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "target",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "transferOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "unwrappers",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "key",
              "type": "bytes32"
            },
            {
              "internalType": "uint128",
              "name": "maxRefill",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "refill",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            }
          ],
          "name": "updateAllowance",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis-guild/zodiac-core/contracts/core/Modifier.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ExecutionTracker} from \"../signature/ExecutionTracker.sol\";\nimport {IAvatar} from \"../interfaces/IAvatar.sol\";\nimport {Module} from \"./Module.sol\";\nimport {SignatureChecker} from \"../signature/SignatureChecker.sol\";\n\nimport \"./Operation.sol\";\n\n/// @title Modifier Interface - A contract that sits between a Module and an Avatar and enforce some additional logic.\nabstract contract Modifier is\n  Module,\n  ExecutionTracker,\n  SignatureChecker,\n  IAvatar\n{\n  address internal constant SENTINEL_MODULES = address(0x1);\n  /// Mapping of modules.\n  mapping(address => address) internal modules;\n\n  /// `sender` is not an authorized module.\n  /// @param sender The address of the sender.\n  error NotAuthorized(address sender);\n\n  /// `module` is invalid.\n  error InvalidModule(address module);\n\n  /// `pageSize` is invalid.\n  error InvalidPageSize();\n\n  /// `module` is already disabled.\n  error AlreadyDisabledModule(address module);\n\n  /// `module` is already enabled.\n  error AlreadyEnabledModule(address module);\n\n  /// @dev `setModules()` was already called.\n  error SetupModulesAlreadyCalled();\n\n  /*\n    --------------------------------------------------\n    You must override both of the following virtual functions,\n    execTransactionFromModule() and execTransactionFromModuleReturnData().\n    It is recommended that implementations of both functions make use the \n    onlyModule modifier.\n    */\n\n  /// @dev Passes a transaction to the modifier.\n  /// @notice Can only be called by enabled modules.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction.\n  function execTransactionFromModule(\n    address to,\n    uint256 value,\n    bytes calldata data,\n    Operation operation\n  ) public virtual returns (bool success);\n\n  /// @dev Passes a transaction to the modifier, expects return data.\n  /// @notice Can only be called by enabled modules.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction.\n  function execTransactionFromModuleReturnData(\n    address to,\n    uint256 value,\n    bytes calldata data,\n    Operation operation\n  ) public virtual returns (bool success, bytes memory returnData);\n\n  /*\n    --------------------------------------------------\n    */\n\n  modifier moduleOnly() {\n    if (modules[msg.sender] == address(0)) {\n      (bytes32 hash, address signer) = moduleTxSignedBy();\n\n      // is the signer a module?\n      if (modules[signer] == address(0)) {\n        revert NotAuthorized(msg.sender);\n      }\n\n      // is the provided signature fresh?\n      if (consumed[signer][hash]) {\n        revert HashAlreadyConsumed(hash);\n      }\n\n      consumed[signer][hash] = true;\n      emit HashExecuted(hash);\n    }\n\n    _;\n  }\n\n  function sentOrSignedByModule() internal view returns (address) {\n    if (modules[msg.sender] != address(0)) {\n      return msg.sender;\n    }\n\n    (, address signer) = moduleTxSignedBy();\n    if (modules[signer] != address(0)) {\n      return signer;\n    }\n\n    return address(0);\n  }\n\n  /// @dev Disables a module on the modifier.\n  /// @notice This can only be called by the owner.\n  /// @param prevModule Module that pointed to the module to be removed in the linked list.\n  /// @param module Module to be removed.\n  function disableModule(\n    address prevModule,\n    address module\n  ) public override onlyOwner {\n    if (module == address(0) || module == SENTINEL_MODULES)\n      revert InvalidModule(module);\n    if (modules[prevModule] != module) revert AlreadyDisabledModule(module);\n    modules[prevModule] = modules[module];\n    modules[module] = address(0);\n    emit DisabledModule(module);\n  }\n\n  /// @dev Enables a module that can add transactions to the queue\n  /// @param module Address of the module to be enabled\n  /// @notice This can only be called by the owner\n  function enableModule(address module) public override onlyOwner {\n    if (module == address(0) || module == SENTINEL_MODULES)\n      revert InvalidModule(module);\n    if (modules[module] != address(0)) revert AlreadyEnabledModule(module);\n    modules[module] = modules[SENTINEL_MODULES];\n    modules[SENTINEL_MODULES] = module;\n    emit EnabledModule(module);\n  }\n\n  /// @dev Returns if an module is enabled\n  /// @return True if the module is enabled\n  function isModuleEnabled(\n    address _module\n  ) public view override returns (bool) {\n    return SENTINEL_MODULES != _module && modules[_module] != address(0);\n  }\n\n  /// @dev Returns array of modules.\n  ///      If all entries fit into a single page, the next pointer will be 0x1.\n  ///      If another page is present, next will be the last element of the returned array.\n  /// @param start Start of the page. Has to be a module or start pointer (0x1 address)\n  /// @param pageSize Maximum number of modules that should be returned. Has to be > 0\n  /// @return array Array of modules.\n  /// @return next Start of the next page.\n  function getModulesPaginated(\n    address start,\n    uint256 pageSize\n  ) external view override returns (address[] memory array, address next) {\n    if (start != SENTINEL_MODULES && !isModuleEnabled(start)) {\n      revert InvalidModule(start);\n    }\n    if (pageSize == 0) {\n      revert InvalidPageSize();\n    }\n\n    // Init array with max page size\n    array = new address[](pageSize);\n\n    // Populate return array\n    uint256 moduleCount = 0;\n    next = modules[start];\n    while (\n      next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize\n    ) {\n      array[moduleCount] = next;\n      next = modules[next];\n      moduleCount++;\n    }\n\n    // Because of the argument validation we can assume that\n    // the `currentModule` will always be either a module address\n    // or sentinel address (aka the end). If we haven't reached the end\n    // inside the loop, we need to set the next pointer to the last element\n    // because it skipped over to the next module which is neither included\n    // in the current page nor won't be included in the next one\n    // if you pass it as a start.\n    if (next != SENTINEL_MODULES) {\n      next = array[moduleCount - 1];\n    }\n    // Set correct size of returned array\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      mstore(array, moduleCount)\n    }\n  }\n\n  /// @dev Initializes the modules linked list.\n  /// @notice Should be called as part of the `setUp` / initializing function and can only be called once.\n  function setupModules() internal {\n    if (modules[SENTINEL_MODULES] != address(0))\n      revert SetupModulesAlreadyCalled();\n    modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n  }\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/core/Module.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {FactoryFriendly} from \"../factory/FactoryFriendly.sol\";\nimport {IAvatar} from \"../interfaces/IAvatar.sol\";\nimport \"./Operation.sol\";\n\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\nabstract contract Module is FactoryFriendly {\n  /// @dev Address that will ultimately execute function calls.\n  address public avatar;\n  /// @dev Address that this module will pass transactions to.\n  address public target;\n\n  /// @dev Emitted each time the avatar is set.\n  event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\n  /// @dev Emitted each time the Target is set.\n  event TargetSet(address indexed previousTarget, address indexed newTarget);\n\n  /// @dev Sets the avatar to a new avatar (`newAvatar`).\n  /// @notice Can only be called by the current owner.\n  function setAvatar(address _avatar) public onlyOwner {\n    address previousAvatar = avatar;\n    avatar = _avatar;\n    emit AvatarSet(previousAvatar, _avatar);\n  }\n\n  /// @dev Sets the target to a new target (`newTarget`).\n  /// @notice Can only be called by the current owner.\n  function setTarget(address _target) public onlyOwner {\n    address previousTarget = target;\n    target = _target;\n    emit TargetSet(previousTarget, _target);\n  }\n\n  /// @dev Passes a transaction to be executed by the avatar.\n  /// @notice Can only be called by this contract.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function exec(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  ) internal virtual returns (bool success) {\n    return\n      IAvatar(target).execTransactionFromModule(to, value, data, operation);\n  }\n\n  /// @dev Passes a transaction to be executed by the target and returns data.\n  /// @notice Can only be called by this contract.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execAndReturnData(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  ) internal virtual returns (bool success, bytes memory returnData) {\n    return\n      IAvatar(target).execTransactionFromModuleReturnData(\n        to,\n        value,\n        data,\n        operation\n      );\n  }\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/core/Operation.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nenum Operation {\n  Call,\n  DelegateCall\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/factory/FactoryFriendly.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\npragma solidity >=0.7.0 <0.9.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract FactoryFriendly is OwnableUpgradeable {\n  function setUp(bytes memory initializeParams) public virtual;\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/interfaces/IAvatar.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../core/Operation.sol\";\n\ninterface IAvatar {\n  event EnabledModule(address module);\n  event DisabledModule(address module);\n  event ExecutionFromModuleSuccess(address indexed module);\n  event ExecutionFromModuleFailure(address indexed module);\n\n  /// @dev Enables a module on the avatar.\n  /// @notice Can only be called by the avatar.\n  /// @notice Modules should be stored as a linked list.\n  /// @notice Must emit EnabledModule(address module) if successful.\n  /// @param module Module to be enabled.\n  function enableModule(address module) external;\n\n  /// @dev Disables a module on the avatar.\n  /// @notice Can only be called by the avatar.\n  /// @notice Must emit DisabledModule(address module) if successful.\n  /// @param prevModule Address that pointed to the module to be removed in the linked list\n  /// @param module Module to be removed.\n  function disableModule(address prevModule, address module) external;\n\n  /// @dev Allows a Module to execute a transaction.\n  /// @notice Can only be called by an enabled module.\n  /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n  /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execTransactionFromModule(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  ) external returns (bool success);\n\n  /// @dev Allows a Module to execute a transaction and return data\n  /// @notice Can only be called by an enabled module.\n  /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n  /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n  /// @param to Destination address of module transaction.\n  /// @param value Ether value of module transaction.\n  /// @param data Data payload of module transaction.\n  /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n  function execTransactionFromModuleReturnData(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  ) external returns (bool success, bytes memory returnData);\n\n  /// @dev Returns if an module is enabled\n  /// @return True if the module is enabled\n  function isModuleEnabled(address module) external view returns (bool);\n\n  /// @dev Returns array of modules.\n  /// @param start Start of the page.\n  /// @param pageSize Maximum number of modules that should be returned.\n  /// @return array Array of modules.\n  /// @return next Start of the next page.\n  function getModulesPaginated(\n    address start,\n    uint256 pageSize\n  ) external view returns (address[] memory array, address next);\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/signature/ExecutionTracker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n/// @title ExecutionTracker - A contract that keeps track of executed and invalidated hashes\ncontract ExecutionTracker {\n  error HashAlreadyConsumed(bytes32);\n\n  event HashExecuted(bytes32);\n  event HashInvalidated(bytes32);\n\n  mapping(address => mapping(bytes32 => bool)) public consumed;\n\n  function invalidate(bytes32 hash) external {\n    consumed[msg.sender][hash] = true;\n    emit HashInvalidated(hash);\n  }\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/signature/IERC1271.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC1271 {\n  /**\n   * @notice EIP1271 method to validate a signature.\n   * @param hash Hash of the data signed on the behalf of address(this).\n   * @param signature Signature byte array associated with _data.\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */\n  function isValidSignature(\n    bytes32 hash,\n    bytes memory signature\n  ) external view returns (bytes4);\n}\n"
          },
          "@gnosis-guild/zodiac-core/contracts/signature/SignatureChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IERC1271} from \"./IERC1271.sol\";\n\n/// @title SignatureChecker - A contract that retrieves and validates signatures appended to transaction calldata.\n/// @dev currently supports eip-712 and eip-1271 signatures\nabstract contract SignatureChecker {\n  /**\n   * @notice Searches for a signature, validates it, and returns the signer's address.\n   * @dev When signature not found or invalid, zero address is returned\n   * @return The address of the signer.\n   */\n  function moduleTxSignedBy() internal view returns (bytes32, address) {\n    bytes calldata data = msg.data;\n\n    /*\n     * The idea is to extend `onlyModule` and provide signature checking\n     * without code changes to inheriting contracts (Modifiers).\n     *\n     * Since it's a generic mechanism, there is no way to conclusively\n     * identify the trailing bytes as a signature. We simply slice those\n     * and recover signer.\n     *\n     * As a result, we impose a minimum calldata length equal to a function\n     * selector plus salt, plus a signature (i.e., 4 + 32 + 65 bytes), any\n     * shorter and calldata it guaranteed to not contain a signature.\n     */\n    if (data.length < 4 + 32 + 65) {\n      return (bytes32(0), address(0));\n    }\n\n    (uint8 v, bytes32 r, bytes32 s) = _splitSignature(data);\n\n    uint256 end = data.length - (32 + 65);\n    bytes32 salt = bytes32(data[end:]);\n\n    /*\n     * When handling contract signatures:\n     *  v - is zero\n     *  r - contains the signer\n     *  s - contains the offset within calldata where the signer specific\n     *      signature is located\n     *\n     * We detect contract signatures by checking:\n     *  1- `v` is zero\n     *  2- `s` points within the buffer, is after selector, is before\n     *      salt and delimits a non-zero length buffer\n     */\n    if (v == 0) {\n      uint256 start = uint256(s);\n      if (start < 4 || start > end) {\n        return (bytes32(0), address(0));\n      }\n      address signer = address(uint160(uint256(r)));\n\n      bytes32 hash = moduleTxHash(data[:start], salt);\n      return\n        _isValidContractSignature(signer, hash, data[start:end])\n          ? (hash, signer)\n          : (bytes32(0), address(0));\n    } else {\n      bytes32 hash = moduleTxHash(data[:end], salt);\n      return (hash, ecrecover(hash, v, r, s));\n    }\n  }\n\n  /**\n   * @notice Hashes the transaction EIP-712 data structure.\n   * @dev The produced hash is intended to be signed.\n   * @param data The current transaction's calldata.\n   * @param salt The salt value.\n   * @return The 32-byte hash that is to be signed.\n   */\n  function moduleTxHash(\n    bytes calldata data,\n    bytes32 salt\n  ) public view returns (bytes32) {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this)\n    );\n    bytes memory moduleTxData = abi.encodePacked(\n      bytes1(0x19),\n      bytes1(0x01),\n      domainSeparator,\n      keccak256(abi.encode(MODULE_TX_TYPEHASH, keccak256(data), salt))\n    );\n    return keccak256(moduleTxData);\n  }\n\n  /**\n   * @dev Extracts signature from calldata, and divides it into `uint8 v, bytes32 r, bytes32 s`.\n   * @param data The current transaction's calldata.\n   * @return v The ECDSA v value\n   * @return r The ECDSA r value\n   * @return s The ECDSA s value\n   */\n  function _splitSignature(\n    bytes calldata data\n  ) private pure returns (uint8 v, bytes32 r, bytes32 s) {\n    v = uint8(bytes1(data[data.length - 1:]));\n    r = bytes32(data[data.length - 65:]);\n    s = bytes32(data[data.length - 33:]);\n  }\n\n  /**\n   * @dev Calls the signer contract, and validates the contract signature.\n   * @param signer The address of the signer contract.\n   * @param hash Hash of the data signed\n   * @param signature The contract signature.\n   * @return result Indicates whether the signature is valid.\n   */\n  function _isValidContractSignature(\n    address signer,\n    bytes32 hash,\n    bytes calldata signature\n  ) internal view returns (bool result) {\n    uint256 size;\n    // eslint-disable-line no-inline-assembly\n    assembly {\n      size := extcodesize(signer)\n    }\n    if (size == 0) {\n      return false;\n    }\n\n    (, bytes memory returnData) = signer.staticcall(\n      abi.encodeWithSelector(\n        IERC1271.isValidSignature.selector,\n        hash,\n        signature\n      )\n    );\n\n    return bytes4(returnData) == EIP1271_MAGIC_VALUE;\n  }\n\n  // keccak256(\n  //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n  // );\n  bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n    0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n  // keccak256(\n  //     \"ModuleTx(bytes data,bytes32 salt)\"\n  // );\n  bytes32 private constant MODULE_TX_TYPEHASH =\n    0x2939aeeda3ca260200c9f7b436b19e13207547ccc65cfedc857751c5ea6d91d4;\n\n  // bytes4(keccak256(\n  //     \"isValidSignature(bytes32,bytes)\"\n  // ));\n  bytes4 private constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
          },
          "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
          },
          "contracts/common/AbiLocation.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Condition, Encoding} from \"../types/Condition.sol\";\nimport {Operator} from \"../types/Operator.sol\";\n\n/**\n * @title AbiLocation - Locates ABI-encoded parameters on-demand\n * @author gnosisguild\n */\nlibrary AbiLocation {\n    /**\n     * @dev Resolves absolute calldata locations for direct children of a\n     *      container. Supports Tuple, Array, and AbiEncoded types.\n     *\n     * @param data      The calldata buffer being inspected.\n     * @param location  The absolute start position of the container block.\n     *\n     */\n    function children(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition\n    ) internal pure returns (uint256[] memory none, bool overflow) {\n        uint256 childCount = condition.children.length;\n\n        bool isArray = condition.encoding == Encoding.Array;\n        if (isArray) {\n            if (location + 32 > data.length) return (none, true);\n            assembly {\n                childCount := calldataload(add(data.offset, location))\n            }\n            location += 32;\n        }\n\n        uint256[] memory result = new uint256[](childCount);\n\n        uint256 headOffset;\n        for (uint256 i; i < childCount; ++i) {\n            Condition memory child = condition.children[isArray ? 0 : i];\n\n            if (child.inlined) {\n                result[i] = location + headOffset;\n                headOffset += child.size;\n            } else {\n                result[i] = _tailLocation(data, location, headOffset);\n                headOffset += 32;\n            }\n\n            if (result[i] > data.length) {\n                return (none, true);\n            }\n        }\n        return (result, false);\n    }\n\n    /**\n     * @dev Computes the encoded size of a value at location.\n     */\n    function size(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition\n    ) internal pure returns (uint256 result) {\n        Encoding encoding = condition.encoding;\n\n        if (encoding == Encoding.Static) {\n            return 32;\n        }\n\n        /*\n         * Read first word, detect overflow\n         */\n        if (location + 32 > data.length) return data.length + 1;\n        uint256 word;\n        assembly {\n            word := calldataload(add(data.offset, location))\n        }\n\n        /*\n         * About AbiEncoded\n         *\n         * AbiEncoded location is patched during ConditionEvaluation\n         * so that top-level and nested AbiEncoded nodes are treated\n         * uniformly by the evaluator. As a consequence, this function\n         * only supports nested AbiEncoded nodes – calling it on a\n         * root one would fail. This is fine because the entry point\n         * for size is always via EqualTo, and AbiEncoded cannot be\n         * paired with that operator.\n         */\n        if (encoding == Encoding.Dynamic || encoding == Encoding.AbiEncoded) {\n            // Dynamic types: length prefix + padded content (ceil32)\n            return 32 + ((word + 31) & ~uint256(31));\n        }\n\n        uint256 childCount = condition.children.length;\n        if (encoding == Encoding.None) {\n            // Transparent And/Or: delegate size to first child\n            for (uint256 i; i < childCount; ++i) {\n                result = size(data, location, condition.children[i]);\n                // children can overflow or be non structural\n                if (result > 0 && result <= data.length) return result;\n            }\n            // if we reached here, just mark overflow\n            return data.length + 1;\n        }\n\n        /*\n         * Tuple / Array\n         */\n        bool isArray = encoding == Encoding.Array;\n        if (isArray) {\n            childCount = word;\n            location += 32;\n            result = 32;\n        }\n\n        uint256 headOffset;\n        for (uint256 i; i < childCount; ++i) {\n            Condition memory child = condition.children[isArray ? 0 : i];\n            /*\n             * HEAD + TAIL block encoding\n             *\n             * Process the HEAD region. ABI encoding stores static elements\n             * inline and dynamic elements as 32-byte offsets to the TAIL\n             * region. We sum the HEAD footprint (element size or offset) and\n             * recursive TAIL sizes.\n             */\n            if (child.inlined) {\n                result += child.size;\n                headOffset += child.size;\n            } else {\n                result +=\n                    32 +\n                    size(\n                        data,\n                        _tailLocation(data, location, headOffset),\n                        child\n                    );\n                headOffset += 32;\n            }\n        }\n    }\n\n    /**\n     * @dev Computes the absolute position of a dynamic (non-inline) element.\n     *      Reads the relative offset from HEAD and adds it to the block start\n     *      to locate the element in the TAIL region.\n     *\n     * @param data       The calldata being inspected.\n     * @param location   Absolute start position of the current ABI block.\n     * @param headOffset Byte offset within HEAD where the pointer resides.\n     * @return           Absolute position, or type(uint256).max on overflow.\n     */\n    function _tailLocation(\n        bytes calldata data,\n        uint256 location,\n        uint256 headOffset\n    ) private pure returns (uint256) {\n        // HEAD overflows buffer\n        if (location + headOffset + 32 > data.length) {\n            return data.length + 1;\n        }\n\n        uint256 tailOffset;\n        assembly {\n            tailOffset := calldataload(\n                add(data.offset, add(location, headOffset))\n            )\n        }\n\n        // TAIL points backwards\n        if (tailOffset <= headOffset) {\n            return data.length + 1;\n        }\n\n        // TAIL overflows buffer\n        if (location + tailOffset + 32 > data.length) {\n            return data.length + 1;\n        }\n\n        return location + tailOffset;\n    }\n}\n"
          },
          "contracts/common/AllowanceLoader.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Allowance} from \"../types/Allowance.sol\";\n\n/**\n * @title AllowanceLoader\n * @notice Loads allowances from storage and calculates accrued balances\n *\n * @author gnosisguild\n */\nlibrary AllowanceLoader {\n    function accrue(\n        bytes32 allowanceKey,\n        uint64 blockTimestamp\n    ) internal view returns (uint128 balance, uint64 timestamp) {\n        Allowance memory a = _load(allowanceKey);\n\n        // No refill configured.\n        if (a.period == 0) return (a.balance, a.timestamp);\n\n        uint64 nextAccrualAt = a.timestamp + a.period;\n        // Not enough time elapsed to complete a period.\n        if (blockTimestamp < nextAccrualAt) return (a.balance, a.timestamp);\n\n        // Calculate full periods elapsed\n        uint64 elapsedIntervals = (blockTimestamp - a.timestamp) / a.period;\n        // Timestamp always advances, even when balance is at cap\n        timestamp = a.timestamp + elapsedIntervals * a.period;\n\n        // Already at cap, or initial balance was set above maxRefill\n        if (a.balance >= a.maxRefill) return (a.balance, timestamp);\n\n        // Add refill for each elapsed period, capping at maxRefill.\n        uint128 accruedBalance = a.balance + (a.refill * elapsedIntervals);\n        balance = accruedBalance < a.maxRefill ? accruedBalance : a.maxRefill;\n    }\n\n    /**\n     *\n     * Storage Layout (2 words, 64 bytes, 512 bits):\n     * ┌────────────────────────────────┬────────────────────────────────┐\n     * │           maxRefill            │             refill             │\n     * │            128 bits            │            128 bits            │\n     * ├────────────────┬───────────────┴───────────────┬────────────────┤\n     * │   timestamp    │            balance            │     period     │\n     * │    64 bits     │           128 bits            │    64 bits     │\n     * └────────────────┴───────────────────────────────┴────────────────┘\n     *\n     */\n    uint256 constant ALLOWANCES_SLOT = 106;\n    function _load(\n        bytes32 allowanceKey\n    ) private view returns (Allowance memory) {\n        uint256 word1;\n        uint256 word2;\n        assembly {\n            mstore(0x00, allowanceKey)\n            mstore(0x20, ALLOWANCES_SLOT)\n            let slot := keccak256(0x00, 0x40)\n            word1 := sload(slot)\n            word2 := sload(add(slot, 1))\n        }\n\n        return\n            Allowance({\n                refill: uint128(word1),\n                maxRefill: uint128(word1 >> 128),\n                period: uint64(word2),\n                balance: uint128(word2 >> 64),\n                timestamp: uint64(word2 >> 192)\n            });\n    }\n}\n"
          },
          "contracts/common/ConsumptionList.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Consumption} from \"../types/Allowance.sol\";\n\n/**\n * @title ConsumptionList\n * @notice Provides copy-on-write array operations for Consumption entries.\n *\n * @author gnosisguild\n */\nlibrary ConsumptionList {\n    /**\n     * @notice Creates a new array with entry written at index.\n     * @dev If index equals array length, the array grows by one.\n     * @param list Source array (shallow copied)\n     * @param entry The consumption entry to write\n     * @param index Position to write entry\n     * @return result New array with entry at index\n     */\n    function copyOnWrite(\n        Consumption[] memory list,\n        Consumption memory entry,\n        uint256 index\n    ) internal pure returns (Consumption[] memory result) {\n        uint256 prevLength = list.length;\n        uint256 length = prevLength + (index == prevLength ? 1 : 0);\n\n        assembly {\n            // Allocate new array\n            result := mload(0x40)\n            mstore(0x40, add(result, mul(add(length, 1), 0x20)))\n            mstore(result, length)\n\n            // Shallow copy previous elements\n            let dst := add(result, 0x20)\n            let src := add(list, 0x20)\n            let size := mul(prevLength, 0x20)\n            mcopy(dst, src, size)\n        }\n\n        result[index] = entry;\n    }\n}\n"
          },
          "contracts/common/ImmutableStorage.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\ninterface ISingletonFactory {\n    function deploy(\n        bytes memory initCode,\n        bytes32 salt\n    ) external returns (address);\n}\n\nlibrary ImmutableStorage {\n    address public constant SINGLETON_FACTORY =\n        0xce0042B868300000d44A59004Da54A005ffdcf9f;\n\n    function store(bytes memory buffer) internal returns (address pointer) {\n        bytes memory bytecode = _creationBytecode(buffer);\n        pointer = _calculateAddress(bytecode);\n\n        uint256 size;\n        assembly {\n            size := extcodesize(pointer)\n        }\n\n        if (size == 0) {\n            assert(\n                pointer ==\n                    ISingletonFactory(SINGLETON_FACTORY).deploy(\n                        bytecode,\n                        bytes32(0)\n                    )\n            );\n        }\n    }\n\n    /**\n     * @notice Reads the runtime bytecode stored at a `pointer` contract, skipping the first byte.\n     *\n     * @param pointer The address of the deployed pointer contract.\n     * @return buffer The raw bytecode (minus the prepended 0x00) read from `pointer`.\n     */\n    function load(address pointer) internal view returns (bytes memory buffer) {\n        assembly {\n            let size := sub(extcodesize(pointer), 1)\n            // free memory point ought to be multiple of 32\n            let rounded := and(add(size, 31), not(31))\n\n            // Get free pointer\n            buffer := mload(0x40)\n            // Store length\n            mstore(buffer, size)\n            // Update free pointer\n            mstore(0x40, add(add(buffer, 0x20), rounded))\n\n            // Copy code starting from offset 0x01 (skip the 0x00 prefix)\n            extcodecopy(pointer, add(buffer, 0x20), 0x01, size)\n        }\n    }\n\n    /**\n     * @notice Generates creation bytecode that deploys a contract containing `data` as its runtime bytecode.\n     * @dev The generated constructor copies `data` into memory and returns it as the contract's code.\n     *      A leading `0x00` byte is prepended so the resulting contract cannot be called.\n     *\n     * Assembly layout (constructor):\n     *\n     * ```\n     * 0x00    63 <XXXXXX>   PUSH4 code_size         ; push code length (runtime size)\n     * 0x01    80             DUP1                   ; duplicate size\n     * 0x02    60 0e          PUSH1 0x0e             ; offset of actual code\n     * 0x03    60 00          PUSH1 0x00             ; destination offset\n     * 0x04    39             CODECOPY               ; copy <code_size> bytes from offset 0x0e\n     * 0x05    60 00          PUSH1 0x00             ; return offset\n     * 0x06    f3             RETURN                 ; return code as runtime bytecode\n     * <CODE>                                        ; runtime code (0x00 + data)\n     * ```\n     *\n     */\n    function _creationBytecode(\n        bytes memory data\n    ) private pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(data.length + 1),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                // Prepend 0x00 to prevent the deployed contract from being callable\n                hex\"00\",\n                data\n            );\n    }\n\n    function _calculateAddress(\n        bytes memory creationBytecode\n    ) private pure returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                SINGLETON_FACTORY,\n                bytes32(0),\n                keccak256(creationBytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}\n"
          },
          "contracts/common/PriceConversion.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../periphery/interfaces/IPricing.sol\";\nimport \"../types/Types.sol\";\n\n/**\n * @title PriceConversion\n * @notice Library for applying exchange rate conversion via IPricing adapters.\n *\n * @dev Converts amounts using an external pricing adapter. The adapter returns\n *      a price with 18 decimals precision. Decimal scaling should be handled\n *      by the caller.\n *\n * @author gnosisguild\n */\nlibrary PriceConversion {\n    uint256 private constant PRICE_DECIMALS = 18;\n    uint256 private constant ONE = 10 ** PRICE_DECIMALS;\n\n    /**\n     * @notice Applies exchange rate conversion to an amount.\n     * @param amount The amount to convert\n     * @param adapter Price adapter address\n     * @return status Ok or error status from adapter\n     * @return result Amount multiplied by price and divided by 10^18\n     */\n    function convert(\n        uint256 amount,\n        address adapter\n    ) internal view returns (Status, uint256) {\n        (Status status, uint256 price) = _getPrice(adapter);\n        if (status != Status.Ok) {\n            return (status, 0);\n        }\n\n        return (Status.Ok, (amount * price) / ONE);\n    }\n\n    /**\n     * @dev Safely invokes pricing adapter via staticcall.\n     *\n     *  Price Adapter (IPricing.getPrice) Error Scenarios:\n     *  | Scenario              | staticcall Result     | Behavior                      | Status                          |\n     *  |-----------------------|-----------------------|-------------------------------|---------------------------------|\n     *  | No code at address    | (true, \"\")            | extcodesize == 0              | PricingAdapterNotAContract      |\n     *  | Wrong interface       | (false, \"\")           | staticcall fails              | PricingAdapterReverted          |\n     *  | Function reverts      | (false, <error data>) | staticcall fails              | PricingAdapterReverted          |\n     *  | Returns wrong type    | (true, <len != 32>)   | returnData.length != 32       | PricingAdapterInvalidResult     |\n     *  | Returns zero price    | (true, <32 bytes>)    | price == 0                    | PricingAdapterZeroPrice         |\n     *\n     */\n\n    function _getPrice(address adapter) private view returns (Status, uint256) {\n        if (adapter == address(0)) {\n            return (Status.Ok, ONE);\n        }\n\n        uint256 size;\n        assembly {\n            size := extcodesize(adapter)\n        }\n        if (size == 0) {\n            return (Status.PricingAdapterNotAContract, 0);\n        }\n\n        (bool success, bytes memory returnData) = adapter.staticcall(\n            abi.encodeCall(IPricing.getPrice, ())\n        );\n\n        if (!success) {\n            return (Status.PricingAdapterReverted, 0);\n        }\n\n        if (returnData.length != 32) {\n            return (Status.PricingAdapterInvalidResult, 0);\n        }\n\n        uint256 price = uint256(bytes32(returnData));\n        if (price == 0) {\n            return (Status.PricingAdapterZeroPrice, 0);\n        }\n\n        return (Status.Ok, price);\n    }\n}\n"
          },
          "contracts/core/Authorization.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./evaluate/ConditionEvaluator.sol\";\nimport \"./serialize/ConditionLoader.sol\";\nimport \"./Storage.sol\";\n\nimport \"../periphery/interfaces/ITransactionUnwrapper.sol\";\n\n/**\n * @title Authorization\n * @notice Authorizes transactions by evaluating role permissions:\n *         1. Target Clearance - is the target address allowed?\n *         2. ExecutionOptions - can it send value or delegatecall?\n *         3. Condition tree - do parameters satisfy the constraints?\n *\n * @dev Handles unwrapping of transaction bundles if an adapter is registered.\n *\n * @author gnosisguild\n */\nabstract contract Authorization is RolesStorage {\n    function _authorize(\n        bytes32 roleKey,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) internal view returns (Consumption[] memory consumptions) {\n        address adapter = unwrappers[_key(to, bytes4(data))];\n        if (adapter == address(0)) {\n            return\n                _transaction(\n                    roleKey,\n                    data,\n                    consumptions,\n                    Transaction(to, value, operation)\n                );\n        }\n\n        /*\n         * Transaction Bundle\n         */\n        try\n            ITransactionUnwrapper(adapter).unwrap(to, value, data, operation)\n        returns (UnwrappedTransaction[] memory unwrapped) {\n            for (uint256 i; i < unwrapped.length; ++i) {\n                UnwrappedTransaction memory entry = unwrapped[i];\n                consumptions = _transaction(\n                    roleKey,\n                    data[entry.dataLocation:entry.dataLocation +\n                        entry.dataSize],\n                    consumptions,\n                    Transaction(entry.to, entry.value, entry.operation)\n                );\n            }\n        } catch {\n            revert MalformedMultiEntrypoint();\n        }\n    }\n\n    /// @dev Inspects a transaction and authorizes based on role permissions.\n    function _transaction(\n        bytes32 roleKey,\n        bytes calldata data,\n        Consumption[] memory consumptions,\n        Transaction memory transaction\n    ) private view returns (Consumption[] memory) {\n        if (data.length != 0 && data.length < 4) {\n            revert FunctionSignatureTooShort();\n        }\n\n        Role storage role = roles[roleKey];\n        /*\n         * Check Clearance\n         */\n        Clearance clearance = role.clearance[transaction.to];\n        if (clearance == Clearance.None) {\n            revert TargetAddressNotAllowed(transaction.to);\n        }\n\n        /*\n         * Check that some Condition is defined\n         */\n        uint256 scopeConfig;\n        {\n            bytes32 key = bytes32(bytes20(transaction.to)) |\n                (\n                    clearance == Clearance.Target\n                        ? (~bytes32(0) >> 160)\n                        : (bytes32(bytes4(data)) >> 160)\n                );\n\n            scopeConfig = role.scopeConfig[key];\n            if (scopeConfig == 0) {\n                revert FunctionNotAllowed(transaction.to, bytes4(data));\n            }\n        }\n\n        /*\n         * Check ExecutionOptions\n         */\n        {\n            uint256 options = scopeConfig >> 160;\n            if (options & 1 == 0 && transaction.value > 0) {\n                revert SendNotAllowed(transaction.to);\n            }\n            if (\n                options & 2 == 0 &&\n                transaction.operation == Operation.DelegateCall\n            ) {\n                revert DelegateCallNotAllowed(transaction.to);\n            }\n        }\n\n        /*\n         * Load and Evaluate Condition\n         */\n        (Condition memory condition, uint256 maxPluckCount) = ConditionLoader\n            .load(scopeConfig);\n\n        Result memory result = ConditionEvaluator.evaluate(\n            data,\n            0,\n            condition,\n            consumptions,\n            Context(\n                transaction.to,\n                transaction.value,\n                transaction.operation,\n                new bytes32[](maxPluckCount),\n                new uint256[](maxPluckCount)\n            )\n        );\n\n        if (result.status != Status.Ok) {\n            revert ConditionViolation(\n                result.status,\n                result.violatedNodeIndex,\n                result.payloadLocation\n            );\n        }\n\n        return result.consumptions;\n    }\n}\n"
          },
          "contracts/core/evaluate/BitmaskChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Status} from \"../../types/Types.sol\";\n\n/**\n * @title BitmaskChecker\n * @notice Validates that a value matches an expected pattern after applying a bitmask.\n *\n * @dev compValue packs shift, mask and expected.\n *\n * @author gnosisguild\n *\n */\nlibrary BitmaskChecker {\n    function check(\n        bytes calldata data,\n        uint256 location,\n        bytes memory compValue,\n        bool inlined\n    ) internal pure returns (Status) {\n        uint256 shift = uint16(bytes2(compValue));\n        uint256 length = (compValue.length - 2) / 2;\n\n        uint256 start = location + (inlined ? 0 : 32);\n        uint256 end = data.length;\n\n        if (shift + length > end - start) {\n            return Status.BitmaskOverflow;\n        }\n\n        bytes calldata value = data[start:];\n\n        /*\n         * Load actual, expected, and mask in 32-byte chunks. Final chunk\n         * gets rinsed if less than 32 bytes remain.\n         */\n        for (uint256 i; i < length; i += 32) {\n            /*\n             * compValue memory layout:\n             * | 32: length | 2: shift | N: mask | N: expected |\n             *                         ^--- 0x22 offset\n             */\n            bytes32 mask;\n            assembly {\n                mask := mload(add(add(compValue, 0x22), i))\n            }\n\n            bytes32 expected;\n            assembly {\n                expected := mload(add(add(compValue, 0x22), add(length, i)))\n            }\n\n            bytes32 actual;\n            assembly {\n                actual := calldataload(add(value.offset, add(shift, i)))\n            }\n\n            bytes32 rinseMask = _rinseMask(length - i);\n\n            if (expected & rinseMask != actual & mask & rinseMask) {\n                return Status.BitmaskNotAllowed;\n            }\n        }\n\n        return Status.Ok;\n    }\n\n    /// @dev Returns a mask with leading 1s for byteCount bytes, rest 0s.\n    function _rinseMask(uint256 bytesLeft) private pure returns (bytes32) {\n        uint256 bitsToRinse = (bytesLeft > 31 ? 0 : 32 - bytesLeft) * 8;\n        return bytes32(type(uint256).max << bitsToRinse);\n    }\n}\n"
          },
          "contracts/core/evaluate/ConditionEvaluator.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./BitmaskChecker.sol\";\nimport \"./CustomConditionChecker.sol\";\nimport \"./WithinAllowanceChecker.sol\";\nimport \"./WithinRatioChecker.sol\";\n\nimport \"../../common/AbiLocation.sol\";\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title ConditionEvaluator\n * @notice Evaluates condition trees on scoped function calls.\n * @author gnosisguild\n */\nlibrary ConditionEvaluator {\n    function evaluate(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) internal view returns (Result memory) {\n        Operator operator = condition.operator;\n\n        if (operator < Operator.EqualTo) {\n            if (operator == Operator.Pass) {\n                return _ok(consumptions);\n            } else if (operator == Operator.Matches) {\n                location = location > 0 &&\n                    condition.encoding == Encoding.AbiEncoded\n                    ? location + 32\n                    : location;\n                return\n                    _matches(data, location, condition, consumptions, context);\n            } else if (operator == Operator.And) {\n                return _and(data, location, condition, consumptions, context);\n            } else if (operator == Operator.Or) {\n                return _or(data, location, condition, consumptions, context);\n            } else if (operator == Operator.Slice) {\n                return _slice(data, location, condition, consumptions, context);\n            } else if (operator == Operator.Pluck) {\n                return _pluck(data, location, condition, consumptions, context);\n            } else if (operator == Operator.Empty) {\n                return\n                    _result(\n                        data.length == 0 ? Status.Ok : Status.CalldataNotEmpty,\n                        0,\n                        condition,\n                        consumptions\n                    );\n            } else if (\n                operator == Operator.ArraySome ||\n                operator == Operator.ArrayEvery\n            ) {\n                return\n                    _arrayIterator(\n                        data,\n                        location,\n                        condition,\n                        consumptions,\n                        context\n                    );\n            } else if (operator == Operator.ArrayTailMatches) {\n                return\n                    _arrayTailMatches(\n                        data,\n                        location,\n                        condition,\n                        consumptions,\n                        context\n                    );\n            } else {\n                // ZipSome or ZipEvery\n                return\n                    _zipIterator(\n                        data,\n                        location,\n                        condition,\n                        consumptions,\n                        context\n                    );\n            }\n        } else {\n            if (operator <= Operator.SignedIntLessThan) {\n                (bytes32 value, bool overflow) = __input(\n                    data,\n                    location,\n                    condition,\n                    context\n                );\n\n                return\n                    _result(\n                        overflow\n                            ? Status.CalldataOverflow\n                            : operator <= Operator.LessThan\n                                ? __compare(value, condition)\n                                : __compareSigned(value, condition),\n                        location,\n                        condition,\n                        consumptions\n                    );\n            } else if (operator == Operator.Bitmask) {\n                return\n                    _result(\n                        BitmaskChecker.check(\n                            data,\n                            location,\n                            condition.compValue,\n                            condition.inlined\n                        ),\n                        location,\n                        condition,\n                        consumptions\n                    );\n            } else if (operator == Operator.WithinAllowance) {\n                (bytes32 value, bool overflow) = __input(\n                    data,\n                    location,\n                    condition,\n                    context\n                );\n                if (overflow) {\n                    return\n                        _violation(\n                            Status.CalldataOverflow,\n                            location,\n                            condition\n                        );\n                }\n                return\n                    __allowance(\n                        uint256(value),\n                        location,\n                        condition,\n                        consumptions\n                    );\n            } else if (operator == Operator.CallWithinAllowance) {\n                return __allowance(1, location, condition, consumptions);\n            } else if (operator == Operator.WithinRatio) {\n                return\n                    _result(\n                        WithinRatioChecker.check(\n                            condition.compValue,\n                            context.pluckedValues\n                        ),\n                        location,\n                        condition,\n                        consumptions\n                    );\n            } else {\n                // Custom\n                return\n                    _result(\n                        CustomConditionChecker.check(\n                            condition.compValue,\n                            context.to,\n                            context.value,\n                            data,\n                            context.operation,\n                            location,\n                            condition,\n                            context.pluckedValues\n                        ),\n                        location,\n                        condition,\n                        consumptions\n                    );\n            }\n        }\n    }\n\n    function _matches(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        uint256 shift = 32 - condition.compValue.length;\n        if (shift < 32) {\n            /*\n             * Leading Bytes Validation\n             *\n             * For AbiEncoded + Matches, compValue might contain N bytes that must\n             * match the first N bytes of calldata at location.\n             *\n             * Integrity.sol validates N <= 32, so shift underflow is impossible.\n             *\n             * Comparison uses right-alignment in bytes32:\n             *   shift = 32 - N\n             *   expected: bytes32(compValue)  >> shift  (N bytes, right-aligned)\n             *   actual:   bytes32(data[loc:]) >> shift  (N bytes, right-aligned)\n             *\n             * If compValue is empty (shift == 32), validation is skipped.\n             */\n\n            // Check bounds before reading leading bytes\n            if (location + (32 - shift) > data.length) {\n                return _violation(Status.CalldataOverflow, location, condition);\n            }\n\n            bytes32 expected = bytes32(condition.compValue) >> shift;\n            bytes32 actual = bytes32(data[location:]) >> shift;\n\n            if (expected != actual) {\n                return\n                    _violation(\n                        Status.LeadingBytesNotAMatch,\n                        location,\n                        condition\n                    );\n            }\n        }\n\n        // Decode children locations - all children are structural\n        (uint256[] memory childLocations, bool overflow) = AbiLocation.children(\n            data,\n            location + condition.leadingBytes,\n            condition\n        );\n\n        if (overflow) {\n            return _violation(Status.CalldataOverflow, location, condition);\n        }\n\n        if (condition.children.length != childLocations.length) {\n            return _violation(Status.ParameterNotAMatch, location, condition);\n        }\n\n        result.consumptions = consumptions;\n        for (uint256 i; i < childLocations.length; ++i) {\n            result = evaluate(\n                data,\n                childLocations[i],\n                condition.children[i],\n                result.consumptions,\n                context\n            );\n            if (result.status != Status.Ok) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    function _and(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        result.consumptions = consumptions;\n        for (uint256 i; i < condition.children.length; ++i) {\n            result = evaluate(\n                data,\n                location,\n                condition.children[i],\n                result.consumptions,\n                context\n            );\n            if (result.status != Status.Ok) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    function _or(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        for (uint256 i; i < condition.children.length; ++i) {\n            result = evaluate(\n                data,\n                location,\n                condition.children[i],\n                consumptions,\n                context\n            );\n            if (result.status == Status.Ok) {\n                return result;\n            }\n        }\n\n        return _violation(Status.OrViolation, location, condition);\n    }\n\n    function _arrayIterator(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        bool every = condition.operator == Operator.ArrayEvery;\n\n        (uint256[] memory childLocations, bool overflow) = AbiLocation.children(\n            data,\n            location,\n            condition\n        );\n\n        if (overflow) {\n            return _violation(Status.CalldataOverflow, location, condition);\n        }\n\n        result.consumptions = consumptions;\n        for (uint256 i; i < childLocations.length; ++i) {\n            result = evaluate(\n                data,\n                childLocations[i],\n                condition.children[0],\n                every ? result.consumptions : consumptions,\n                context\n            );\n\n            if (every) {\n                if (result.status != Status.Ok) {\n                    result.status = Status.NotEveryArrayElementPasses;\n                    return result;\n                }\n            } else {\n                if (result.status == Status.Ok) {\n                    return result;\n                }\n            }\n        }\n\n        return\n            every\n                ? result\n                : _violation(Status.NoArrayElementPasses, location, condition);\n    }\n\n    function _arrayTailMatches(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        // Decode array element locations\n        (uint256[] memory childLocations, bool overflow) = AbiLocation.children(\n            data,\n            location,\n            condition\n        );\n\n        if (overflow) {\n            return _violation(Status.CalldataOverflow, location, condition);\n        }\n\n        uint256 conditionCount = condition.children.length;\n        uint256 childCount = childLocations.length;\n\n        if (childCount < conditionCount) {\n            return _violation(Status.ParameterNotAMatch, location, condition);\n        }\n\n        uint256 tailOffset = childCount - conditionCount;\n\n        result.consumptions = consumptions;\n        for (uint256 i; i < conditionCount; ++i) {\n            result = evaluate(\n                data,\n                childLocations[tailOffset + i],\n                condition.children[i],\n                result.consumptions,\n                context\n            );\n\n            if (result.status != Status.Ok) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    function _zipIterator(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        bool every = condition.operator == Operator.ZipEvery;\n\n        (\n            uint256[][] memory locations,\n            uint256 length,\n            Status status\n        ) = _zipLocations(data, condition, context);\n\n        if (status != Status.Ok) {\n            return _violation(status, location, condition);\n        }\n\n        Condition[] memory fields = condition.children[0].children;\n\n        result.consumptions = consumptions;\n        for (uint256 i; i < length; ++i) {\n            // For ZipSome, we always start from base consumptions.\n            if (!every) result.consumptions = consumptions;\n\n            bool tuplePasses = true;\n            for (uint256 f; f < fields.length; ++f) {\n                result = evaluate(\n                    data,\n                    locations[f][i],\n                    fields[f],\n                    result.consumptions,\n                    context\n                );\n                if (result.status != Status.Ok) {\n                    tuplePasses = false;\n                    break;\n                }\n            }\n\n            if (every) {\n                if (!tuplePasses) {\n                    result.status = Status.NotEveryZippedElementPasses;\n                    return result;\n                }\n            } else {\n                if (tuplePasses) {\n                    return result;\n                }\n            }\n        }\n\n        return\n            every\n                ? result\n                : _violation(Status.NoZippedElementPasses, location, condition);\n    }\n\n    /*\n     * Slice computes a new location pointing to a byte-range within the\n     * current location, so the child transparently evaluates against that\n     * slice.\n     *\n     * The child will read the slice via __input, which right-aligns values\n     * <=32 bytes to match comparison compValue encoding.\n     */\n    function _slice(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private view returns (Result memory result) {\n        // compValue layout: | 2 bytes: shift | 1 byte: size (1-32)\n        uint16 shift = uint16(bytes2(condition.compValue));\n        uint8 size = uint8(condition.compValue[2]);\n\n        Condition memory sliced = condition.children[0];\n        sliced.size = size;\n\n        return\n            evaluate(\n                data,\n                // compute the slices location\n                location + (condition.inlined ? 0 : 32) + shift,\n                sliced,\n                consumptions,\n                context\n            );\n    }\n\n    function _pluck(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions,\n        Context memory context\n    ) private pure returns (Result memory) {\n        (bytes32 pluckedValue, bool overflow) = __input(\n            data,\n            location,\n            condition,\n            context\n        );\n        if (overflow) {\n            return _violation(Status.CalldataOverflow, location, condition);\n        }\n\n        uint256 index = uint8(condition.compValue[0]);\n        context.pluckedLocations[index] = location;\n        context.pluckedValues[index] = pluckedValue;\n\n        return _ok(consumptions);\n    }\n\n    function __compare(\n        bytes32 value,\n        Condition memory condition\n    ) private pure returns (Status) {\n        bytes32 compValue = condition.compValue.length > 32\n            ? keccak256(condition.compValue)\n            : bytes32(condition.compValue);\n\n        if (condition.operator == Operator.EqualTo) {\n            return value == compValue ? Status.Ok : Status.ParameterNotAllowed;\n        }\n        if (condition.operator == Operator.GreaterThan) {\n            return\n                value > compValue ? Status.Ok : Status.ParameterLessThanAllowed;\n        }\n        return\n            value < compValue ? Status.Ok : Status.ParameterGreaterThanAllowed;\n    }\n\n    function __compareSigned(\n        bytes32 rawValue,\n        Condition memory condition\n    ) private pure returns (Status) {\n        int256 value = int256(uint256(rawValue));\n        int256 compValue = int256(uint256(bytes32(condition.compValue)));\n\n        if (condition.operator == Operator.SignedIntGreaterThan) {\n            return\n                value > compValue ? Status.Ok : Status.ParameterLessThanAllowed;\n        }\n        return\n            value < compValue ? Status.Ok : Status.ParameterGreaterThanAllowed;\n    }\n\n    function __allowance(\n        uint256 value,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions\n    ) private view returns (Result memory) {\n        (\n            Status status,\n            Consumption[] memory nextConsumptions\n        ) = WithinAllowanceChecker.check(\n                consumptions,\n                value,\n                condition.compValue\n            );\n\n        return _result(status, location, condition, nextConsumptions);\n    }\n\n    /**\n     * @dev Reads a value from calldata or from Transaction.value, right-aligning when needed.\n     *      - Encoding.None: returns context.value (ether amount)\n     *      - size <= 32: reads from calldata and right-aligns\n     *      - size > 32: returns keccak256 hash of the calldata slice\n     *\n     * @param data      The calldata to read from.\n     * @param location  The location in calldata.\n     * @param condition The condition with layout info.\n     * @param context   The execution context (for ether value).\n     * @return result   The value as bytes32, right-aligned or hashed.\n     */\n    function __input(\n        bytes calldata data,\n        uint256 location,\n        Condition memory condition,\n        Context memory context\n    ) private pure returns (bytes32 result, bool overflow) {\n        /*\n         * Integrity rules map Encoding.EtherValue -> Encoding.None during packing.\n         * If we encounter Encoding.None here (in a comparison context), it acts as\n         * a virtual static parameter representing the transaction value.\n         */\n        if (condition.encoding == Encoding.None) {\n            return (bytes32(context.value), false);\n        }\n\n        // Check if condition has size set (e.g., from Slice), otherwise get from decoder\n        uint256 size = condition.size != 0\n            ? condition.size\n            : AbiLocation.size(data, location, condition);\n\n        if (location + size > data.length) {\n            return (0, true);\n        }\n\n        if (size == 32) {\n            assembly {\n                result := calldataload(add(data.offset, location))\n            }\n            return (result, false);\n        }\n\n        // align the word for slicing\n        if (size < 32) {\n            return (\n                bytes32(data[location:location + size]) >> ((32 - size) * 8),\n                false\n            );\n        }\n\n        // size > 32\n        return (keccak256(data[location:location + size]), false);\n    }\n\n    function _ok(\n        Consumption[] memory consumptions\n    ) private pure returns (Result memory) {\n        return\n            Result({\n                status: Status.Ok,\n                violatedNodeIndex: 0,\n                payloadLocation: 0,\n                consumptions: consumptions\n            });\n    }\n\n    function _violation(\n        Status status,\n        uint256 location,\n        Condition memory condition\n    ) private pure returns (Result memory) {\n        Consumption[] memory empty;\n        return\n            Result({\n                status: status,\n                violatedNodeIndex: condition.index,\n                payloadLocation: location,\n                consumptions: empty\n            });\n    }\n\n    function _result(\n        Status status,\n        uint256 location,\n        Condition memory condition,\n        Consumption[] memory consumptions\n    ) private pure returns (Result memory) {\n        return\n            status == Status.Ok\n                ? _ok(consumptions)\n                : _violation(status, location, condition);\n    }\n\n    /**\n     * @dev Resolves element locations for arrays being zipped together.\n     *\n     * @param data      The calldata being evaluated.\n     * @param condition The Zip condition (ZipSome / ZipEvery).\n     * @param context   Evaluation context with pluckedLocations.\n     *\n     * @return result One uint256[] per array – element locations in calldata.\n     * @return length The common length of all zipped arrays.\n     * @return status Status.Ok, or an error\n     */\n    function _zipLocations(\n        bytes calldata data,\n        Condition memory condition,\n        Context memory context\n    )\n        private\n        pure\n        returns (uint256[][] memory result, uint256 length, Status status)\n    {\n        Condition[] memory fields = condition.children[0].children;\n        Condition memory stub;\n        stub.encoding = Encoding.Array;\n        stub.children = new Condition[](1);\n\n        result = new uint256[][](fields.length);\n\n        for (uint256 f; f < fields.length; ++f) {\n            stub.children[0] = fields[f];\n            (uint256[] memory locations, bool overflow) = AbiLocation.children(\n                data,\n                context.pluckedLocations[uint8(condition.compValue[f])],\n                stub\n            );\n\n            if (overflow) return (result, 0, Status.CalldataOverflow);\n\n            if (f == 0) {\n                length = locations.length;\n            } else {\n                if (length != locations.length) {\n                    return (result, 0, Status.ZippedArrayLengthMismatch);\n                }\n            }\n\n            result[f] = locations;\n        }\n    }\n}\n"
          },
          "contracts/core/evaluate/CustomConditionChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../periphery/interfaces/ICustomCondition.sol\";\nimport \"../../types/Types.sol\";\nimport \"../../common/AbiLocation.sol\";\n\n/**\n * @title CustomConditionChecker\n * @notice Validates transactions against external custom condition adapters.\n *\n * @dev Safely invokes ICustomCondition.check via staticcall, handling all\n *      error scenarios:\n *\n *   | Scenario              | staticcall Result     | Behavior                      | Status                          |\n *   |-----------------------|-----------------------|-------------------------------|---------------------------------|\n *   | No code at address    | (true, \"\")            | extcodesize == 0              | CustomConditionNotAContract     |\n *   | Wrong interface       | (false, \"\")           | staticcall fails              | CustomConditionReverted         |\n *   | Function reverts      | (false, <error data>) | staticcall fails              | CustomConditionReverted         |\n *   | Returns wrong type    | (true, <len != 32>)   | returnData.length != 32       | CustomConditionInvalidResult    |\n *   | Returns false         | (true, <32 bytes>)    | Adapter rejects the condition | CustomConditionViolation        |\n *\n * @author gnosisguild\n */\nlibrary CustomConditionChecker {\n    /**\n     * @notice Evaluates a custom condition against an external adapter.\n     * @param compValue Packed config: adapter address (20 bytes) + optional extra data\n     * @param to Target address of the transaction\n     * @param value ETH value of the transaction\n     * @param data Calldata of the transaction\n     * @param operation Call or DelegateCall\n     * @param location Byte offset into calldata\n     * @param condition The condition with payload info for size computation\n     * @param pluckedValues Array of previously plucked values\n     * @return status Ok if condition passes, error status otherwise\n     */\n    function check(\n        bytes memory compValue,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 location,\n        Condition memory condition,\n        bytes32[] memory pluckedValues\n    ) internal view returns (Status status) {\n        address adapter = address(bytes20(compValue));\n\n        uint256 size = condition.size != 0\n            ? condition.size\n            : AbiLocation.size(data, location, condition);\n\n        bytes memory extra;\n        if (compValue.length > 20) {\n            assembly {\n                let len := sub(mload(compValue), 20)\n                extra := mload(0x40)\n                mstore(0x40, add(extra, add(0x40, len)))\n                mstore(extra, len)\n                mcopy(add(extra, 0x20), add(compValue, 0x34), len)\n            }\n        }\n\n        return\n            _invoke(\n                adapter,\n                to,\n                value,\n                data,\n                operation,\n                location,\n                size,\n                extra,\n                pluckedValues\n            );\n    }\n\n    /**\n     * @dev Safely invokes the adapter via staticcall.\n     */\n    function _invoke(\n        address adapter,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 location,\n        uint256 size,\n        bytes memory extra,\n        bytes32[] memory pluckedValues\n    ) private view returns (Status) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(adapter)\n        }\n        if (codeSize == 0) {\n            return Status.CustomConditionNotAContract;\n        }\n\n        (bool callSuccess, bytes memory returnData) = adapter.staticcall(\n            abi.encodeCall(\n                ICustomCondition.check,\n                (\n                    to,\n                    value,\n                    data,\n                    operation,\n                    location,\n                    size,\n                    extra,\n                    pluckedValues\n                )\n            )\n        );\n\n        if (!callSuccess) {\n            return Status.CustomConditionReverted;\n        }\n\n        if (returnData.length != 32) {\n            return Status.CustomConditionInvalidResult;\n        }\n\n        bool success = abi.decode(returnData, (bool));\n        if (!success) {\n            return Status.CustomConditionViolation;\n        }\n\n        return Status.Ok;\n    }\n}\n"
          },
          "contracts/core/evaluate/WithinAllowanceChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../common/AllowanceLoader.sol\";\nimport \"../../common/ConsumptionList.sol\";\nimport \"../../common/PriceConversion.sol\";\nimport \"../../types/Types.sol\";\n\nimport {Consumption} from \"../../types/Allowance.sol\";\n\n/**\n * @title WithinAllowanceChecker\n * @notice Validates allowance consumption with optional amount conversion.\n *\n * @dev Checks if a value is within an allowance and consumes it. The value is\n *      normalized to the allowance's base denomination via decimal scaling\n *      and/or exchange rate conversion.\n *\n *      The `consumptions` array is treated as immutable. If consumption occurs,\n *      a new array is allocated and returned (Copy-on-Write).\n *\n * @author gnosisguild\n */\nlibrary WithinAllowanceChecker {\n    function check(\n        Consumption[] memory consumptions,\n        uint256 value,\n        bytes memory compValue\n    ) internal view returns (Status status, Consumption[] memory) {\n        bytes32 allowanceKey = bytes32(compValue);\n\n        // 1. Convert value to base denomination\n        (status, value) = _convert(value, compValue);\n        if (status != Status.Ok) {\n            return (status, consumptions);\n        }\n\n        // 2. Find in list\n        uint256 index;\n        for (; index < consumptions.length; ++index) {\n            if (consumptions[index].allowanceKey == allowanceKey) break;\n        }\n\n        // 3. Copy existing or load from storage\n        Consumption memory consumption;\n        if (index < consumptions.length) {\n            consumption = Consumption(\n                allowanceKey,\n                consumptions[index].balance,\n                consumptions[index].consumed,\n                consumptions[index].timestamp\n            );\n        } else {\n            (uint128 balance, uint64 timestamp) = AllowanceLoader.accrue(\n                allowanceKey,\n                uint64(block.timestamp)\n            );\n            consumption = Consumption(allowanceKey, balance, 0, timestamp);\n        }\n\n        // 4. Check overflow before consuming\n        if (consumption.consumed + value > type(uint128).max) {\n            return (Status.AllowanceValueOverflow, consumptions);\n        }\n\n        // 5. Consume\n        consumption.consumed += uint128(value);\n\n        // 6. Check balance\n        if (consumption.consumed > consumption.balance) {\n            return (Status.AllowanceExceeded, consumptions);\n        }\n\n        // 7. Return updated list\n        return (\n            Status.Ok,\n            ConsumptionList.copyOnWrite(consumptions, consumption, index)\n        );\n    }\n\n    /**\n     * @dev Normalizes a value to the allowance's base denomination.\n     *\n     *      Calculates the final amount via decimal scaling and optionally\n     *      an exchange rate (via price adapter). Scaling is possible without\n     *      an adapter by providing both base and param decimals.\n     *\n     * @param value The raw amount to be converted.\n     * @param compValue Configuration bytes containing decimals and adapter.\n     * @return status Result of the conversion (Ok or price adapter error).\n     * @return converted Normalized amount in the allowance's base decimals.\n     */\n    function _convert(\n        uint256 value,\n        bytes memory compValue\n    ) private view returns (Status, uint256) {\n        /**\n         * CompValue Layout (32, 34, or 54 bytes):\n         * ┌─────────────────────────┬──────────┬──────────┬─────────────────────┐\n         * │      allowanceKey       │   base   │  param   │       adapter       │\n         * │        (bytes32)        │ decimals │ decimals │      (address)      │\n         * ├─────────────────────────┼──────────┼──────────┼─────────────────────┤\n         * │         0 - 31          │    32    │    33    │       34 - 53       │\n         * └─────────────────────────┴──────────┴──────────┴─────────────────────┘\n         *                           └── optional ─────────┴───── optional ──────┘\n         *\n         * baseDecimals: decimals of the allowance unit  (how it's accounted)\n         * paramDecimals: decimals of the parameter value (from calldata)\n         */\n\n        if (compValue.length == 32) {\n            return (Status.Ok, value);\n        }\n\n        uint256 baseDecimals = uint8(compValue[32]);\n        uint256 paramDecimals = uint8(compValue[33]);\n\n        // Scale decimals\n        if (baseDecimals >= paramDecimals) {\n            value = value * (10 ** (baseDecimals - paramDecimals));\n        } else {\n            value = value / (10 ** (paramDecimals - baseDecimals));\n        }\n\n        address adapter;\n        if (compValue.length > 34) {\n            assembly {\n                adapter := shr(96, mload(add(compValue, 0x42)))\n            }\n        }\n\n        return PriceConversion.convert(value, adapter);\n    }\n}\n"
          },
          "contracts/core/evaluate/WithinRatioChecker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../common/PriceConversion.sol\";\nimport \"../../types/Types.sol\";\n\n/**\n * @title WithinRatioChecker\n * @notice Validates that a relative amount falls within a ratio range of a\n *         reference amount, with optional price adapter conversion.\n *\n * @dev Ratio is computed in basis points (10000 = 100%). Both amounts are read\n *      from pluckedValues by index, scaled to shared precision, optionally\n *      converted via price adapters, then compared against [minRatio, maxRatio].\n *\n * @author gnosisguild\n */\nlibrary WithinRatioChecker {\n    /**\n     * @dev Configuration decoded from compValue bytes.\n     *\n     *\n     * Layout (12 or 52 bytes):\n     * ┌───────────────────┬───────────────────┬───────────────────┬───────────────────┬────────────┬────────────┬───────────────────┬───────────────────┐\n     * │ referencePluckIdx │ referenceDecimals │ relativePluckIdx  │ relativeDecimals  │  minRatio  │  maxRatio  │ referenceAdapter  │ relativeAdapter   │\n     * │      (uint8)      │      (uint8)      │      (uint8)      │      (uint8)      │  (uint32)  │  (uint32)  │     (address)     │     (address)     │\n     * ├───────────────────┼───────────────────┼───────────────────┼───────────────────┼────────────┼────────────┼───────────────────┼───────────────────┤\n     * │         0         │         1         │         2         │         3         │    4–7     │    8–11    │      12–31        │      32–51        │\n     * └───────────────────┴───────────────────┴───────────────────┴───────────────────┴────────────┴────────────┴───────────────────┴───────────────────┘\n     *                                                                                                          └─────────────────── optional ──────────┘\n     */\n    struct CompValue {\n        uint8 referencePluckIndex;\n        uint8 referenceDecimals;\n        uint8 relativePluckIndex;\n        uint8 relativeDecimals;\n        uint32 minRatio;\n        uint32 maxRatio;\n        address referenceAdapter;\n        address relativeAdapter;\n    }\n\n    uint256 private constant BPS = 10000;\n\n    /**\n     * @notice Checks if ratio of relative to reference amount is within bounds.\n     * @param compValue Packed configuration bytes\n     * @param pluckedValues Array of values extracted from calldata\n     * @return Status Ok if within bounds, error status otherwise\n     */\n    function check(\n        bytes memory compValue,\n        bytes32[] memory pluckedValues\n    ) internal view returns (Status) {\n        CompValue memory config = _unpack(compValue);\n        (\n            Status status,\n            uint256 referenceAmount,\n            uint256 relativeAmount\n        ) = _convert(config, pluckedValues);\n        if (status != Status.Ok) {\n            return status;\n        }\n\n        /*\n         *                 relativeAmount × priceRel\n         *   ratio (bps) = ───────────────────────── × 10,000\n         *                 referenceAmount × priceRef\n         */\n        uint256 ratio = (relativeAmount * BPS) / referenceAmount;\n\n        if (config.minRatio != 0 && ratio < config.minRatio) {\n            return Status.RatioBelowMin;\n        }\n        if (config.maxRatio != 0 && ratio > config.maxRatio) {\n            return Status.RatioAboveMax;\n        }\n\n        return Status.Ok;\n    }\n\n    /**\n     * @dev Extracts and converts reference and relative amounts for ratio comparison.\n     *\n     *      1. Reads raw values from pluckedValues by index\n     *      2. Scales both to the higher decimal precision\n     *      3. Applies price adapters (if configured)\n     */\n    function _convert(\n        CompValue memory config,\n        bytes32[] memory pluckedValues\n    )\n        private\n        view\n        returns (Status status, uint256 referenceAmount, uint256 relativeAmount)\n    {\n        uint256 precision = config.referenceDecimals > config.relativeDecimals\n            ? config.referenceDecimals\n            : config.relativeDecimals;\n\n        (status, referenceAmount) = _scaleAndPrice(\n            uint256(pluckedValues[config.referencePluckIndex]),\n            config.referenceDecimals,\n            precision,\n            config.referenceAdapter\n        );\n        if (status != Status.Ok) return (status, 0, 0);\n\n        (status, relativeAmount) = _scaleAndPrice(\n            uint256(pluckedValues[config.relativePluckIndex]),\n            config.relativeDecimals,\n            precision,\n            config.relativeAdapter\n        );\n        if (status != Status.Ok) return (status, 0, 0);\n    }\n\n    function _scaleAndPrice(\n        uint256 value,\n        uint256 decimals,\n        uint256 precision,\n        address adapter\n    ) private view returns (Status, uint256) {\n        return\n            PriceConversion.convert(\n                value * (10 ** (precision - decimals)),\n                adapter\n            );\n    }\n\n    function _unpack(\n        bytes memory compValue\n    ) private pure returns (CompValue memory config) {\n        bytes32 packed = bytes32(compValue);\n\n        config.referencePluckIndex = uint8(bytes1(packed));\n        config.referenceDecimals = uint8(bytes1(packed << 8));\n        config.relativePluckIndex = uint8(bytes1(packed << 16));\n        config.relativeDecimals = uint8(bytes1(packed << 24));\n        config.minRatio = uint32(bytes4(packed << 32));\n        config.maxRatio = uint32(bytes4(packed << 64));\n        config.referenceAdapter = address(bytes20(packed << 96));\n\n        if (compValue.length > 32) {\n            assembly {\n                mstore(add(config, 0xe0), shr(96, mload(add(compValue, 0x40))))\n            }\n        }\n    }\n}\n"
          },
          "contracts/core/Membership.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Storage.sol\";\n\n/**\n * @title   Membership\n * @notice  Validates that a module holds an active role membership before\n *          authorizing transactions. Memberships can be time-bound and usage-limited.\n *\n * @dev     moduleOnly reverts if the call is not sent or signed by an enabled module.\n *          Membership packs timestamps and uses into a single uint256. See layout below.\n *\n * @author  gnosisguild\n */\n\nabstract contract Membership is RolesStorage {\n    uint256 private constant _MEMBERSHIP_NOOP = type(uint256).max;\n    uint256 private constant _MEMBERSHIP_REVOKE = 0;\n\n    function _authenticate(\n        bytes32 roleKey\n    ) internal moduleOnly returns (address module, uint256 nextMembership) {\n        // Never authorize the zero role\n        if (roleKey == 0) {\n            revert NoMembership();\n        }\n\n        module = sentOrSignedByModule();\n\n        uint256 membership = roles[roleKey].members[module];\n        if (membership == 0) {\n            revert NoMembership();\n        }\n\n        /*\n         * Membership Layout (256 bits)\n         * ┌────────────────┬────────────────┬─────────────────────────────────┐\n         * │ startTimestamp │  endTimestamp  │            usesLeft             │\n         * │    64 bits     │    64 bits     │            128 bits             │\n         * └────────────────┴────────────────┴─────────────────────────────────┘\n         *\n         * - startTimestamp: Unix timestamp when membership becomes valid\n         * - endTimestamp:   Unix timestamp when membership expires\n         * - usesLeft:       Remaining uses (type(uint128).max = unlimited)\n         */\n\n        if (block.timestamp < uint64(membership >> 192)) {\n            revert MembershipNotYetValid();\n        }\n        if (block.timestamp > uint64(membership >> 128)) {\n            revert MembershipExpired();\n        }\n        if (~membership << 128 == 0) {\n            // unlimited uses\n            return (module, _MEMBERSHIP_NOOP);\n        }\n\n        uint256 usesLeft = (membership << 128) >> 128;\n\n        return (\n            module,\n            usesLeft <= 1\n                ? _MEMBERSHIP_REVOKE\n                : ((membership >> 128) << 128) | (usesLeft - 1)\n        );\n    }\n}\n"
          },
          "contracts/core/serialize/ConditionLoader.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../common/ImmutableStorage.sol\";\n\nimport \"./ConditionUnpacker.sol\";\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title ConditionLoader\n * @notice Loads and unpacks condition trees from immutable storage.\n *\n * @author gnosisguild\n */\nlibrary ConditionLoader {\n    /**\n     * @param scopeConfig Packed scopeSonfig (options << 160 | pointer).\n     * @return condition The unpacked condition tree with embedded layout.\n     * @return maxPluckIndex Maximum pluck index for pluck bag allocation.\n     */\n    function load(\n        uint256 scopeConfig\n    )\n        internal\n        view\n        returns (Condition memory condition, uint256 maxPluckIndex)\n    {\n        address pointer = address(uint160(scopeConfig));\n        bytes memory buffer = ImmutableStorage.load(pointer);\n        return ConditionUnpacker.unpack(buffer);\n    }\n}\n"
          },
          "contracts/core/serialize/ConditionPacker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\n\n/**\n * @title  ConditionPacker\n * @notice A library that provides packing functions for conditions,\n *         transforming ConditionsFlat[] into a memory-optimized buffer.\n *\n * @dev    This library is NOT gas-sensitive since packing is intended to be\n *         called as a helper function within a view entrypoint.\n *\n * @author gnosisguild\n *\n * ╔════════════════════════════════ BUFFER ═════════════════════════════════╗\n * ║ ┌─────────────────────────────────────────────────────────────────────┐ ║\n * ║ │ HEADER (3 bytes = 24 bits)                                          │ ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤ ║\n * ║ │ • conditionNodeCount     16 bits (bytes 0-1)                        │ ║\n * ║ │ • maxPluckValue           8 bits (byte 2)                           │ ║\n * ║ └─────────────────────────────────────────────────────────────────────┘ ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐ ║\n * ║ │ NODES (nodeCount × 4 bytes each)                                    │ ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤ ║\n * ║ │ Each node (32 bits = 4 bytes):                                      │ ║\n * ║ │   • encoding              3 bits  [31-29]                           │ ║\n * ║ │   • operator              5 bits  [28-24]                           │ ║\n * ║ │   • childCount           10 bits  [23-14]                           │ ║\n * ║ │   • inlinedSize          13 bits  [13-1]                            │ ║\n * ║ │   • hasCompValue          1 bit   [0]                               │ ║\n * ║ └─────────────────────────────────────────────────────────────────────┘ ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐ ║\n * ║ │ COMPVALUES (variable length)                                        │ ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤ ║\n * ║ │ For each node with hasCompValue=true (in BFS order):                │ ║\n * ║ │   • length               16 bits  (compValue byte length)           │ ║\n * ║ │   • data                 N bytes  (actual compValue data)           │ ║\n * ║ └─────────────────────────────────────────────────────────────────────┘ ║\n * ╚═════════════════════════════════════════════════════════════════════════╝\n *\n */\nlibrary ConditionPacker {\n    uint256 private constant HEADER_BYTES = 3;\n    uint256 private constant NODE_BYTES = 4;\n\n    function pack(\n        ConditionFlat[] memory conditions\n    ) internal pure returns (bytes memory buffer) {\n        _transform(conditions);\n\n        (uint256 compValuesSize, uint256 maxPluckCount) = _count(conditions);\n\n        uint256 nodeCount = conditions.length;\n\n        buffer = new bytes(\n            HEADER_BYTES + nodeCount * NODE_BYTES + compValuesSize\n        );\n\n        uint256 header = (nodeCount << 8) | maxPluckCount;\n        assembly {\n            mstore(add(buffer, 0x20), shl(232, header))\n        }\n\n        _packNodes(conditions, buffer);\n    }\n\n    function _packNodes(\n        ConditionFlat[] memory conditions,\n        bytes memory buffer\n    ) private pure {\n        uint256 offset = HEADER_BYTES;\n        uint256 compValueOffset = HEADER_BYTES + conditions.length * NODE_BYTES;\n\n        for (uint256 i; i < conditions.length; ++i) {\n            ConditionFlat memory condition = conditions[i];\n\n            Encoding encoding = condition.paramType;\n            (, uint256 childCount) = Topology.childBounds(conditions, i);\n            uint256 inlinedSize = Topology.isInlined(conditions, i)\n                ? Topology.inlinedSize(conditions, i)\n                : 0;\n\n            bytes memory compValue = condition.compValue;\n            uint256 compValueLength = compValue.length;\n            bool hasCompValue = compValueLength > 0;\n\n            /*\n             * ┌───────────────────────────────────────────────────────────┐\n             * │ packed 32 bits, 4 bytes:                                  │\n             * │   • encoding              3 bits  [31-29]                 │\n             * │   • operator              5 bits  [28-24]                 │\n             * │   • childCount           10 bits  [23-14]                 │\n             * │   • inlinedSize          13 bits  [13-1]                  │\n             * │   • hasCompValue          1 bit   [0]                     │\n             * └───────────────────────────────────────────────────────────┘\n             */\n            uint256 packed = (uint256(encoding) << 29) |\n                (uint256(condition.operator) << 24) |\n                (childCount << 14) |\n                (inlinedSize << 1) |\n                (hasCompValue ? 1 : 0);\n\n            /*\n             * The or with mload preserves bytes 4-31 (compValues written in\n             * previous iterations) while writing our 4 bytes at positions 0-3.\n             */\n            assembly {\n                let dest := add(add(buffer, 0x20), offset)\n                mstore(dest, or(mload(dest), shl(224, packed)))\n            }\n            offset += NODE_BYTES;\n\n            // Pack compValue writes at tail, no preserving required\n            if (hasCompValue) {\n                assembly {\n                    let dest := add(add(buffer, 0x20), compValueOffset)\n                    // write 2 bytes length\n                    mstore(dest, shl(240, compValueLength))\n                    // copy compValue body\n                    mcopy(add(dest, 2), add(compValue, 0x20), compValueLength)\n                }\n                compValueOffset = compValueOffset + 2 + compValueLength;\n            }\n        }\n    }\n\n    function _count(\n        ConditionFlat[] memory conditions\n    ) private pure returns (uint256 compValuesSize, uint256 maxPluckCount) {\n        for (uint256 i; i < conditions.length; ++i) {\n            if (conditions[i].operator == Operator.Pluck) {\n                uint8 pluckIndex = uint8(conditions[i].compValue[0]);\n                if (pluckIndex + 1 > maxPluckCount) {\n                    maxPluckCount = pluckIndex + 1;\n                }\n            }\n\n            uint256 length = conditions[i].compValue.length;\n            if (length > 0) {\n                compValuesSize += 2 + length;\n            }\n        }\n    }\n\n    /**\n     * @dev Normalizes conditions in-place before packing:\n     *      1. AbiEncoded without compValue gets default leadingBytes (0x0004)\n     *      2. EqualTo at offset has 32-byte head pointer stripped\n     */\n    function _transform(ConditionFlat[] memory conditions) private pure {\n        for (uint256 i; i < conditions.length; ++i) {\n            /*\n             * Patch AbiEncoded leadingBytes\n             *\n             * AbiEncoded nodes without compValue need a default leadingBytes of 4\n             * (function selector size). Store as 2-byte big-endian value.\n             */\n            if (\n                conditions[i].paramType == Encoding.AbiEncoded &&\n                conditions[i].compValue.length == 0\n            ) {\n                conditions[i].compValue = hex\"0004\";\n            }\n\n            /*\n             * Remove Extraneous Offsets\n             *\n             * Remove unnecessary offsets from compValue fields. This ensures a\n             * consistent API where every `compValue` provided for use in\n             * `Operator.EqualTo` is obtained by calling `abi.encode` directly.\n             *\n             * By removing the leading extraneous offset this makes\n             * `abi.encode(...)` output line up with the layout produced by\n             * Decoder inspection. Without it, callers would need to patch\n             * compValues based on whether the payload is fully inline or at\n             * offset.\n             */\n            if (\n                conditions[i].operator == Operator.EqualTo &&\n                !Topology.isInlined(conditions, i)\n            ) {\n                bytes memory compValue = conditions[i].compValue;\n                assembly {\n                    let newLength := sub(mload(compValue), 32)\n                    compValue := add(compValue, 32)\n                    mstore(compValue, newLength)\n                }\n                conditions[i].compValue = compValue;\n            }\n        }\n    }\n}\n"
          },
          "contracts/core/serialize/ConditionStorer.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../common/ImmutableStorage.sol\";\n\nimport \"./ConditionPacker.sol\";\nimport \"./Integrity.sol\";\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title ConditionStorer\n * @notice Validates and stores condition trees in immutable storage.\n *\n * @author gnosisguild\n */\nlibrary ConditionStorer {\n    /**\n     * @notice Validates and packs a condition tree into bytes.\n     *\n     * @param conditions The flat condition array in BFS order.\n     * @return buffer The packed condition buffer.\n     */\n    function pack(\n        ConditionFlat[] memory conditions\n    ) external pure returns (bytes memory buffer) {\n        Integrity.enforce(conditions);\n        return ConditionPacker.pack(conditions);\n    }\n\n    /**\n     * @notice Stores a pre-packed condition buffer.\n     *\n     * @param buffer The packed condition buffer (from pack()).\n     * @param options Execution options (Send, DelegateCall, Both, None).\n     * @return scopeConfig Packed scope config (options << 160 | pointer).\n     */\n    function store(\n        bytes memory buffer,\n        ExecutionOptions options\n    ) external returns (uint256 scopeConfig) {\n        address pointer = ImmutableStorage.store(buffer);\n        return (uint256(options) << 160) | uint160(pointer);\n    }\n}\n"
          },
          "contracts/core/serialize/ConditionUnpacker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title  ConditionUnpacker\n * @notice A library that provides unpacking functions for reconstructing the\n *         Condition tree from a memory-optimized buffer.\n *\n * @dev    This is performance-critical code. Every transaction execution\n *         begins by loading packed conditions from contract storage\n *         (via extcodecopy) and performing tree unpacking. The implementation\n *         is deliberately low-level to minimize execution overhead.\n *\n * @author gnosisguild\n */\nlibrary ConditionUnpacker {\n    uint256 private constant HEADER_BYTES = 3;\n    uint256 private constant NODE_BYTES = 4;\n\n    function unpack(\n        bytes memory buffer\n    )\n        internal\n        view\n        returns (Condition memory condition, uint256 maxPluckValue)\n    {\n        /*\n         * ┌───────────────────────────────────────────────────────────────┐\n         * │ header 24 bits, 3 bytes:                                      │\n         * │   • conditionNodeCount    16 bits  [23-8]                     │\n         * │   • maxPluckCount          8 bits  [7-0]                      │\n         * └───────────────────────────────────────────────────────────────┘\n         */\n        uint256 header = uint24(bytes3(buffer));\n\n        Condition[] memory conditions = new Condition[]((header >> 8));\n\n        _unpackConditions(buffer, conditions);\n\n        condition = conditions[0];\n        maxPluckValue = header & 0xFF;\n    }\n\n    function _unpackConditions(\n        bytes memory buffer,\n        Condition[] memory conditions\n    ) private view {\n        uint256 offset;\n        uint256 compValueOffset;\n        uint256 childConditionPtr;\n        assembly {\n            offset := add(add(buffer, 0x20), HEADER_BYTES)\n            compValueOffset := add(offset, mul(mload(conditions), NODE_BYTES))\n            childConditionPtr := add(conditions, 0x40)\n        }\n\n        for (uint256 c; c < conditions.length; ++c) {\n            /*\n             * ┌───────────────────────────────────────────────────────────┐\n             * │ packed 32 bits, 4 bytes:                                  │\n             * │   • encoding              3 bits  [31-29]                 │\n             * │   • operator              5 bits  [28-24]                 │\n             * │   • childCount           10 bits  [23-14]                 │\n             * │   • inlinedSize          13 bits  [13-1]                  │\n             * │   • hasCompValue          1 bit   [0]                     │\n             * └───────────────────────────────────────────────────────────┘\n             */\n            uint256 packed;\n            assembly {\n                packed := shr(224, mload(offset))\n                offset := add(offset, NODE_BYTES)\n            }\n\n            Condition memory condition = conditions[c];\n\n            // Extract fields from packed bits\n            uint256 encoding = (packed >> 29);\n            if (encoding == 6) encoding = 0; // EtherValue -> None\n            uint256 childCount = (packed >> 14) & 0x3FF;\n            uint256 inlinedSize = (packed >> 1) & 0x1FFF;\n\n            /*\n             * Set Condition fields in struct order:\n             *   0x00 index\n             *   0x20 encoding\n             *   0x40 operator\n             *   0x60 compValue     (set via assembly below)\n             *   0x80 children      (set via assembly below)\n             *   0xa0 inlined\n             *   0xc0 size\n             *   0xe0 leadingBytes  (set when parsing compValue)\n             */\n            condition.index = c;\n            condition.encoding = Encoding(encoding);\n            condition.operator = Operator((packed >> 24) & 0x1F);\n            condition.inlined = inlinedSize > 0;\n            condition.size = inlinedSize;\n\n            // hasCompValue\n            if ((packed & 1) != 0) {\n                uint256 length;\n                assembly {\n                    length := shr(240, mload(compValueOffset))\n                    compValueOffset := add(compValueOffset, 2)\n                }\n\n                // Encoding.AbiEncoded(5): first 2 bytes are leadingBytes\n                if (encoding == 5) {\n                    uint256 leadingBytes;\n                    assembly {\n                        leadingBytes := shr(240, mload(compValueOffset))\n                        compValueOffset := add(compValueOffset, 2)\n                        length := sub(length, 2)\n                    }\n                    condition.leadingBytes = leadingBytes;\n                }\n\n                // parse compValue\n                if (length > 0) {\n                    assembly {\n                        // free mem pointer: load\n                        let compValue := mload(0x40)\n                        // free mem pointer: advance\n                        mstore(0x40, add(add(compValue, 0x20), length))\n\n                        // new buffer: store length\n                        mstore(compValue, length)\n                        // new buffer: copy body\n                        mcopy(add(compValue, 0x20), compValueOffset, length)\n\n                        //condition: point to copied buffer (compValue at offset 0x60)\n                        mstore(add(condition, 0x60), compValue)\n                        // advance pointer\n                        compValueOffset := add(compValueOffset, length)\n                    }\n                }\n            }\n\n            // Parse children\n            if (childCount > 0) {\n                assembly {\n                    let size := mul(childCount, 0x20)\n                    // free mem pointer: load\n                    let dest := mload(0x40)\n                    // free mem pointer: advance\n                    mstore(0x40, add(add(dest, 0x20), size))\n\n                    // new array: store length\n                    mstore(dest, childCount)\n                    // new array: shallow copy body\n                    mcopy(add(dest, 0x20), childConditionPtr, size)\n\n                    // condition: point to copied array (children at offset 0x80)\n                    mstore(add(condition, 0x80), dest)\n                    // advance child pointer\n                    childConditionPtr := add(childConditionPtr, size)\n                }\n            }\n\n            // EqualToAvatar: replace with EqualTo + avatar address\n            if (condition.operator == Operator.EqualToAvatar) {\n                condition.operator = Operator.EqualTo;\n                address avatar;\n                assembly {\n                    avatar := sload(101)\n                }\n                condition.compValue = abi.encode(avatar);\n            }\n        }\n    }\n}\n"
          },
          "contracts/core/serialize/Integrity.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\nimport \"./TypeTree.sol\";\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title Integrity\n * @notice A library that validates input condition integrity\n *\n * @author gnosisguild\n */\nlibrary Integrity {\n    function enforce(ConditionFlat[] memory conditions) internal pure {\n        _validateBFS(conditions);\n\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            _validateOperator(conditions, i);\n            _validateEncoding(conditions, i);\n        }\n\n        _validateVariantTypes(conditions);\n        _validatePluckZipTypes(conditions);\n        _validatePluckOrder(conditions, 0, 0);\n    }\n\n    function _validateBFS(ConditionFlat[] memory conditions) private pure {\n        uint256 length = conditions.length;\n        if (length == 0 || conditions[0].parent != 0) {\n            revert IRolesError.UnsuitableRootNode();\n        }\n\n        for (uint256 i = 1; i < length; ++i) {\n            uint256 parent = conditions[i].parent;\n            if (parent == i) {\n                revert IRolesError.UnsuitableRootNode();\n            }\n            // Parent must have lower index (no forward references)\n            if (parent < conditions[i - 1].parent) {\n                revert IRolesError.NotBFS();\n            }\n            // Parent cannot be higher than self\n            if (parent >= i) {\n                revert IRolesError.NotBFS();\n            }\n        }\n    }\n\n    function _validateOperator(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        Operator op = conditions[index].operator;\n\n        if (op == Operator.Pass) {\n            _checkPass(conditions, index);\n        } else if (op == Operator.And || op == Operator.Or) {\n            _checkLogic(conditions, index);\n        } else if (op == Operator.Empty) {\n            _checkEmpty(conditions, index);\n        } else if (op == Operator.Matches) {\n            _checkMatches(conditions, index);\n        } else if (op == Operator.ArraySome || op == Operator.ArrayEvery) {\n            _checkArrayIterator(conditions, index);\n        } else if (op == Operator.ArrayTailMatches) {\n            _checkArrayTail(conditions, index);\n        } else if (op == Operator.ZipSome || op == Operator.ZipEvery) {\n            _checkZipIterator(conditions, index);\n        } else if (op == Operator.Slice) {\n            _checkSlice(conditions, index);\n        } else if (op == Operator.Pluck) {\n            _checkPluck(conditions, index);\n        } else if (op == Operator.EqualToAvatar) {\n            _checkEqualToAvatar(conditions, index);\n        } else if (op == Operator.EqualTo) {\n            _checkEqualTo(conditions, index);\n        } else if (\n            op == Operator.GreaterThan ||\n            op == Operator.LessThan ||\n            op == Operator.SignedIntGreaterThan ||\n            op == Operator.SignedIntLessThan\n        ) {\n            _checkComparison(conditions, index);\n        } else if (op == Operator.Bitmask) {\n            _checkBitmask(conditions, index);\n        } else if (op == Operator.Custom) {\n            _checkCustom(conditions, index);\n        } else if (op == Operator.WithinRatio) {\n            _checkWithinRatio(conditions, index);\n        } else if (op == Operator.WithinAllowance) {\n            _checkWithinAllowance(conditions, index);\n        } else if (op == Operator.CallWithinAllowance) {\n            _checkCallWithinAllowance(conditions, index);\n        } else {\n            revert IRolesError.UnsupportedOperator(index);\n        }\n    }\n\n    /**\n     * @notice Validates child constraints based on encoding type.\n     *\n     * @dev Encoding types determine fundamental child rules:\n     *      - Leaf types (Static, Dynamic, EtherValue): Cannot have children\n     *      - Container types (Tuple, Array): Must have structural children\n     *      - None: Operator-dependent (validated elsewhere)\n     *\n     *      Exception: Slice operator uses Static/Dynamic encoding but requires\n     *      exactly one child (validated in _checkSlice).\n     */\n    function _validateEncoding(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n\n        if (\n            (encoding == Encoding.Static ||\n                encoding == Encoding.Dynamic ||\n                encoding == Encoding.EtherValue) &&\n            (condition.operator != Operator.Slice)\n        ) {\n            // Slice is a special case: uses Static/Dynamic but requires a child\n            // Leaf types cannot have children\n            if (childCount != 0) {\n                revert IRolesError.LeafNodeCannotHaveChildren(index);\n            }\n        }\n\n        if (\n            encoding == Encoding.AbiEncoded ||\n            encoding == Encoding.Tuple ||\n            encoding == Encoding.Array\n        ) {\n            // Container types must have structural children for type tree\n            if (sChildCount == 0) {\n                revert IRolesError.UnsuitableChildCount(index);\n            }\n        }\n    }\n\n    // --- Operator Handlers ---\n\n    function _checkPass(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // Encoding: Any\n        // CompValue: Must be empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkLogic(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // And/Or\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: Must have children\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount == 0) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkEmpty(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: None\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount != 0) {\n            revert IRolesError.LeafNodeCannotHaveChildren(index);\n        }\n    }\n\n    function _checkMatches(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Tuple, Array, AbiEncoded\n        if (\n            encoding != Encoding.Tuple &&\n            encoding != Encoding.Array &&\n            encoding != Encoding.AbiEncoded\n        ) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n\n        // CompValue Validation\n        if (encoding == Encoding.AbiEncoded) {\n            uint16 leadingBytes = condition.compValue.length >= 2\n                ? uint16(bytes2(condition.compValue))\n                : 0;\n            bool valid = condition.compValue.length == 0 ||\n                condition.compValue.length == 2 ||\n                (condition.compValue.length == 2 + leadingBytes &&\n                    leadingBytes <= 32);\n            if (!valid) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n        } else {\n            if (condition.compValue.length != 0) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n        }\n\n        // All children must be structural\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n        if (sChildCount == 0 || childCount != sChildCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkArrayIterator(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ArraySome / ArrayEvery\n        // ParamType: Array\n        if (condition.paramType != Encoding.Array) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: Exactly 1 child\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n        if (sChildCount != 1 || sChildCount != childCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkArrayTail(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ArrayTailMatches\n        // ParamType: Array\n        if (condition.paramType != Encoding.Array) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: All children must be structural\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n        if (sChildCount == 0 || childCount != sChildCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkZipIterator(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ZipSome / ZipEvery\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: at least 2 bytes (one per plucked array)\n        if (condition.compValue.length < 2) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n\n        // Children: Exactly 1 child\n        (\n            uint256 childStart,\n            uint256 childCount,\n            uint256 sChildCount\n        ) = _sChildBounds(conditions, index);\n        if (sChildCount != 1 || sChildCount != childCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n\n        if (conditions[childStart].paramType != Encoding.Tuple) {\n            revert IRolesError.UnsuitableChildTypeTree(index);\n        }\n\n        // Child must resolve to a Tuple\n        Layout memory layout = TypeTree.resolve(conditions, childStart);\n        assert(layout.encoding == Encoding.Tuple);\n\n        // Tuple field count must match compValue length\n        if (layout.children.length != condition.compValue.length) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n\n        // Validate pluck references: no duplicates, each must exist and be Array\n        uint256 seen;\n        for (uint256 k = 0; k < condition.compValue.length; ++k) {\n            uint8 pluckIndex = uint8(condition.compValue[k]);\n            uint256 mask = 1 << pluckIndex;\n            if ((seen & mask) != 0) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n            seen |= mask;\n\n            (bool found, uint256 pluckCondition) = _findPluckedArray(\n                conditions,\n                pluckIndex\n            );\n            if (\n                !found || conditions[pluckCondition].paramType != Encoding.Array\n            ) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n        }\n\n        // No Pluck allowed in zip descendants\n        _validateNoPluckDescendant(conditions, childStart);\n    }\n\n    function _checkSlice(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Static / Dynamic\n        if (encoding != Encoding.Static && encoding != Encoding.Dynamic) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 3 bytes\n        if (condition.compValue.length != 3) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        uint8 size = uint8(condition.compValue[2]);\n        if (size == 0 || size > 32) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n        // Children: At most 1 child\n        if (childCount != 1) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n\n        // If it has a structural child, it must resolve to Static\n        if (conditions[childStart].paramType != Encoding.Static) {\n            revert IRolesError.SliceChildNotStatic(index);\n        }\n    }\n\n    function _checkPluck(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Static / EtherValue / Array\n        if (encoding == Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 1 byte\n        if (\n            condition.compValue.length != 1 ||\n            uint8(condition.compValue[0]) == 255\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkEqualToAvatar(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: Static\n        if (condition.paramType != Encoding.Static) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkEqualTo(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding enc = condition.paramType;\n        // ParamType: Static, Dynamic, Tuple, Array, EtherValue\n        if (enc == Encoding.None || enc == Encoding.AbiEncoded) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n\n        // CompValue check\n        bool unsuitable;\n        if (enc == Encoding.Static || enc == Encoding.EtherValue) {\n            unsuitable = condition.compValue.length != 32;\n        }\n\n        if (enc == Encoding.Tuple || enc == Encoding.Array) {\n            unsuitable = condition.compValue.length < 32;\n        }\n\n        if (unsuitable) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkComparison(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: WordLike\n        if (encoding != Encoding.Static && encoding != Encoding.EtherValue) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 32 bytes\n        if (condition.compValue.length != 32) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkBitmask(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Static / Dynamic\n        if (encoding != Encoding.Static && encoding != Encoding.Dynamic) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 2 shift + 2N\n        if (\n            condition.compValue.length < 4 ||\n            (condition.compValue.length - 2) % 2 != 0\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkCustom(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // CompValue: >= 20 bytes\n        if (condition.compValue.length < 20) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkWithinRatio(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 12, 32 or 52 bytes (12 base + 0, 1, or 2 adapters)\n        if (\n            condition.compValue.length != 12 &&\n            condition.compValue.length != 32 &&\n            condition.compValue.length != 52\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Check ratio bounds\n        uint32 minRatio;\n        uint32 maxRatio;\n        bytes memory cv = condition.compValue;\n        assembly {\n            minRatio := shr(224, mload(add(cv, 0x24)))\n            maxRatio := shr(224, mload(add(cv, 0x28)))\n        }\n        if (minRatio == 0 && maxRatio == 0) {\n            revert IRolesError.WithinRatioNoRatioProvided(index);\n        }\n        // Children: None\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount != 0) {\n            revert IRolesError.LeafNodeCannotHaveChildren(index);\n        }\n    }\n\n    function _checkWithinAllowance(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: WordLike\n        if (encoding != Encoding.Static && encoding != Encoding.EtherValue) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 32, 34, 54\n        if (\n            condition.compValue.length != 32 &&\n            condition.compValue.length != 34 &&\n            condition.compValue.length != 54\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        if (condition.compValue.length > 32) {\n            if (\n                uint8(condition.compValue[32]) > 27 ||\n                uint8(condition.compValue[33]) > 27\n            ) {\n                revert IRolesError.AllowanceDecimalsExceedMax(index);\n            }\n        }\n    }\n\n    function _checkCallWithinAllowance(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 32 bytes\n        if (condition.compValue.length != 32) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: None\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount != 0) {\n            revert IRolesError.LeafNodeCannotHaveChildren(index);\n        }\n    }\n\n    function _validateVariantTypes(\n        ConditionFlat[] memory conditions\n    ) private pure {\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            bool isLogical = conditions[i].operator == Operator.And ||\n                conditions[i].operator == Operator.Or;\n            bool isArray = conditions[i].paramType == Encoding.Array;\n            /*\n             * Only Logical or Arrays hold variants\n             */\n            if (!isLogical && !isArray) continue;\n\n            (uint256 childStart, uint256 childCount) = Topology.childBounds(\n                conditions,\n                i\n            );\n\n            Layout memory a;\n            for (uint256 j = 0; j < childCount; ++j) {\n                Layout memory b = TypeTree.resolve(conditions, childStart + j);\n                if (TypeTree.hash(b) == 0) continue;\n\n                if (TypeTree.hash(a) == 0) a = b;\n\n                if (!_isTypeCompatible(a, b)) {\n                    revert IRolesError.UnsuitableChildTypeTree(i);\n                }\n            }\n        }\n    }\n\n    function _validatePluckZipTypes(\n        ConditionFlat[] memory conditions\n    ) private pure {\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            Operator op = conditions[i].operator;\n            if (op != Operator.ZipSome && op != Operator.ZipEvery) continue;\n\n            (uint256 childStart, ) = Topology.childBounds(conditions, i);\n\n            Layout memory tuple = TypeTree.resolve(conditions, childStart);\n\n            for (uint256 j = 0; j < tuple.children.length; ++j) {\n                (, uint256 pluckCondition) = _findPluckedArray(\n                    conditions,\n                    uint8(conditions[i].compValue[j])\n                );\n                Layout memory array = TypeTree.resolve(\n                    conditions,\n                    pluckCondition\n                );\n\n                Layout memory arrayEntry = array.children[0];\n                Layout memory tupleField = tuple.children[j];\n\n                if (!_isTypeCompatible(arrayEntry, tupleField)) {\n                    revert IRolesError.UnsuitableChildTypeTree(i);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Validates plucked variable definitions precede their usage.\n     *\n     * @dev Evaluation happens in DFS order, so this function must check that\n     *      definitions come before usages in DFS order.\n     *\n     *      While the flat `conditions` array is stored in BFS order (parents\n     *      first), this function traverses the tree in DFS order to track the\n     *      `visited` state of plucked variables. This ensures that a\n     *      `WithinRatio` check can only reference variables that have been\n     *      \"plucked\" by a preceding condition in the execution flow.\n     */\n    function _validatePluckOrder(\n        ConditionFlat[] memory conditions,\n        uint256 index,\n        uint256 visited\n    ) private pure returns (uint256) {\n        ConditionFlat memory condition = conditions[index];\n\n        if (condition.operator == Operator.Pluck) {\n            uint8 pluckIndex = uint8(condition.compValue[0]);\n            visited |= (1 << pluckIndex);\n        }\n\n        if (condition.operator == Operator.WithinRatio) {\n            uint8 referencePluckIndex = uint8(condition.compValue[0]);\n            if ((visited & (1 << referencePluckIndex)) == 0) {\n                revert IRolesError.PluckNotVisitedBeforeRef(\n                    index,\n                    referencePluckIndex\n                );\n            }\n\n            uint8 relativePluckIndex = uint8(condition.compValue[2]);\n            if ((visited & (1 << relativePluckIndex)) == 0) {\n                revert IRolesError.PluckNotVisitedBeforeRef(\n                    index,\n                    relativePluckIndex\n                );\n            }\n        }\n\n        if (\n            condition.operator == Operator.ZipSome ||\n            condition.operator == Operator.ZipEvery\n        ) {\n            for (uint256 k; k < condition.compValue.length; ++k) {\n                uint8 pluckIndex = uint8(condition.compValue[k]);\n                if ((visited & (1 << pluckIndex)) == 0) {\n                    revert IRolesError.PluckNotVisitedBeforeRef(\n                        index,\n                        pluckIndex\n                    );\n                }\n            }\n        }\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n\n        for (uint256 i = 0; i < childCount; ++i) {\n            visited = _validatePluckOrder(conditions, childStart + i, visited);\n        }\n\n        return visited;\n    }\n\n    function _validateNoPluckDescendant(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        if (conditions[index].operator == Operator.Pluck) {\n            revert IRolesError.UnsupportedOperator(index);\n        }\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n        for (uint256 i = 0; i < childCount; ++i) {\n            _validateNoPluckDescendant(conditions, childStart + i);\n        }\n    }\n\n    function _sChildBounds(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    )\n        private\n        pure\n        returns (uint256 childStart, uint256 childCount, uint256 sChildCount)\n    {\n        (childStart, childCount) = Topology.childBounds(conditions, index);\n        for (uint256 i; i < childCount; ++i) {\n            if (TypeTree.hash(conditions, childStart + i) != 0) {\n                ++sChildCount;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if two layouts are type-compatible: either exact type\n     *         hash match, or type equivalence (both resolve to Dynamic or\n     *         AbiEncoded).\n     */\n    function _isTypeCompatible(\n        Layout memory a,\n        Layout memory b\n    ) private pure returns (bool) {\n        bytes32 hashA = TypeTree.hash(a);\n        assert(hashA != 0);\n\n        bytes32 hashB = TypeTree.hash(b);\n        assert(hashB != 0);\n\n        if (hashA == hashB) {\n            return true;\n        }\n        return _isDynamicish(a) && _isDynamicish(b);\n    }\n\n    /**\n     * @notice Finds the conditions index of the Pluck condition with the given\n     *         pluck index.\n     */\n    function _findPluckedArray(\n        ConditionFlat[] memory conditions,\n        uint8 pluckIndex\n    ) private pure returns (bool found, uint256 conditionIndex) {\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            if (\n                conditions[i].operator == Operator.Pluck &&\n                uint8(conditions[i].compValue[0]) == pluckIndex\n            ) {\n                return (true, i);\n            }\n        }\n    }\n\n    function _isDynamicish(Layout memory layout) private pure returns (bool) {\n        /*\n         * None on a resolved type tree means a Variant placeholder. Such\n         * fields equate to Dynamic\n         */\n        return\n            layout.encoding == Encoding.Dynamic ||\n            layout.encoding == Encoding.AbiEncoded ||\n            layout.encoding == Encoding.None;\n    }\n}\n"
          },
          "contracts/core/serialize/Topology.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title  Topology\n * @notice Utilities for navigating flat condition tree structure.\n *\n * @author gnosisguild\n */\nlibrary Topology {\n    /**\n     * @notice Gets the bounds and counts of children for a given node\n     * @param conditions The flat array of conditions\n     * @param index The index of the parent node\n     *\n     * @return childStart The index of the first child (0 if no children)\n     * @return childCount The total number of children\n     */\n    function childBounds(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (uint256 childStart, uint256 childCount) {\n        uint256 len = conditions.length;\n\n        for (uint256 i = index + 1; i < len; ++i) {\n            uint256 parent = conditions[i].parent;\n\n            if (parent == index) {\n                if (childCount == 0) childStart = i;\n                ++childCount;\n            } else if (parent > index) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if a node is inlined (all descendants are static)\n     */\n    function isInlined(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (bool) {\n        Encoding encoding = conditions[index].paramType;\n        if (\n            encoding == Encoding.Dynamic ||\n            encoding == Encoding.Array ||\n            encoding == Encoding.AbiEncoded\n        ) {\n            return false;\n        }\n\n        (uint256 childStart, uint256 childCount) = childBounds(\n            conditions,\n            index\n        );\n        for (uint256 i; i < childCount; ++i) {\n            if (!isInlined(conditions, childStart + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Computes inlined size for a node (0 if not inlined)\n     */\n    function inlinedSize(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (uint256 size) {\n        assert(isInlined(conditions, index) == true);\n\n        /*\n         * Dynamic, Array, and AbiEncoded types are never inlined, so this\n         * function is guaranteed to only process Static, Tuple, or None types\n         * (enforced by the assertion above).\n         */\n        Encoding encoding = conditions[index].paramType;\n\n        if (encoding == Encoding.Static) {\n            return 32;\n        }\n\n        /*\n         * Remaining encodings:\n         * - Tuple: sum of all children sizes\n         * - None: delegates to first structural child\n         */\n        (uint256 childStart, uint256 childCount) = childBounds(\n            conditions,\n            index\n        );\n\n        for (uint256 i; i < childCount; ++i) {\n            uint256 childSize = inlinedSize(conditions, childStart + i);\n            /*\n             * None nodes are transparent wrappers (And/Or or non-structural).\n             * Since inlined nodes can't have variants, all structural children\n             * share the same size. Return on first non-zero (structural) child.\n             */\n            if (encoding == Encoding.None && childSize > 0) return childSize;\n            size += childSize;\n        }\n    }\n}\n"
          },
          "contracts/core/serialize/TypeTree.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../types/Types.sol\";\nimport \"./Topology.sol\";\n\n/**\n * @title  TypeTree\n * @notice Extracts type trees from flat conditions for use in decoding.\n *         Variants can appear in logical or array nodes and must be handled.\n *         See inline comments for rules\n *\n * @author gnosisguild\n */\nlibrary TypeTree {\n    /**\n     * @notice Resolves type tree for condition at an index\n     */\n    function resolve(\n        ConditionFlat[] memory conditions,\n        uint256 i\n    ) internal pure returns (Layout memory layout) {\n        bool isArray = conditions[i].paramType == Encoding.Array;\n        bool isLogical = conditions[i].operator == Operator.And ||\n            conditions[i].operator == Operator.Or;\n        bool isNonVariant = _isVariant(conditions, i) == false;\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            i\n        );\n\n        if (isLogical && isNonVariant) {\n            /*\n             * Non-variant logical nodes: first structural child defines the type tree\n             */\n            for (uint256 j; j < childCount; ++j) {\n                if (hash(conditions, childStart + j) != bytes32(0)) {\n                    return resolve(conditions, childStart + j);\n                }\n            }\n\n            /*\n             * No structural child was found.\n             */\n            Layout memory none;\n            return none;\n        }\n\n        layout.encoding = conditions[i].paramType == Encoding.EtherValue\n            ? Encoding.None\n            : conditions[i].paramType;\n\n        /*\n         * Extract leadingBytes for AbiEncoded from compValue, first 2 bytes\n         * Default is 4 (selector size) when compValue is empty\n         */\n        if (layout.encoding == Encoding.AbiEncoded) {\n            bytes memory compValue = conditions[i].compValue;\n            layout.leadingBytes = compValue.length >= 2\n                ? uint16(bytes2(compValue))\n                : 4;\n        }\n\n        layout.children = new Layout[](childCount);\n\n        uint256 length;\n        for (uint256 j; j < layout.children.length; ++j) {\n            if (hash(conditions, childStart + j) != bytes32(0)) {\n                layout.children[length++] = resolve(conditions, childStart + j);\n\n                /*\n                 * For non-variant arrays, the first child serves as a template for\n                 * all elements. For all other nodes, traverse all structural children\n                 */\n                if (isArray && isNonVariant) {\n                    break;\n                }\n            }\n        }\n        assembly {\n            // layout.children is at offset 0x20 (second field)\n            mstore(mload(add(layout, 0x20)), length)\n        }\n\n        layout.inlined = Topology.isInlined(conditions, i);\n    }\n\n    /**\n     * @notice Checks if a node is a variant (children have different type trees)\n     */\n    function _isVariant(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure returns (bool) {\n        Encoding encoding = conditions[index].paramType;\n        Operator operator = conditions[index].operator;\n        if (\n            encoding != Encoding.Array &&\n            operator != Operator.And &&\n            operator != Operator.Or\n        ) {\n            return false;\n        }\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n\n        bytes32 baseline;\n        for (uint256 i; i < childCount; ++i) {\n            bytes32 childHash = hash(conditions, childStart + i);\n\n            if (childHash == bytes32(0)) {\n                continue;\n            }\n\n            if (baseline == bytes32(0)) {\n                baseline = childHash;\n            }\n\n            if (baseline != childHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Computes a unique hash for a type tree structure\n     */\n    function hash(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (bytes32) {\n        return hash(resolve(conditions, index));\n    }\n\n    /**\n     * @notice Computes a unique hash for a Layout tree\n     */\n    function hash(Layout memory tree) internal pure returns (bytes32 result) {\n        Encoding encoding = tree.encoding == Encoding.EtherValue\n            ? Encoding.None\n            : tree.encoding;\n\n        if (tree.children.length == 0) {\n            return bytes32(uint256(encoding));\n        }\n\n        result = bytes32(uint256(encoding));\n        for (uint256 i; i < tree.children.length; ++i) {\n            bytes32 childHash = hash(tree.children[i]);\n            if (childHash != bytes32(0)) {\n                result = keccak256(abi.encodePacked(result, childHash));\n            }\n        }\n    }\n}\n"
          },
          "contracts/core/Settlement.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Storage.sol\";\n\nimport {Consumption} from \"../types/Allowance.sol\";\n\n/**\n * @title Settlement - Persists allowance consumption and membership updates to storage.\n *\n * @dev Called after successful execution. Reentrancy is prevented by the\n *      nonReentrant modifier in RolesStorage on execution entry points.\n *\n * @author gnosisguild\n */\nabstract contract Settlement is RolesStorage {\n    /**\n     * @dev Persists allowance consumption and membership updates after a successful execution.\n     *\n     * @param sender The address that initiated the transaction\n     * @param roleKey The role key used for execution\n     * @param nextMembership Packed membership data. uint256.max skips membership update\n     * @param consumptions Allowance consumption records to persist\n     */\n    function _persist(\n        address sender,\n        bytes32 roleKey,\n        uint256 nextMembership,\n        Consumption[] memory consumptions\n    ) internal {\n        uint256 count = consumptions.length;\n        for (uint256 i; i < count; ++i) {\n            Consumption memory consumption = consumptions[i];\n\n            assert(consumption.consumed <= consumption.balance);\n\n            uint128 updatedBalance = _persistConsumption(consumption);\n\n            emit ConsumeAllowance(\n                consumption.allowanceKey,\n                consumption.consumed,\n                updatedBalance\n            );\n        }\n\n        // uint256.max == noop\n        if (nextMembership == type(uint256).max) return;\n\n        roles[roleKey].members[sender] = nextMembership;\n        if (nextMembership != 0) {\n            emit UpdateRole(\n                roleKey,\n                sender,\n                uint64(nextMembership >> 192),\n                uint64(nextMembership >> 128),\n                uint128(nextMembership)\n            );\n        } else {\n            emit RevokeRole(roleKey, sender);\n        }\n    }\n\n    /// @dev Writes consumption to allowance storage, returns new balance.\n    function _persistConsumption(\n        Consumption memory consumption\n    ) private returns (uint128 updatedBalance) {\n        bytes32 allowanceKey = consumption.allowanceKey;\n        uint64 _timestamp = consumption.timestamp;\n        updatedBalance = consumption.balance - consumption.consumed;\n\n        /*\n         * Allowance Storage Layout (2 words):\n         * ┌────────────────────────────────┬────────────────────────────────┐\n         * │           maxRefill            │             refill             │\n         * │            128 bits            │            128 bits            │\n         * ├────────────────┬───────────────┴───────────────┬────────────────┤\n         * │   timestamp    │            balance            │     period     │\n         * │    64 bits     │           128 bits            │    64 bits     │\n         * └────────────────┴───────────────────────────────┴────────────────┘\n         */\n        assembly {\n            mstore(0x00, allowanceKey)\n            mstore(0x20, allowances.slot)\n\n            let slot := add(keccak256(0x00, 0x40), 1)\n\n            sstore(\n                slot,\n                or(\n                    or(shl(192, _timestamp), shl(64, updatedBalance)),\n                    and(sload(slot), 0xffffffffffffffff)\n                )\n            )\n        }\n    }\n}\n"
          },
          "contracts/core/Setup.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../common/AllowanceLoader.sol\";\nimport \"./serialize/ConditionStorer.sol\";\nimport \"./Storage.sol\";\n\nimport {Clearance} from \"../types/Permission.sol\";\n\n/*\n * Permission Model\n *\n * Role\n *  │\n *  ├─ members ───────────────────────► who can use this role\n *  │\n *  ├─ targets (address → Clearance)\n *  │   │\n *  │   ├─ Clearance.None ────────────► target blocked (default)\n *  │   │\n *  │   ├─ Clearance.Target ──────────► all functions allowed, subject to\n *  │   │                               ExecutionOptions and the target-level\n *  │   │                               scopeConfig entry (wildcard selector)\n *  │   │\n *  │   └─ Clearance.Function ────────► only specific functions allowed\n *  │                                   (see scopeConfig below)\n *  │\n *  └─ scopeConfig (target + selector → ScopeConfig)\n *      │\n *      │   Used for Clearance.Function (selector == calldata selector)\n *      │   and for Clearance.Target via the wildcard selector.\n *      │\n *      ├─ not set ───────────────────► blocked (target/function not allowed)\n *      │\n *      └─ set ───────────────────────► allowed with conditions\n *                                      + ExecutionOptions\n *                                      + Condition tree\n *\n * Allowances (separate storage, referenced by conditions)\n */\n\n/**\n * @title Setup - Configuration and setup functions for Zodiac Roles Mod.\n *\n * @author gnosisguild\n */\nabstract contract Setup is RolesStorage {\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    function setUp(\n        bytes memory initParams\n    ) public virtual override initializer {\n        (address _owner, address _avatar, address _target) = abi.decode(\n            initParams,\n            (address, address, address)\n        );\n        _transferOwnership(_owner);\n        avatar = _avatar;\n        target = _target;\n\n        setupModules();\n\n        emit RolesModSetup(msg.sender, _owner, _avatar, _target, VERSION);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           ROLE MEMBERSHIP\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Grants a role to a module with optional session parameters.\n    /// @param module Module to grant the role to.\n    /// @param roleKey Role to grant.\n    /// @param startTimestamp Start timestamp (0 = immediately valid).\n    /// @param endTimestamp End timestamp (0 = never expires).\n    /// @param usesLeft Number of uses (0 = unlimited).\n    function grantRole(\n        address module,\n        bytes32 roleKey,\n        uint64 startTimestamp,\n        uint64 endTimestamp,\n        uint128 usesLeft\n    ) public onlyOwner {\n        endTimestamp = endTimestamp != 0 ? endTimestamp : type(uint64).max;\n        usesLeft = usesLeft != 0 ? usesLeft : type(uint128).max;\n        roles[roleKey].members[module] =\n            (uint256(startTimestamp) << 192) |\n            (uint256(endTimestamp) << 128) |\n            uint256(usesLeft);\n        if (!isModuleEnabled(module)) {\n            enableModule(module);\n        }\n        emit GrantRole(roleKey, module, startTimestamp, endTimestamp, usesLeft);\n    }\n\n    /// @dev Revokes a role from a module.\n    /// @param module Module to revoke the role from.\n    /// @param roleKey Role to revoke.\n    function revokeRole(address module, bytes32 roleKey) public onlyOwner {\n        delete roles[roleKey].members[module];\n        emit RevokeRole(roleKey, module);\n    }\n\n    /// @dev Allows a module to renounce its own role.\n    /// @param roleKey Role to renounce.\n    function renounceRole(bytes32 roleKey) external {\n        delete roles[roleKey].members[msg.sender];\n        emit RevokeRole(roleKey, msg.sender);\n    }\n\n    /// @dev Batch assigns roles to a module.\n    /// @param module Module to assign roles to.\n    /// @param roleKeys Roles to assign.\n    /// @param memberOf true to grant, false to revoke.\n    function assignRoles(\n        address module,\n        bytes32[] calldata roleKeys,\n        bool[] calldata memberOf\n    ) external onlyOwner {\n        for (uint256 i; i < roleKeys.length; ++i) {\n            bytes32 key = roleKeys[i];\n            if (memberOf[i]) {\n                grantRole(module, key, 0, 0, 0);\n            } else {\n                revokeRole(module, key);\n            }\n        }\n    }\n\n    /// @dev Sets the default role used for a module if it calls\n    ///      execTransactionFromModule() or execTransactionFromModuleReturnData().\n    /// @param module Address of the module on which to set default role.\n    /// @param roleKey Role to be set as default.\n    function setDefaultRole(\n        address module,\n        bytes32 roleKey\n    ) external onlyOwner {\n        defaultRoles[module] = roleKey;\n        emit SetDefaultRole(module, roleKey);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         TARGET PERMISSIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Allows transactions to a target address, optionally with conditions.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param packedConditions Pre-packed condition buffer (use packConditions() or empty bytes for pass-through).\n    /// @param options designates if a transaction can send ether and/or delegatecall to target.\n    function allowTarget(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes memory packedConditions,\n        ExecutionOptions options\n    ) external onlyOwner {\n        bytes32 key = bytes32(bytes20(targetAddress)) | (~bytes32(0) >> 160);\n\n        roles[roleKey].clearance[targetAddress] = Clearance.Target;\n        roles[roleKey].scopeConfig[key] = ConditionStorer.store(\n            _conditionsOrPass(packedConditions),\n            options\n        );\n\n        emit AllowTarget(roleKey, targetAddress, packedConditions, options);\n    }\n\n    /// @dev Designates only specific functions can be called.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    function scopeTarget(\n        bytes32 roleKey,\n        address targetAddress\n    ) external onlyOwner {\n        roles[roleKey].clearance[targetAddress] = Clearance.Function;\n        emit ScopeTarget(roleKey, targetAddress);\n    }\n\n    /// @dev Removes transactions to a target address.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    function revokeTarget(\n        bytes32 roleKey,\n        address targetAddress\n    ) external onlyOwner {\n        delete roles[roleKey].clearance[targetAddress];\n        emit RevokeTarget(roleKey, targetAddress);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FUNCTION PERMISSIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Specifies the functions that can be called, optionally with conditions.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param selector 4 byte function selector.\n    /// @param packedConditions Pre-packed condition buffer (use packConditions() or empty bytes for pass-through).\n    /// @param options designates if a transaction can send ether and/or delegatecall to target.\n    function allowFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        bytes memory packedConditions,\n        ExecutionOptions options\n    ) external onlyOwner {\n        bytes32 key = _key(targetAddress, selector);\n\n        roles[roleKey].scopeConfig[key] = ConditionStorer.store(\n            _conditionsOrPass(packedConditions),\n            options\n        );\n\n        emit AllowFunction(\n            roleKey,\n            targetAddress,\n            selector,\n            packedConditions,\n            options\n        );\n    }\n\n    /// @dev Removes the functions that can be called.\n    /// @param roleKey identifier of the role to be modified.\n    /// @param targetAddress Destination address of transaction.\n    /// @param selector 4 byte function selector.\n    function revokeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector\n    ) external onlyOwner {\n        delete roles[roleKey].scopeConfig[_key(targetAddress, selector)];\n        emit RevokeFunction(roleKey, targetAddress, selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ALLOWANCES\n    //////////////////////////////////////////////////////////////*/\n\n    function setAllowance(\n        bytes32 key,\n        uint128 balance,\n        uint128 maxRefill,\n        uint128 refill,\n        uint64 period,\n        uint64 timestamp\n    ) external onlyOwner {\n        maxRefill = maxRefill != 0 ? maxRefill : type(uint128).max;\n        timestamp = timestamp != 0 ? timestamp : uint64(block.timestamp);\n\n        allowances[key] = Allowance({\n            refill: refill,\n            maxRefill: maxRefill,\n            period: period,\n            timestamp: timestamp,\n            balance: balance\n        });\n        emit SetAllowance(key, balance, maxRefill, refill, period, timestamp);\n    }\n\n    /// @dev Updates only the refill parameters of an existing allowance, preserving balance and timestamp.\n    /// @param key The allowance key.\n    /// @param maxRefill Cap at which refilling stops. Pass 0 to set to max uint128.\n    /// @param refill Amount added to balance each period.\n    /// @param period Refill interval in seconds.\n    function updateAllowance(\n        bytes32 key,\n        uint128 maxRefill,\n        uint128 refill,\n        uint64 period\n    ) external onlyOwner {\n        maxRefill = maxRefill != 0 ? maxRefill : type(uint128).max;\n        uint64 timestamp = allowances[key].timestamp;\n        uint128 balance = allowances[key].balance;\n\n        allowances[key].refill = refill;\n        allowances[key].maxRefill = maxRefill;\n        allowances[key].period = period;\n\n        emit SetAllowance(key, balance, maxRefill, refill, period, timestamp);\n    }\n\n    /// @dev Returns the accrued allowance balance at current block.timestamp.\n    /// @param allowanceKey The allowance key.\n    /// @return balance The accrued balance.\n    /// @return timestamp The timestamp of the last accrual point.\n    function accruedAllowance(\n        bytes32 allowanceKey\n    ) external view returns (uint128 balance, uint64 timestamp) {\n        return AllowanceLoader.accrue(allowanceKey, uint64(block.timestamp));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ADAPTERS\n    //////////////////////////////////////////////////////////////*/\n\n    function setTransactionUnwrapper(\n        address to,\n        bytes4 selector,\n        address adapter\n    ) external onlyOwner {\n        unwrappers[bytes32(bytes20(to)) | (bytes32(selector) >> 160)] = adapter;\n        emit SetUnwrapAdapter(to, selector, adapter);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Packs conditions into a buffer for allowTarget/allowFunction.\n    /// @param conditions The conditions to pack.\n    /// @return buffer The packed condition buffer.\n    function packConditions(\n        ConditionFlat[] memory conditions\n    ) external pure returns (bytes memory buffer) {\n        if (conditions.length > 0) {\n            buffer = ConditionStorer.pack(conditions);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev If buffer is empty, returns packed single Pass condition;\n    ///      otherwise returns the buffer unchanged.\n    function _conditionsOrPass(\n        bytes memory buffer\n    ) private pure returns (bytes memory) {\n        if (buffer.length == 0) {\n            return ConditionStorer.pack(new ConditionFlat[](1));\n        }\n        return buffer;\n    }\n}\n"
          },
          "contracts/core/Storage.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Modifier.sol\";\n\nimport \"../types/Types.sol\";\n\n/**\n * @title RolesStorage\n * @notice Base contract defining shared storage for Zodiac Roles Mod\n *\n * @author gnosisguild\n *\n */\nabstract contract RolesStorage is Modifier, IRolesEvent, IRolesError {\n    string public constant VERSION = \"3.0.0\";\n\n    mapping(bytes32 => Role) internal roles;\n    mapping(bytes32 => Allowance) public allowances;\n    mapping(bytes32 => address) public unwrappers;\n    mapping(address => bytes32) public defaultRoles;\n\n    bool private transient _reentrancyGuard;\n\n    modifier nonReentrant() {\n        if (_reentrancyGuard) {\n            revert Reentrancy();\n        }\n        _reentrancyGuard = true;\n        _;\n        _reentrancyGuard = false;\n    }\n\n    function _key(\n        address targetAddress,\n        bytes4 selector\n    ) internal pure returns (bytes32) {\n        return bytes32(bytes20(targetAddress)) | (bytes32(selector) >> 160);\n    }\n}\n"
          },
          "contracts/periphery/interfaces/ICustomCondition.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Operation.sol\";\n\ninterface ICustomCondition {\n    function check(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 location,\n        uint256 size,\n        bytes calldata extra,\n        bytes32[] memory pluckedValues\n    ) external view returns (bool success);\n}\n"
          },
          "contracts/periphery/interfaces/IPricing.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\n/**\n * @notice Interface for pricing contracts\n * @dev Returns a price with 18 decimals precision\n */\ninterface IPricing {\n    function getPrice() external view returns (uint256 price);\n}\n"
          },
          "contracts/periphery/interfaces/ITransactionUnwrapper.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Operation.sol\";\n\nstruct UnwrappedTransaction {\n    Operation operation;\n    address to;\n    uint256 value;\n    // We wanna deal in calldata slices. We return location, let invoker slice\n    uint256 dataLocation;\n    uint256 dataSize;\n}\n\ninterface ITransactionUnwrapper {\n    function unwrap(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) external view returns (UnwrappedTransaction[] memory result);\n}\n"
          },
          "contracts/Roles.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./core/Authorization.sol\";\nimport \"./core/Membership.sol\";\nimport \"./core/Settlement.sol\";\nimport \"./core/Setup.sol\";\n\n/**\n * @title Zodiac Roles Mod - granular, role-based access control and policy\n *        engine for onchain accounts\n *\n * @author gnosisguild\n *\n */\ncontract Roles is RolesStorage, Setup, Membership, Authorization, Settlement {\n    /// @param _owner Address of the owner\n    /// @param _avatar Address of the avatar (e.g. a Gnosis Safe)\n    /// @param _target Address of the contract that will call exec function\n    constructor(address _owner, address _avatar, address _target) {\n        bytes memory initParams = abi.encode(_owner, _avatar, _target);\n        setUp(initParams);\n    }\n\n    /// @dev Passes a transaction to the modifier using the caller's default role.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @notice Can only be called by enabled modules\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) public override returns (bool success) {\n        return\n            execTransactionWithRole(\n                to,\n                value,\n                data,\n                operation,\n                defaultRoles[sentOrSignedByModule()],\n                false\n            );\n    }\n\n    /// @dev Passes a transaction to the modifier using the caller's default role. Expects return data.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @notice Can only be called by enabled modules\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) public override returns (bool success, bytes memory returnData) {\n        return\n            execTransactionWithRoleReturnData(\n                to,\n                value,\n                data,\n                operation,\n                defaultRoles[sentOrSignedByModule()],\n                false\n            );\n    }\n\n    /// @dev Passes a transaction to the modifier assuming the specified role.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @param roleKey Identifier of the role to assume for this transaction\n    /// @param shouldRevert Should the function revert on inner execution returning success false?\n    /// @notice Can only be called by enabled modules\n    function execTransactionWithRole(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        bytes32 roleKey,\n        bool shouldRevert\n    ) public nonReentrant returns (bool success) {\n        (address module, uint256 nextMembership) = _authenticate(roleKey);\n        Consumption[] memory consumptions = _authorize(\n            roleKey,\n            to,\n            value,\n            data,\n            operation\n        );\n        success = IAvatar(target).execTransactionFromModule(\n            to,\n            value,\n            data,\n            operation\n        );\n        if (shouldRevert && !success) {\n            revert ModuleTransactionFailed();\n        }\n        if (success) {\n            _persist(module, roleKey, nextMembership, consumptions);\n        }\n    }\n\n    /// @dev Passes a transaction to the modifier assuming the specified role. Expects return data.\n    /// @param to Destination address of module transaction\n    /// @param value Ether value of module transaction\n    /// @param data Data payload of module transaction\n    /// @param operation Operation type of module transaction\n    /// @param roleKey Identifier of the role to assume for this transaction\n    /// @param shouldRevert Should the function revert on inner execution returning success false?\n    /// @notice Can only be called by enabled modules\n    function execTransactionWithRoleReturnData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        bytes32 roleKey,\n        bool shouldRevert\n    ) public nonReentrant returns (bool success, bytes memory returnData) {\n        (address module, uint256 nextMembership) = _authenticate(roleKey);\n        Consumption[] memory consumptions = _authorize(\n            roleKey,\n            to,\n            value,\n            data,\n            operation\n        );\n        (success, returnData) = IAvatar(target)\n            .execTransactionFromModuleReturnData(to, value, data, operation);\n        if (shouldRevert && !success) {\n            revert ModuleTransactionFailed();\n        }\n        if (success) {\n            _persist(module, roleKey, nextMembership, consumptions);\n        }\n    }\n}\n"
          },
          "contracts/types/Allowance.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\n/**\n * @notice Represents an allowance with periodic refilling capability.\n *\n * @dev The struct layout is storage-optimized: fields updated together during\n * accrual (`balance` and `timestamp`) share word2, minimizing SSTORE\n *\n * Storage Layout (2 words, 64 bytes, 512 bits):\n * ┌────────────────────────────────┬────────────────────────────────┐\n * │           maxRefill            │             refill             │\n * │            128 bits            │            128 bits            │\n * ├────────────────┬───────────────┴───────────────┬────────────────┤\n * │   timestamp    │            balance            │     period     │\n * │    64 bits     │           128 bits            │    64 bits     │\n * └────────────────┴───────────────────────────────┴────────────────┘\n *\n * @custom:member refill Amount added to balance each period.\n * @custom:member maxRefill Cap at which refilling stops.\n * @custom:member period Refill interval in seconds. Zero means one-time use.\n * @custom:member balance Current available allowance.\n * @custom:member timestamp Last refill time.\n */\nstruct Allowance {\n    uint128 refill;\n    uint128 maxRefill;\n    uint64 period;\n    uint128 balance;\n    uint64 timestamp;\n}\n\nstruct Consumption {\n    bytes32 allowanceKey;\n    uint128 balance;\n    uint128 consumed;\n    uint64 timestamp;\n}\n"
          },
          "contracts/types/Authorization.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Operation.sol\";\n\nimport {Consumption} from \"./Allowance.sol\";\n\nenum Status {\n    Ok,\n    /// Or conition not met\n    OrViolation,\n    /// Parameter value is not equal to allowed\n    ParameterNotAllowed,\n    /// Parameter value less than allowed\n    ParameterLessThanAllowed,\n    /// Parameter value greater than maximum allowed by role\n    ParameterGreaterThanAllowed,\n    /// Parameter value does not match\n    ParameterNotAMatch,\n    /// Array elements do not meet allowed criteria for every element\n    NotEveryArrayElementPasses,\n    /// Array elements do not meet allowed criteria for at least one element\n    NoArrayElementPasses,\n    /// Bitmask exceeded value length\n    BitmaskOverflow,\n    /// Bitmask not an allowed value\n    BitmaskNotAllowed,\n    CustomConditionViolation,\n    CustomConditionNotAContract,\n    CustomConditionReverted,\n    CustomConditionInvalidResult,\n    PricingAdapterNotAContract,\n    PricingAdapterReverted,\n    PricingAdapterInvalidResult,\n    PricingAdapterZeroPrice,\n    AllowanceExceeded,\n    /// Converted allowance value exceeds uint128 max\n    AllowanceValueOverflow,\n    CalldataOverflow,\n    RatioBelowMin,\n    RatioAboveMax,\n    /// Calldata is not empty when it should be\n    CalldataNotEmpty,\n    /// Leading bytes do not match expected value\n    LeadingBytesNotAMatch,\n    /// Zipped arrays have different lengths\n    ZippedArrayLengthMismatch,\n    /// No zipped element pair passes\n    NoZippedElementPasses,\n    /// Not every zipped element pair passes\n    NotEveryZippedElementPasses\n}\n\nstruct Transaction {\n    address to;\n    uint256 value;\n    Operation operation;\n}\n\nstruct Context {\n    address to;\n    uint256 value;\n    Operation operation;\n    bytes32[] pluckedValues;\n    uint256[] pluckedLocations;\n}\n\nstruct Result {\n    Status status;\n    uint256 violatedNodeIndex;\n    uint256 payloadLocation;\n    Consumption[] consumptions;\n}\n"
          },
          "contracts/types/Condition.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Operator} from \"./Operator.sol\";\n\nenum Encoding {\n    None,\n    Static,\n    Dynamic,\n    Tuple,\n    Array,\n    AbiEncoded,\n    /* EtherValue is a nonstructural, and an alias for None */\n    EtherValue\n}\n\nstruct Condition {\n    /// @dev BFS index from unpacking - identifies this node in the flattened tree\n    uint256 index;\n    Encoding encoding;\n    Operator operator;\n    bytes compValue;\n    Condition[] children;\n    /* meta fields */\n    bool inlined;\n    uint256 size;\n    uint256 leadingBytes;\n}\n\n// This struct is a flattened version of Condition\n// used for ABI encoding a scope config tree\n// (ABI does not support recursive types)\nstruct ConditionFlat {\n    uint16 parent;\n    Encoding paramType;\n    Operator operator;\n    bytes compValue;\n}\n\n/// @dev Layout is a type tree used for AbiDecoder and EIP712 encoding.\nstruct Layout {\n    Encoding encoding;\n    Layout[] children;\n    uint256 leadingBytes;\n    bool inlined;\n}\n\nstruct LayoutFlat {\n    uint256 parent;\n    Encoding encoding;\n}\n\n/// @dev Payload is the result of AbiDecoder.inspect() - maps parameter locations.\nstruct Payload {\n    uint256 location;\n    uint256 size;\n    Payload[] children;\n    /* meta flags */\n    bool inlined;\n    bool variant;\n    bool overflow;\n}\n"
          },
          "contracts/types/Operator.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nenum Operator {\n    // 00:    EMPTY EXPRESSION (default, always passes)\n    //          paramType: Static / Dynamic / Tuple / Array / EtherValue\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          🚫 compValue\n    /* 00: */ Pass,\n    // ------------------------------------------------------------\n    // 01-03: LOGICAL EXPRESSIONS\n    //          paramType: None\n    //          ✅ children\n    //          🚫 compValue\n    /* 01: */ And,\n    /* 02: */ Or,\n    /* 03: */ _Placeholder03,\n    // ------------------------------------------------------------\n    // 04:    EMPTY CHECK (passes if data.length == 0)\n    //          paramType: None\n    //          🚫 children\n    //          🚫 compValue\n    /* 04: */ Empty,\n    // ------------------------------------------------------------\n    // 05-12: COMPLEX EXPRESSIONS\n    //          paramType: AbiEncoded / Tuple / Array,\n    //          ✅ children\n    //          🚫 compValue (exception AbiEncoded.Matches uses compValue to define leading bytes)\n    /* 05: */ Matches,\n    /* 06: */ ArraySome,\n    /* 07: */ ArrayEvery,\n    /* 08: */ ArrayTailMatches,\n    /* 09: */ _Placeholder09,\n    /* 10: */ ZipSome, // paramType: None, compValue: at least 2 bytes, one per plucked array\n    /* 11: */ ZipEvery, // paramType: None, compValue: at least 2 bytes, one per plucked array\n    /* 12: */ _Placeholder12,\n    // ------------------------------------------------------------\n    // 13-14: EXTRACTION EXPRESSIONS\n    //          ❓ children (at most one child, must resolve to Static)\n    //          ✅ compValue\n    /* 13: */ Slice, // paramType: Static / Dynamic, compValue: 3 bytes (2 bytes shift + 1 byte size, 1-32)\n    /* 14: */ Pluck, // paramType: Static / EtherValue / Array, compValue: 1 byte (index into pluckedValues, 0-255)\n    // ------------------------------------------------------------\n    // 15:    SPECIAL COMPARISON (without compValue)\n    //          paramType: Static\n    //          🚫 children\n    //          🚫 compValue\n    /* 15: */ EqualToAvatar,\n    // ------------------------------------------------------------\n    // 16-31: COMPARISON EXPRESSIONS\n    //          paramType: Static / Dynamic / Tuple / Array / EtherValue\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          ✅ compValue\n    /* 16: */ EqualTo, // paramType: Static / Dynamic / Tuple / Array / EtherValue\n    /* 17: */ GreaterThan, // paramType: Static / EtherValue\n    /* 18: */ LessThan, // paramType: Static / EtherValue\n    /* 19: */ SignedIntGreaterThan, // paramType: Static / EtherValue\n    /* 20: */ SignedIntLessThan, // paramType: Static / EtherValue\n    /* 21: */ Bitmask, // paramType: Static / Dynamic\n    /* 22: */ Custom, // paramType: Static / Dynamic / Tuple / Array / EtherValue\n    /* 23: */ WithinRatio, // paramType: None\n    /* 24: */ _Placeholder24,\n    /* 25: */ _Placeholder25,\n    /* 26: */ _Placeholder26,\n    /* 27: */ _Placeholder27,\n    /* 28: */ WithinAllowance, // paramType: Static / EtherValue\n    /* 29: */ _Placeholder29,\n    /* 30: */ CallWithinAllowance, // paramType: None\n    /* 31: */ _Placeholder31\n}\n"
          },
          "contracts/types/Permission.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nenum Clearance {\n    None,\n    Target,\n    Function\n}\n\nenum ExecutionOptions {\n    None,\n    Send,\n    DelegateCall,\n    Both\n}\n\nstruct Role {\n    mapping(address => uint256) members;\n    mapping(address => Clearance) clearance;\n    mapping(bytes32 => uint256) scopeConfig;\n}\n"
          },
          "contracts/types/RolesError.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Status} from \"./Authorization.sol\";\n\n/**\n * @title IRolesError - All custom errors emitted by the Roles Mod\n *\n * @author gnosisguild\n */\ninterface IRolesError {\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTION ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Sender is allowed to make this call, but the internal transaction failed\n    error ModuleTransactionFailed();\n\n    /// Reentrant call detected\n    error Reentrancy();\n\n    /*//////////////////////////////////////////////////////////////\n                          AUTHORIZATION ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Sender is not a member of the role\n    error NoMembership();\n\n    /// Membership is not yet valid (before start timestamp)\n    error MembershipNotYetValid();\n\n    /// Membership has expired (after end timestamp)\n    error MembershipExpired();\n\n    /// Function signature too short\n    error FunctionSignatureTooShort();\n\n    /// Calldata unwrapping failed\n    error MalformedMultiEntrypoint();\n\n    /// Authorization check failed with violation information\n    error ConditionViolation(\n        Status status,\n        uint256 violatedNodeIndex,\n        uint256 location\n    );\n\n    /// Target address is not allowed for this role\n    error TargetAddressNotAllowed(address target);\n\n    /// Function selector is not allowed for this role on the target\n    error FunctionNotAllowed(address target, bytes4 selector);\n\n    /// Sending value is not allowed\n    error SendNotAllowed(address target);\n\n    /// Delegate call is not allowed\n    error DelegateCallNotAllowed(address target);\n\n    /*//////////////////////////////////////////////////////////////\n                            DECODING ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Attempted to read beyond calldata bounds\n    error CalldataOutOfBounds();\n\n    /*//////////////////////////////////////////////////////////////\n                           INTEGRITY ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Root node is invalid or missing\n    error UnsuitableRootNode();\n\n    /// Condition tree is not in BFS (breadth-first search) order\n    error NotBFS();\n\n    /// Parameter type is unsuitable for the operator at given index\n    error UnsuitableParameterType(uint256 index);\n\n    /// Comparison value is unsuitable for the operator at given index\n    error UnsuitableCompValue(uint256 index);\n\n    /// Operator is not supported at given index\n    error UnsupportedOperator(uint256 index);\n\n    /// Parent node is unsuitable for the child at given index\n    error UnsuitableParent(uint256 index);\n\n    /// Child count is unsuitable for the node at given index\n    error UnsuitableChildCount(uint256 index);\n\n    /// Leaf node cannot have children at given index\n    error LeafNodeCannotHaveChildren(uint256 index);\n\n    /// Child type tree is unsuitable for the node at given index\n    error UnsuitableChildTypeTree(uint256 index);\n\n    /// WithinRatio target must resolve to a Static type\n    error WithinRatioTargetNotStatic(uint256 index);\n\n    /// WithinRatio requires at least one ratio (min or max) to be provided\n    error WithinRatioNoRatioProvided(uint256 index);\n\n    /// Allowance decimals exceed maximum of 18\n    error AllowanceDecimalsExceedMax(uint256 index);\n\n    /// Slice child must resolve to Static type\n    error SliceChildNotStatic(uint256 index);\n\n    /// WithinRatio references a Pluck index that hasn't been visited yet in DFS order\n    error PluckNotVisitedBeforeRef(uint256 index, uint8 pluckIndex);\n}\n"
          },
          "contracts/types/RolesEvent.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ExecutionOptions} from \"./Permission.sol\";\n\n/**\n * @title IRolesEvent - All events emitted by the Roles Mod.\n *\n * @author gnosisguild\n */\ninterface IRolesEvent {\n    /*//////////////////////////////////////////////////////////////\n                             SETUP EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Emitted when the Roles Mod is initialized\n    event RolesModSetup(\n        address indexed initiator,\n        address indexed owner,\n        address indexed avatar,\n        address target,\n        string version\n    );\n\n    /// Emitted when a role is granted to a module\n    event GrantRole(\n        bytes32 roleKey,\n        address module,\n        uint64 start,\n        uint64 end,\n        uint128 usesLeft\n    );\n\n    /// Emitted when a role is revoked from a module\n    event RevokeRole(bytes32 roleKey, address module);\n\n    /// Emitted when role membership is updated (e.g., uses consumed)\n    event UpdateRole(\n        bytes32 roleKey,\n        address module,\n        uint64 start,\n        uint64 end,\n        uint128 usesLeft\n    );\n\n    /// Emitted when the default role is set for a module\n    event SetDefaultRole(address module, bytes32 defaultRoleKey);\n\n    /*//////////////////////////////////////////////////////////////\n                           PERMISSION EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Emitted when a target address is allowed for a role\n    event AllowTarget(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes conditions,\n        ExecutionOptions options\n    );\n\n    /// Emitted when a target address is revoked from a role\n    event RevokeTarget(bytes32 roleKey, address targetAddress);\n\n    /// Emitted when a target is scoped (function-level permissions enabled)\n    event ScopeTarget(bytes32 roleKey, address targetAddress);\n\n    /// Emitted when a function is allowed for a role\n    event AllowFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        bytes conditions,\n        ExecutionOptions options\n    );\n\n    /// Emitted when a function is revoked from a role\n    event RevokeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector\n    );\n\n    /// Emitted when an allowance is configured\n    event SetAllowance(\n        bytes32 allowanceKey,\n        uint128 balance,\n        uint128 maxRefill,\n        uint128 refill,\n        uint64 period,\n        uint64 timestamp\n    );\n\n    /// Emitted when a transaction unwrap adapter is set\n    event SetUnwrapAdapter(address to, bytes4 selector, address adapter);\n\n    /*//////////////////////////////////////////////////////////////\n                           ALLOWANCE EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Emitted when an allowance is consumed during execution\n    event ConsumeAllowance(\n        bytes32 allowanceKey,\n        uint128 consumed,\n        uint128 newBalance\n    );\n}\n"
          },
          "contracts/types/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Allowance.sol\";\nimport \"./Authorization.sol\";\nimport \"./Condition.sol\";\nimport \"./Operator.sol\";\nimport \"./Permission.sol\";\nimport \"./RolesError.sol\";\nimport \"./RolesEvent.sol\";\n"
          }
        },
        "settings": {
          "evmVersion": "cancun",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata"
              ],
              "": [
                "ast"
              ]
            }
          },
          "libraries": {
            "contracts/core/serialize/ConditionStorer.sol": {
              "ConditionStorer": "0x77172cAA8409e651a74627013B77cEDB00E53D5C"
            }
          }
        }
      }
    }
  },
  "MultiSendUnwrapper": {
    "2.1.0": {
      "contractName": "MultiSendUnwrapper",
      "sourceName": "contracts/adapters/MultiSendUnwrapper.sol",
      "contractVersion": "2.1.0",
      "compilerVersion": "v0.8.21+commit.d9974bed",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x93B7fCbc63ED8a3a24B59e1C3e6649D50B7427c0",
      "bytecode": "0x608060405234801561000f575f80fd5b506108178061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063c7a7b6351461002d575b5f80fd5b61004061003b366004610511565b610056565b60405161004d91906105c8565b60405180910390f35b606084156100775760405163ad6e405560e01b815260040160405180910390fd5b600182600181111561008b5761008b6105b4565b146100a95760405163ad6e405560e01b815260040160405180910390fd5b6100b384846100d6565b5f6100be85856101a1565b90506100cb85858361029d565b979650505050505050565b6346c07f8560e11b6100e8828461065c565b6001600160e01b0319161461011057604051631a751fb760e11b815260040160405180910390fd5b602061011f826004818661068c565b610128916106b3565b1461014657604051631a751fb760e11b815260040160405180910390fd5b5f610154826024818661068c565b61015d916106b3565b90508161017361016e8360406106e4565b6104ca565b61017e9060046106e4565b1461019c57604051631a751fb760e11b815260040160405180910390fd5b505050565b5f60445b826101b18260206106e4565b1015610277575f6101c48483818861068c565b6101cd916106f7565b60f81c905060018111156101f357604051629ec3f960e31b815260040160405180910390fd5b5f85856102018560356106e4565b61020c92829061068c565b610215916106b3565b905084816102248560556106e4565b61022e91906106e4565b111561024c57604051629ec3f960e31b815260040160405180910390fd5b6102578160556106e4565b61026190846106e4565b92508361026d81610725565b94505050506101a5565b815f0361029657604051629ec3f960e31b815260040160405180910390fd5b5092915050565b60608167ffffffffffffffff8111156102b8576102b861073d565b60405190808252806020026020018201604052801561032057816020015b61030d6040805160a08101909152805f81526020015f6001600160a01b031681526020015f81526020015f81526020015f81525090565b8152602001906001900390816102d65790505b50905060445f5b838110156104c15761033b8583818961068c565b610344916106f7565b60f81c6001811115610358576103586105b4565b83828151811061036a5761036a610751565b60200260200101515f01906001811115610386576103866105b4565b90816001811115610399576103996105b4565b9052506103a76001836106e4565b91506103b58583818961068c565b6103be91610765565b60601c8382815181106103d3576103d3610751565b6020908102919091018101516001600160a01b039092169101526103f86014836106e4565b91506104068583818961068c565b61040f916106b3565b5f1c83828151811061042357610423610751565b6020026020010151604001818152505060208261044091906106e4565b91505f61044f8684818a61068c565b610458916106b3565b90506104656020846106e4565b92508284838151811061047a5761047a610751565b602002602001015160600181815250508084838151811061049d5761049d610751565b6020908102919091010151608001526104b681846106e4565b925050600101610327565b50509392505050565b5f602060016104d984836106e4565b6104e39190610798565b6104ed91906107ab565b6104f89060206107ca565b92915050565b80356002811061050c575f80fd5b919050565b5f805f805f60808688031215610525575f80fd5b85356001600160a01b038116811461053b575f80fd5b945060208601359350604086013567ffffffffffffffff8082111561055e575f80fd5b818801915088601f830112610571575f80fd5b81358181111561057f575f80fd5b896020828501011115610590575f80fd5b6020830195508094505050506105a8606087016104fe565b90509295509295909350565b634e487b7160e01b5f52602160045260245ffd5b602080825282518282018190525f91906040908185019086840185805b8381101561064e57825180516002811061060d57634e487b7160e01b84526021600452602484fd5b8652808801516001600160a01b0316888701528681015187870152606080820151908701526080908101519086015260a090940193918601916001016105e5565b509298975050505050505050565b6001600160e01b031981358181169160048510156106845780818660040360031b1b83161692505b505092915050565b5f808585111561069a575f80fd5b838611156106a6575f80fd5b5050820193919092039150565b803560208310156104f8575f19602084900360031b1b1692915050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156104f8576104f86106d0565b6001600160f81b031981358181169160018510156106845760019490940360031b84901b1690921692915050565b5f60018201610736576107366106d0565b5060010190565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b6bffffffffffffffffffffffff1981358181169160148510156106845760149490940360031b84901b1690921692915050565b818103818111156104f8576104f86106d0565b5f826107c557634e487b7160e01b5f52601260045260245ffd5b500490565b80820281158282048414176104f8576104f86106d056fea2646970667358221220fdbe66738b4a25a36e5fbd476d551f3c9657dd12c046459067c1471f52efa0f764736f6c63430008150033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [],
          "name": "MalformedBody",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "MalformedHeader",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "UnsupportedMode",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Enum.Operation",
              "name": "operation",
              "type": "uint8"
            }
          ],
          "name": "unwrap",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "enum Enum.Operation",
                  "name": "operation",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "to",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "value",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "dataLocation",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "dataSize",
                  "type": "uint256"
                }
              ],
              "internalType": "struct UnwrappedTransaction[]",
              "name": "",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
          },
          "contracts/adapters/MultiSendUnwrapper.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Types.sol\";\n\ncontract MultiSendUnwrapper is ITransactionUnwrapper {\n    uint256 private constant OFFSET_START = 68;\n\n    error UnsupportedMode();\n    error MalformedHeader();\n    error MalformedBody();\n\n    function unwrap(\n        address,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external pure returns (UnwrappedTransaction[] memory) {\n        if (value != 0) {\n            revert UnsupportedMode();\n        }\n        if (operation != Enum.Operation.DelegateCall) {\n            revert UnsupportedMode();\n        }\n        _validateHeader(data);\n        uint256 count = _validateEntries(data);\n        return _unwrapEntries(data, count);\n    }\n\n    function _validateHeader(bytes calldata data) private pure {\n        // first 4 bytes are the selector for multiSend(bytes)\n        if (bytes4(data) != IMultiSend.multiSend.selector) {\n            revert MalformedHeader();\n        }\n\n        // the following 32 bytes are the offset to the bytes param\n        // (always 0x20)\n        if (bytes32(data[4:]) != bytes32(uint256(0x20))) {\n            revert MalformedHeader();\n        }\n\n        // the following 32 bytes are the length of the bytes param\n        uint256 length = uint256(bytes32(data[36:]));\n\n        // validate that the total calldata length matches\n        // it's the 4 + 32 + 32 bytes checked above + the <length> bytes\n        // padded to a multiple of 32\n        if (4 + _ceil32(32 + 32 + length) != data.length) {\n            revert MalformedHeader();\n        }\n    }\n\n    function _validateEntries(\n        bytes calldata data\n    ) private pure returns (uint256 count) {\n        uint256 offset = OFFSET_START;\n\n        // data is padded to 32 bytes we can't simply do offset < data.length\n        for (; offset + 32 < data.length; ) {\n            // Per transaction:\n            // Operation   1  bytes\n            // To          20 bytes\n            // Value       32 bytes\n            // Length      32 bytes\n            // Data        Length bytes\n            uint8 operation = uint8(bytes1(data[offset:]));\n            if (operation > 1) {\n                revert MalformedBody();\n            }\n\n            uint256 length = uint256(bytes32(data[offset + 53:]));\n            if (offset + 85 + length > data.length) {\n                revert MalformedBody();\n            }\n\n            offset += 85 + length;\n            count++;\n        }\n\n        if (count == 0) {\n            revert MalformedBody();\n        }\n    }\n\n    function _unwrapEntries(\n        bytes calldata data,\n        uint256 count\n    ) private pure returns (UnwrappedTransaction[] memory result) {\n        result = new UnwrappedTransaction[](count);\n\n        uint256 offset = OFFSET_START;\n        for (uint256 i; i < count; ) {\n            result[i].operation = Enum.Operation(uint8(bytes1(data[offset:])));\n            offset += 1;\n\n            result[i].to = address(bytes20(data[offset:]));\n            offset += 20;\n\n            result[i].value = uint256(bytes32(data[offset:]));\n            offset += 32;\n\n            uint256 size = uint256(bytes32(data[offset:]));\n            offset += 32;\n\n            result[i].dataLocation = offset;\n            result[i].dataSize = size;\n            offset += size;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _ceil32(uint256 length) private pure returns (uint256) {\n        // pad size. Source: http://www.cs.nott.ac.uk/~psarb2/G51MPC/slides/NumberLogic.pdf\n        return ((length + 32 - 1) / 32) * 32;\n    }\n}\n"
          },
          "contracts/adapters/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IMultiSend {\n    function multiSend(bytes memory transactions) external payable;\n}\n\nstruct UnwrappedTransaction {\n    Enum.Operation operation;\n    address to;\n    uint256 value;\n    // We wanna deal in calldata slices. We return location, let invoker slice\n    uint256 dataLocation;\n    uint256 dataSize;\n}\n\ninterface ITransactionUnwrapper {\n    function unwrap(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external view returns (UnwrappedTransaction[] memory result);\n}\n\ninterface ICustomCondition {\n    function check(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 location,\n        uint256 size,\n        bytes12 extra\n    ) external view returns (bool success, bytes32 reason);\n}\n"
          }
        },
        "settings": {
          "evmVersion": "shanghai",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "evm.bytecode",
                "evm.deployedBytecode",
                "devdoc",
                "userdoc",
                "metadata",
                "abi"
              ]
            }
          },
          "libraries": {}
        }
      }
    },
    "3.0.0": {
      "contractName": "MultiSendUnwrapper",
      "sourceName": "contracts/periphery/unwrappers/MultiSendUnwrapper.sol",
      "contractVersion": "3.0.0",
      "compilerVersion": "v0.8.30+commit.73712a01",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x69F590D820e7604768e174Bc364e6b7314DBdCE5",
      "bytecode": "0x6080604052348015600e575f5ffd5b5061082b8061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610029575f3560e01c8063c7a7b6351461002d575b5f5ffd5b61004061003b366004610511565b610056565b60405161004d91906105ca565b60405180910390f35b606084156100775760405163ad6e405560e01b815260040160405180910390fd5b600182600181111561008b5761008b6105b6565b146100a95760405163ad6e405560e01b815260040160405180910390fd5b6100b384846100d6565b5f6100be85856101a1565b90506100cb85858361029d565b979650505050505050565b6346c07f8560e11b6100e8828461065f565b6001600160e01b0319161461011057604051631a751fb760e11b815260040160405180910390fd5b602061011f8260048186610695565b610128916106bc565b1461014657604051631a751fb760e11b815260040160405180910390fd5b5f6101548260248186610695565b61015d916106bc565b90508161017361016e8360406106ed565b6104ca565b61017e9060046106ed565b1461019c57604051631a751fb760e11b815260040160405180910390fd5b505050565b5f60445b826101b18260206106ed565b1015610277575f6101c484838188610695565b6101cd91610700565b60f81c905060018111156101f357604051629ec3f960e31b815260040160405180910390fd5b5f85856102018560356106ed565b61020c928290610695565b610215916106bc565b905084816102248560556106ed565b61022e91906106ed565b111561024c57604051629ec3f960e31b815260040160405180910390fd5b6102578160556106ed565b61026190846106ed565b92508361026d81610736565b94505050506101a5565b815f0361029657604051629ec3f960e31b815260040160405180910390fd5b5092915050565b60608167ffffffffffffffff8111156102b8576102b861074e565b60405190808252806020026020018201604052801561032057816020015b61030d6040805160a08101909152805f81526020015f6001600160a01b031681526020015f81526020015f81526020015f81525090565b8152602001906001900390816102d65790505b50905060445f5b838110156104c15761033b85838189610695565b61034491610700565b60f81c6001811115610358576103586105b6565b83828151811061036a5761036a610762565b60200260200101515f01906001811115610386576103866105b6565b90816001811115610399576103996105b6565b9052506103a76001836106ed565b91506103b585838189610695565b6103be91610776565b60601c8382815181106103d3576103d3610762565b6020908102919091018101516001600160a01b039092169101526103f86014836106ed565b915061040685838189610695565b61040f916106bc565b5f1c83828151811061042357610423610762565b6020026020010151604001818152505060208261044091906106ed565b91505f61044f8684818a610695565b610458916106bc565b90506104656020846106ed565b92508284838151811061047a5761047a610762565b602002602001015160600181815250508084838151811061049d5761049d610762565b6020908102919091010151608001526104b681846106ed565b925050600101610327565b50509392505050565b5f602060016104d984836106ed565b6104e391906107ac565b6104ed91906107bf565b6104f89060206107de565b92915050565b80356002811061050c575f5ffd5b919050565b5f5f5f5f5f60808688031215610525575f5ffd5b85356001600160a01b038116811461053b575f5ffd5b945060208601359350604086013567ffffffffffffffff81111561055d575f5ffd5b8601601f8101881361056d575f5ffd5b803567ffffffffffffffff811115610583575f5ffd5b886020828401011115610594575f5ffd5b602091909101935091506105aa606087016104fe565b90509295509295909350565b634e487b7160e01b5f52602160045260245ffd5b602080825282518282018190525f918401906040840190835b8181101561065457835180516002811061060b57634e487b7160e01b5f52602160045260245ffd5b84526020818101516001600160a01b031681860152604080830151908601526060808301519086015260809182015191850191909152939093019260a0909201916001016105e3565b509095945050505050565b80356001600160e01b03198116906004841015610296576001600160e01b031960049490940360031b84901b1690921692915050565b5f5f858511156106a3575f5ffd5b838611156106af575f5ffd5b5050820193919092039150565b803560208310156104f8575f19602084900360031b1b1692915050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156104f8576104f86106d9565b80356001600160f81b03198116906001841015610296576001600160f81b031960019490940360031b84901b1690921692915050565b5f60018201610747576107476106d9565b5060010190565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b80356001600160601b03198116906014841015610296576001600160601b031960149490940360031b84901b1690921692915050565b818103818111156104f8576104f86106d9565b5f826107d957634e487b7160e01b5f52601260045260245ffd5b500490565b80820281158282048414176104f8576104f86106d956fea26469706673582212207babd794b340cbf28ca8f7062fc79dc666d6f3d9b039f009eb4beafd5fae215e64736f6c634300081e0033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [],
          "name": "MalformedBody",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "MalformedHeader",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "UnsupportedMode",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "internalType": "enum Operation",
              "name": "operation",
              "type": "uint8"
            }
          ],
          "name": "unwrap",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "enum Operation",
                  "name": "operation",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "to",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "value",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "dataLocation",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "dataSize",
                  "type": "uint256"
                }
              ],
              "internalType": "struct UnwrappedTransaction[]",
              "name": "",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis-guild/zodiac-core/contracts/core/Operation.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nenum Operation {\n  Call,\n  DelegateCall\n}\n"
          },
          "contracts/periphery/interfaces/ITransactionUnwrapper.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Operation.sol\";\n\nstruct UnwrappedTransaction {\n    Operation operation;\n    address to;\n    uint256 value;\n    // We wanna deal in calldata slices. We return location, let invoker slice\n    uint256 dataLocation;\n    uint256 dataSize;\n}\n\ninterface ITransactionUnwrapper {\n    function unwrap(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) external view returns (UnwrappedTransaction[] memory result);\n}\n"
          },
          "contracts/periphery/unwrappers/MultiSendUnwrapper.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../interfaces/ITransactionUnwrapper.sol\";\n\ninterface IMultiSend {\n    function multiSend(bytes memory transactions) external payable;\n}\n\ncontract MultiSendUnwrapper is ITransactionUnwrapper {\n    uint256 private constant OFFSET_START = 68;\n\n    error UnsupportedMode();\n    error MalformedHeader();\n    error MalformedBody();\n\n    function unwrap(\n        address,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) external pure returns (UnwrappedTransaction[] memory) {\n        if (value != 0) {\n            revert UnsupportedMode();\n        }\n        if (operation != Operation.DelegateCall) {\n            revert UnsupportedMode();\n        }\n        _validateHeader(data);\n        uint256 count = _validateEntries(data);\n        return _unwrapEntries(data, count);\n    }\n\n    function _validateHeader(bytes calldata data) private pure {\n        // first 4 bytes are the selector for multiSend(bytes)\n        if (bytes4(data) != IMultiSend.multiSend.selector) {\n            revert MalformedHeader();\n        }\n\n        // the following 32 bytes are the offset to the bytes param\n        // (always 0x20)\n        if (bytes32(data[4:]) != bytes32(uint256(0x20))) {\n            revert MalformedHeader();\n        }\n\n        // the following 32 bytes are the length of the bytes param\n        uint256 length = uint256(bytes32(data[36:]));\n\n        // validate that the total calldata length matches\n        // it's the 4 + 32 + 32 bytes checked above + the <length> bytes\n        // padded to a multiple of 32\n        if (4 + _ceil32(32 + 32 + length) != data.length) {\n            revert MalformedHeader();\n        }\n    }\n\n    function _validateEntries(\n        bytes calldata data\n    ) private pure returns (uint256 count) {\n        uint256 offset = OFFSET_START;\n\n        // data is padded to 32 bytes we can't simply do offset < data.length\n        for (; offset + 32 < data.length; ) {\n            // Per transaction:\n            // Operation   1  bytes\n            // To          20 bytes\n            // Value       32 bytes\n            // Length      32 bytes\n            // Data        Length bytes\n            uint8 operation = uint8(bytes1(data[offset:]));\n            if (operation > 1) {\n                revert MalformedBody();\n            }\n\n            uint256 length = uint256(bytes32(data[offset + 53:]));\n            if (offset + 85 + length > data.length) {\n                revert MalformedBody();\n            }\n\n            offset += 85 + length;\n            count++;\n        }\n\n        if (count == 0) {\n            revert MalformedBody();\n        }\n    }\n\n    function _unwrapEntries(\n        bytes calldata data,\n        uint256 count\n    ) private pure returns (UnwrappedTransaction[] memory result) {\n        result = new UnwrappedTransaction[](count);\n\n        uint256 offset = OFFSET_START;\n        for (uint256 i; i < count; ++i) {\n            result[i].operation = Operation(uint8(bytes1(data[offset:])));\n            offset += 1;\n\n            result[i].to = address(bytes20(data[offset:]));\n            offset += 20;\n\n            result[i].value = uint256(bytes32(data[offset:]));\n            offset += 32;\n\n            uint256 size = uint256(bytes32(data[offset:]));\n            offset += 32;\n\n            result[i].dataLocation = offset;\n            result[i].dataSize = size;\n            offset += size;\n        }\n    }\n\n    function _ceil32(uint256 length) private pure returns (uint256) {\n        // pad size. Source: http://www.cs.nott.ac.uk/~psarb2/G51MPC/slides/NumberLogic.pdf\n        return ((length + 32 - 1) / 32) * 32;\n    }\n}\n"
          }
        },
        "settings": {
          "evmVersion": "cancun",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata"
              ],
              "": [
                "ast"
              ]
            }
          }
        }
      }
    }
  },
  "ConditionStorer": {
    "3.0.0": {
      "contractName": "ConditionStorer",
      "sourceName": "contracts/core/serialize/ConditionStorer.sol",
      "contractVersion": "3.0.0",
      "compilerVersion": "v0.8.30+commit.73712a01",
      "factory": "0xce0042b868300000d44a59004da54a005ffdcf9f",
      "address": "0x77172cAA8409e651a74627013B77cEDB00E53D5C",
      "bytecode": "0x613004610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c8063806362d214610043578063deccf5c51461006c575b5f5ffd5b610056610051366004612c33565b610099565b6040516100639190612da2565b60405180910390f35b818015610077575f5ffd5b5061008b610086366004612db4565b6100b3565b604051908152602001610063565b60606100a4826100e9565b6100ad8261013b565b92915050565b5f5f6100be846101e2565b9050806001600160a01b031660a08460038111156100de576100de612e05565b901b17949350505050565b6100f2816102fb565b5f5b8151811015610119576101078282610410565b6101118282610761565b6001016100f4565b50610123816108ac565b61012c81610a15565b610137815f5f610b94565b5050565b606061014682610dc0565b5f5f61015184610f0d565b8551919350915082610164600483612e2d565b61016f906003612e44565b6101799190612e44565b6001600160401b0381111561019057610190612b49565b6040519080825280601f01601f1916602001820160405280156101ba576020820181803683370190505b50600882901b831760e881901b60208301529094506101d98686611003565b50505050919050565b5f5f6101ed8361114f565b905061024f818051602091820120604080516001600160f81b03198185015273ce0042b868300000d44a59004da54a005ffdcf9f60601b60218201525f6035820152605580820193909352815180820390930183526075019052805191012090565b9150813b5f8190036102f45760405163257b1f8160e11b815273ce0042b868300000d44a59004da54a005ffdcf9f90634af63f02906102949085905f90600401612e57565b6020604051808303815f875af11580156102b0573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102d49190612e78565b6001600160a01b0316836001600160a01b0316146102f4576102f4612e9e565b5050919050565b805180158061032a5750815f8151811061031757610317612eb2565b60200260200101515f015161ffff165f14155b1561034857604051632f48858160e21b815260040160405180910390fd5b60015b8181101561040b575f83828151811061036657610366612eb2565b60200260200101515f015161ffff16905081810361039757604051632f48858160e21b815260040160405180910390fd5b836103a3600184612ec6565b815181106103b3576103b3612eb2565b60200260200101515f015161ffff168110156103e257604051638484738160e01b815260040160405180910390fd5b81811061040257604051638484738160e01b815260040160405180910390fd5b5060010161034b565b505050565b5f82828151811061042357610423612eb2565b60200260200101516040015190505f601f81111561044357610443612e05565b81601f81111561045557610455612e05565b036104645761040b8383611187565b600181601f81111561047857610478612e05565b14806104955750600281601f81111561049357610493612e05565b145b156104a45761040b83836111cc565b600481601f8111156104b8576104b8612e05565b036104c75761040b8383611290565b600581601f8111156104db576104db612e05565b036104ea5761040b838361134d565b600681601f8111156104fe576104fe612e05565b148061051b5750600781601f81111561051957610519612e05565b145b1561052a5761040b83836114ff565b600881601f81111561053e5761053e612e05565b0361054d5761040b83836115cf565b600a81601f81111561056157610561612e05565b148061057e5750600b81601f81111561057c5761057c612e05565b145b1561058d5761040b838361169a565b600d81601f8111156105a1576105a1612e05565b036105b05761040b838361190a565b600e81601f8111156105c4576105c4612e05565b036105d35761040b8383611a90565b600f81601f8111156105e7576105e7612e05565b036105f65761040b8383611b3e565b601081601f81111561060a5761060a612e05565b036106195761040b8383611bcc565b601181601f81111561062d5761062d612e05565b148061064a5750601281601f81111561064857610648612e05565b145b806106665750601381601f81111561066457610664612e05565b145b806106825750601481601f81111561068057610680612e05565b145b156106915761040b8383611cea565b601581601f8111156106a5576106a5612e05565b036106b45761040b8383611d8e565b601681601f8111156106c8576106c8612e05565b036106d75761040b8383611e35565b601781601f8111156106eb576106eb612e05565b036106fa5761040b8383611e7c565b601c81601f81111561070e5761070e612e05565b0361071d5761040b8383611fac565b601e81601f81111561073157610731612e05565b036107405761040b83836120f0565b604051630a7d7b8960e41b8152600481018390526024015b60405180910390fd5b5f82828151811061077457610774612eb2565b602002602001015190505f816020015190505f5f610792868661217f565b9093509150600190508360068111156107ad576107ad612e05565b14806107ca575060028360068111156107c8576107c8612e05565b145b806107e6575060068360068111156107e4576107e4612e05565b145b80156108085750600d8460400151601f81111561080557610805612e05565b14155b1561082f57811561082f5760405163999a363b60e01b815260048101869052602401610758565b600583600681111561084357610843612e05565b14806108605750600383600681111561085e5761085e612e05565b145b8061087c5750600483600681111561087a5761087a612e05565b145b156108a457805f036108a45760405163f3379ddd60e01b815260048101869052602401610758565b505050505050565b5f5b8151811015610137575f60018383815181106108cc576108cc612eb2565b602002602001015160400151601f8111156108e9576108e9612e05565b14806109235750600283838151811061090457610904612eb2565b602002602001015160400151601f81111561092157610921612e05565b145b90505f600484848151811061093a5761093a612eb2565b602002602001015160200151600681111561095757610957612e05565b14905081158015610966575080155b15610972575050610a0d565b5f5f61097e86866121cf565b9150915061098a612b23565b5f5b82811015610a06575f6109a8896109a38488612e44565b612252565b90506109b38161255a565b5f036109bf57506109fe565b6109c88361255a565b5f036109d2578092505b6109dc838261262e565b6109fc576040516303a3183b60e61b815260048101899052602401610758565b505b60010161098c565b5050505050505b6001016108ae565b5f5b8151811015610137575f828281518110610a3357610a33612eb2565b6020026020010151604001519050600a601f811115610a5457610a54612e05565b81601f811115610a6657610a66612e05565b14158015610a865750600b81601f811115610a8357610a83612e05565b14155b15610a915750610b8c565b5f610a9c84846121cf565b5090505f610aaa8583612252565b90505f5b816020015151811015610b87575f610afc87888881518110610ad257610ad2612eb2565b6020026020010151606001518481518110610aef57610aef612eb2565b016020015160f81c61269b565b9150505f610b0a8883612252565b90505f81602001515f81518110610b2357610b23612eb2565b602002602001015190505f85602001518581518110610b4457610b44612eb2565b60200260200101519050610b58828261262e565b610b78576040516303a3183b60e61b8152600481018a9052602401610758565b50505050806001019050610aae565b505050505b600101610a17565b5f5f848481518110610ba857610ba8612eb2565b60200260200101519050600e601f811115610bc557610bc5612e05565b8160400151601f811115610bdb57610bdb612e05565b03610c0c575f81606001515f81518110610bf757610bf7612eb2565b0160200151600160f89190911c1b9390931792505b60178160400151601f811115610c2457610c24612e05565b03610cd1575f81606001515f81518110610c4057610c40612eb2565b016020015160f81c90506001811b84165f03610c7b576040516315ff75a960e01b81526004810186905260ff82166024820152604401610758565b5f8260600151600281518110610c9357610c93612eb2565b016020015160f81c90506001811b85165f03610cce576040516315ff75a960e01b81526004810187905260ff82166024820152604401610758565b50505b600a8160400151601f811115610ce957610ce9612e05565b1480610d0a5750600b8160400151601f811115610d0857610d08612e05565b145b15610d7b575f5b816060015151811015610d79575f82606001518281518110610d3557610d35612eb2565b016020015160f81c90506001811b85165f03610d70576040516315ff75a960e01b81526004810187905260ff82166024820152604401610758565b50600101610d11565b505b5f5f610d8787876121cf565b90925090505f5b81811015610db457610daa88610da48386612e44565b88610b94565b9550600101610d8e565b50939695505050505050565b5f5b8151811015610137576005828281518110610ddf57610ddf612eb2565b6020026020010151602001516006811115610dfc57610dfc612e05565b148015610e265750818181518110610e1657610e16612eb2565b602002602001015160600151515f145b15610e6757604051806040016040528060028152602001600160f21b815250828281518110610e5757610e57612eb2565b6020026020010151606001819052505b6010828281518110610e7b57610e7b612eb2565b602002602001015160400151601f811115610e9857610e98612e05565b148015610eac5750610eaa828261273f565b155b15610f05575f828281518110610ec457610ec4612eb2565b602002602001015160600151905060208151036020820191508082525080838381518110610ef457610ef4612eb2565b602002602001015160600181905250505b600101610dc2565b5f5f5f5b8351811015610ffd57600e848281518110610f2e57610f2e612eb2565b602002602001015160400151601f811115610f4b57610f4b612e05565b03610fb2575f848281518110610f6357610f63612eb2565b6020026020010151606001515f81518110610f8057610f80612eb2565b016020015160f81c905082610f96826001612ed9565b60ff161115610fb057610faa816001612ed9565b60ff1692505b505b5f848281518110610fc557610fc5612eb2565b6020026020010151606001515190505f811115610ff457610fe7816002612e44565b610ff19085612e44565b93505b50600101610f11565b50915091565b81516003905f9061101690600490612e2d565b611021906003612e44565b90505f5b8451811015611148575f85828151811061104157611041612eb2565b602002602001015190505f816020015190505f61105e88856121cf565b9150505f61106c898661273f565b611076575f611080565b611080898661281f565b60608501518051919250908015155f8161109a575f61109d565b60015b60ff16600186901b600e88901b60188b60400151601f8111156110c2576110c2612e05565b901b601d8b60068111156110d8576110d8612e05565b901b1717171790508a60208d01018160e01b81511781525060048b6110fd9190612e44565b9a508115611135578960208d01018360f01b81528360208601600283015e50826111288b6002612e44565b6111329190612e44565b99505b5050505050505050806001019050611025565b5050505050565b60608151600161115f9190612e44565b82604051602001611171929190612ef2565b6040516020818303038152906040529050919050565b5f82828151811061119a5761119a612eb2565b602002602001015190508060600151515f1461040b57604051632d6ee65d60e21b815260048101839052602401610758565b5f8282815181106111df576111df612eb2565b602002602001015190505f60068111156111fb576111fb612e05565b8160200151600681111561121157611211612e05565b146112325760405163de10075b60e01b815260048101839052602401610758565b6060810151511561125957604051632d6ee65d60e21b815260048101839052602401610758565b5f61126484846121cf565b915050805f0361128a5760405163f3379ddd60e01b815260048101849052602401610758565b50505050565b5f8282815181106112a3576112a3612eb2565b602002602001015190505f60068111156112bf576112bf612e05565b816020015160068111156112d5576112d5612e05565b146112f65760405163de10075b60e01b815260048101839052602401610758565b6060810151511561131d57604051632d6ee65d60e21b815260048101839052602401610758565b5f61132884846121cf565b915050801561128a5760405163999a363b60e01b815260048101849052602401610758565b5f82828151811061136057611360612eb2565b60209081029190910181015190810151909150600381600681111561138757611387612e05565b141580156113a7575060048160068111156113a4576113a4612e05565b14155b80156113c5575060058160068111156113c2576113c2612e05565b14155b156113e65760405163de10075b60e01b815260048101849052602401610758565b60058160068111156113fa576113fa612e05565b03611498575f60028360600151511015611414575f611426565b826060015161142290612f43565b60f01c5b90505f8360600151515f148061144157508360600151516002145b8061146e5750611452826002612f7d565b61ffff1684606001515114801561146e575060208261ffff1611155b90508061149157604051632d6ee65d60e21b815260048101869052602401610758565b50506114bf565b606082015151156114bf57604051632d6ee65d60e21b815260048101849052602401610758565b5f5f6114cb868661217f565b9250925050805f14806114de5750808214155b156108a45760405163f3379ddd60e01b815260048101869052602401610758565b5f82828151811061151257611512612eb2565b602002602001015190506004600681111561152f5761152f612e05565b8160200151600681111561154557611545612e05565b146115665760405163de10075b60e01b815260048101839052602401610758565b6060810151511561158d57604051632d6ee65d60e21b815260048101839052602401610758565b5f5f611599858561217f565b92509250508060011415806115ae5750818114155b156111485760405163f3379ddd60e01b815260048101859052602401610758565b5f8282815181106115e2576115e2612eb2565b60200260200101519050600460068111156115ff576115ff612e05565b8160200151600681111561161557611615612e05565b146116365760405163de10075b60e01b815260048101839052602401610758565b6060810151511561165d57604051632d6ee65d60e21b815260048101839052602401610758565b5f5f611669858561217f565b9250925050805f14806115ae57508082146111485760405163f3379ddd60e01b815260048101859052602401610758565b5f8282815181106116ad576116ad612eb2565b602002602001015190505f60068111156116c9576116c9612e05565b816020015160068111156116df576116df612e05565b146117005760405163de10075b60e01b815260048101839052602401610758565b6002816060015151101561172a57604051632d6ee65d60e21b815260048101839052602401610758565b5f5f5f611737868661217f565b92509250925080600114158061174d5750818114155b1561176e5760405163f3379ddd60e01b815260048101869052602401610758565b600386848151811061178257611782612eb2565b602002602001015160200151600681111561179f5761179f612e05565b146117c0576040516303a3183b60e61b815260048101869052602401610758565b5f6117cb8785612252565b90506003815160068111156117e2576117e2612e05565b146117ef576117ef612e9e565b8460600151518160200151511461181c57604051632d6ee65d60e21b815260048101879052602401610758565b5f805b8660600151518110156118f5575f8760600151828151811061184357611843612eb2565b016020015160f81c90506001811b8381161561187557604051632d6ee65d60e21b8152600481018b9052602401610758565b928317925f806118858d8561269b565b915091508115806118c5575060048d82815181106118a5576118a5612eb2565b60200260200101516020015160068111156118c2576118c2612e05565b14155b156118e657604051632d6ee65d60e21b8152600481018d9052602401610758565b5050505080600101905061181f565b50611900888661290f565b5050505050505050565b5f82828151811061191d5761191d612eb2565b60209081029190910181015190810151909150600181600681111561194457611944612e05565b141580156119645750600281600681111561196157611961612e05565b14155b156119855760405163de10075b60e01b815260048101849052602401610758565b8160600151516003146119ae57604051632d6ee65d60e21b815260048101849052602401610758565b5f82606001516002815181106119c6576119c6612eb2565b016020015160f81c90508015806119e0575060208160ff16115b15611a0157604051632d6ee65d60e21b815260048101859052602401610758565b5f5f611a0d87876121cf565b9150915080600114611a355760405163f3379ddd60e01b815260048101879052602401610758565b6001878381518110611a4957611a49612eb2565b6020026020010151602001516006811115611a6657611a66612e05565b14611a875760405163598b82ef60e11b815260048101879052602401610758565b50505050505050565b5f828281518110611aa357611aa3612eb2565b602090810291909101810151908101519091505f816006811115611ac957611ac9612e05565b03611aea5760405163de10075b60e01b815260048101849052602401610758565b8160600151516001141580611b1d575081606001515f81518110611b1057611b10612eb2565b60209101015160f81c60ff145b1561128a57604051632d6ee65d60e21b815260048101849052602401610758565b5f828281518110611b5157611b51612eb2565b6020026020010151905060016006811115611b6e57611b6e612e05565b81602001516006811115611b8457611b84612e05565b14611ba55760405163de10075b60e01b815260048101839052602401610758565b6060810151511561040b57604051632d6ee65d60e21b815260048101839052602401610758565b5f828281518110611bdf57611bdf612eb2565b602090810291909101810151908101519091505f816006811115611c0557611c05612e05565b1480611c2257506005816006811115611c2057611c20612e05565b145b15611c435760405163de10075b60e01b815260048101849052602401610758565b5f6001826006811115611c5857611c58612e05565b1480611c7557506006826006811115611c7357611c73612e05565b145b15611c865750606082015151602014155b6003826006811115611c9a57611c9a612e05565b1480611cb757506004826006811115611cb557611cb5612e05565b145b15611cc85760208360600151511090505b801561114857604051632d6ee65d60e21b815260048101859052602401610758565b5f828281518110611cfd57611cfd612eb2565b602090810291909101810151908101519091506001816006811115611d2457611d24612e05565b14158015611d4457506006816006811115611d4157611d41612e05565b14155b15611d655760405163de10075b60e01b815260048101849052602401610758565b81606001515160201461128a57604051632d6ee65d60e21b815260048101849052602401610758565b5f828281518110611da157611da1612eb2565b602090810291909101810151908101519091506001816006811115611dc857611dc8612e05565b14158015611de857506002816006811115611de557611de5612e05565b14155b15611e095760405163de10075b60e01b815260048101849052602401610758565b60048260600151511080611b1d5750600280836060015151611e2b9190612ec6565b611b1d9190612f97565b5f828281518110611e4857611e48612eb2565b602002602001015190506014816060015151101561040b57604051632d6ee65d60e21b815260048101839052602401610758565b5f828281518110611e8f57611e8f612eb2565b602002602001015190505f6006811115611eab57611eab612e05565b81602001516006811115611ec157611ec1612e05565b14611ee25760405163de10075b60e01b815260048101839052602401610758565b806060015151600c14158015611efe5750806060015151602014155b8015611f105750806060015151603414155b15611f3157604051632d6ee65d60e21b815260048101839052602401610758565b60608101516024810151602882015160e091821c92911c9082158015611f5b575063ffffffff8216155b15611f7c57604051632bb338fb60e01b815260048101869052602401610758565b5f611f8787876121cf565b9150508015611a875760405163999a363b60e01b815260048101879052602401610758565b5f828281518110611fbf57611fbf612eb2565b602090810291909101810151908101519091506001816006811115611fe657611fe6612e05565b141580156120065750600681600681111561200357612003612e05565b14155b156120275760405163de10075b60e01b815260048101849052602401610758565b8160600151516020141580156120435750816060015151602214155b80156120555750816060015151603614155b1561207657604051632d6ee65d60e21b815260048101849052602401610758565b6020826060015151111561128a57601b826060015160208151811061209d5761209d612eb2565b016020015160f81c11806120cf5750601b82606001516021815181106120c5576120c5612eb2565b016020015160f81c115b1561128a57604051631de9d6ef60e01b815260048101849052602401610758565b5f82828151811061210357612103612eb2565b602002602001015190505f600681111561211f5761211f612e05565b8160200151600681111561213557612135612e05565b146121565760405163de10075b60e01b815260048101839052602401610758565b80606001515160201461131d57604051632d6ee65d60e21b815260048101839052602401610758565b5f5f5f61218c85856121cf565b90935091505f5b828110156121c7576121ae866121a98387612e44565b612997565b156121bf576121bc82612fb6565b91505b600101612193565b509250925092565b81515f908190816121e1856001612e44565b90505b81811015612249575f8682815181106121ff576121ff612eb2565b60200260200101515f015161ffff16905085810361223257835f03612222578194505b61222b84612fb6565b9350612240565b858111156122405750612249565b506001016121e4565b50509250929050565b61225a612b23565b5f600484848151811061226f5761226f612eb2565b602002602001015160200151600681111561228c5761228c612e05565b1490505f60018585815181106122a4576122a4612eb2565b602002602001015160400151601f8111156122c1576122c1612e05565b14806122fb575060028585815181106122dc576122dc612eb2565b602002602001015160400151601f8111156122f9576122f9612e05565b145b90505f61230886866129aa565b1590505f8061231788886121cf565b915091508380156123255750825b15612381575f5b8181101561236b575f6123438a6121a98487612e44565b1461236357612356896109a38386612e44565b96505050505050506100ad565b60010161232c565b50612374612b23565b95506100ad945050505050565b600688888151811061239557612395612eb2565b60200260200101516020015160068111156123b2576123b2612e05565b146123da578787815181106123c9576123c9612eb2565b6020026020010151602001516123dc565b5f5b869060068111156123ef576123ef612e05565b9081600681111561240257612402612e05565b90525060058651600681111561241a5761241a612e05565b03612469575f88888151811061243257612432612eb2565b602002602001015160600151905060028151101561245157600461245e565b61245a81612f43565b60f01c5b61ffff166040880152505b806001600160401b0381111561248157612481612b49565b6040519080825280602002602001820160405280156124ba57816020015b6124a7612b23565b81526020019060019003908161249f5790505b5060208701525f805b876020015151811015612535575f6124df8b6121a98488612e44565b1461252d576124f28a6109a38387612e44565b60208901518361250181612fb6565b94508151811061251357612513612eb2565b60200260200101819052508680156125285750845b612535575b6001016124c3565b5080602088015152612547898961273f565b1515606088015250505050505092915050565b5f8060068351600681111561257157612571612e05565b1461257d57825161257f565b5f5b90508260200151515f036125a65780600681111561259f5761259f612e05565b9392505050565b8060068111156125b8576125b8612e05565b91505f5b8360200151518110156102f4575f6125f0856020015183815181106125e3576125e3612eb2565b602002602001015161255a565b905080156126255760408051602081018690529081018290526060016040516020818303038152906040528051906020012093505b506001016125bc565b5f5f6126398461255a565b90505f81900361264b5761264b612e9e565b5f6126558461255a565b90505f81900361266757612667612e9e565b808203612679576001925050506100ad565b61268285612ace565b8015612692575061269284612ace565b95945050505050565b5f80805b845181101561273657600e8582815181106126bc576126bc612eb2565b602002602001015160400151601f8111156126d9576126d9612e05565b14801561271e57508360ff168582815181106126f7576126f7612eb2565b6020026020010151606001515f8151811061271457612714612eb2565b016020015160f81c145b1561272e57600192509050612738565b60010161269f565b505b9250929050565b5f5f83838151811061275357612753612eb2565b60200260200101516020015190506002600681111561277457612774612e05565b81600681111561278657612786612e05565b14806127a3575060048160068111156127a1576127a1612e05565b145b806127bf575060058160068111156127bd576127bd612e05565b145b156127cd575f9150506100ad565b5f5f6127d986866121cf565b915091505f5b81811015612812576127fa876127f58386612e44565b61273f565b61280a575f9450505050506100ad565b6001016127df565b5060019695505050505050565b5f61282a838361273f565b151560011461283b5761283b612e9e565b5f83838151811061284e5761284e612eb2565b60200260200101516020015190506001600681111561286f5761286f612e05565b81600681111561288157612881612e05565b036128905760209150506100ad565b5f5f61289c86866121cf565b915091505f5b81811015612905575f6128be886128b98487612e44565b61281f565b90505f8560068111156128d3576128d3612e05565b1480156128df57505f81115b156128f05794506100ad9350505050565b6128fa8187612e44565b9550506001016128a2565b5050505092915050565b600e82828151811061292357612923612eb2565b602002602001015160400151601f81111561294057612940612e05565b0361296157604051630a7d7b8960e41b815260048101829052602401610758565b5f5f61296d84846121cf565b90925090505f5b818110156111485761298f8561298a8386612e44565b61290f565b600101612974565b5f61259f6129a58484612252565b61255a565b5f5f8383815181106129be576129be612eb2565b60200260200101516020015190505f8484815181106129df576129df612eb2565b602002602001015160400151905060046006811115612a0057612a00612e05565b826006811115612a1257612a12612e05565b14158015612a325750600181601f811115612a2f57612a2f612e05565b14155b8015612a505750600281601f811115612a4d57612a4d612e05565b14155b15612a5f575f925050506100ad565b5f5f612a6b87876121cf565b915091505f5f5b82811015612ac0575f612a898a6121a98488612e44565b905080612a965750612ab8565b82612a9f578092505b808314612ab65760019750505050505050506100ad565b505b600101612a72565b505f98975050505050505050565b5f600282516006811115612ae457612ae4612e05565b1480612b025750600582516006811115612b0057612b00612e05565b145b806100ad57505f82516006811115612b1c57612b1c612e05565b1492915050565b6040805160808101909152805f81526060602082018190525f6040830181905291015290565b634e487b7160e01b5f52604160045260245ffd5b604051608081016001600160401b0381118282101715612b7f57612b7f612b49565b60405290565b604051601f8201601f191681016001600160401b0381118282101715612bad57612bad612b49565b604052919050565b803560208110612bc3575f5ffd5b919050565b5f82601f830112612bd7575f5ffd5b81356001600160401b03811115612bf057612bf0612b49565b612c03601f8201601f1916602001612b85565b818152846020838601011115612c17575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60208284031215612c43575f5ffd5b81356001600160401b03811115612c58575f5ffd5b8201601f81018413612c68575f5ffd5b80356001600160401b03811115612c8157612c81612b49565b8060051b612c9160208201612b85565b91825260208184018101929081019087841115612cac575f5ffd5b6020850192505b83831015612d695782356001600160401b03811115612cd0575f5ffd5b85016080818a03601f19011215612ce5575f5ffd5b612ced612b5d565b602082013561ffff81168114612d01575f5ffd5b8152604082013560078110612d14575f5ffd5b6020820152612d2560608301612bb5565b604082015260808201356001600160401b03811115612d42575f5ffd5b612d518b602083860101612bc8565b60608301525083525060209283019290910190612cb3565b979650505050505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61259f6020830184612d74565b5f5f60408385031215612dc5575f5ffd5b82356001600160401b03811115612dda575f5ffd5b612de685828601612bc8565b925050602083013560048110612dfa575f5ffd5b809150509250929050565b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176100ad576100ad612e19565b808201808211156100ad576100ad612e19565b604081525f612e696040830185612d74565b90508260208301529392505050565b5f60208284031215612e88575f5ffd5b81516001600160a01b038116811461259f575f5ffd5b634e487b7160e01b5f52600160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b818103818111156100ad576100ad612e19565b60ff81811683821601908111156100ad576100ad612e19565b606360f81b815260e083901b6001600160e01b03191660018201526880600e6000396000f360b81b60058201525f600e820181905282518060208501600f85015e5f9201600f019182525092915050565b805160208201516001600160f01b03198116919060028210156102f4576001600160f01b031960029290920360031b82901b161692915050565b61ffff81811683821601908111156100ad576100ad612e19565b5f82612fb157634e487b7160e01b5f52601260045260245ffd5b500690565b5f60018201612fc757612fc7612e19565b506001019056fea2646970667358221220896859ce150e0eb1177bb23c436ddeeece0856f7a92fa529bef5feb8a66d345764736f6c634300081e0033",
      "constructorArgs": {
        "types": [],
        "values": []
      },
      "salt": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "AllowanceDecimalsExceedMax",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "LeafNodeCannotHaveChildren",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotBFS",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "pluckIndex",
              "type": "uint8"
            }
          ],
          "name": "PluckNotVisitedBeforeRef",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "SliceChildNotStatic",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableChildCount",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableChildTypeTree",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableCompValue",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsuitableParameterType",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "UnsuitableRootNode",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "UnsupportedOperator",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "name": "WithinRatioNoRatioProvided",
          "type": "error"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "parent",
                  "type": "uint16"
                },
                {
                  "internalType": "enum Encoding",
                  "name": "paramType",
                  "type": "Encoding"
                },
                {
                  "internalType": "enum Operator",
                  "name": "operator",
                  "type": "Operator"
                },
                {
                  "internalType": "bytes",
                  "name": "compValue",
                  "type": "bytes"
                }
              ],
              "internalType": "struct ConditionFlat[]",
              "name": "conditions",
              "type": "tuple[]"
            }
          ],
          "name": "pack",
          "outputs": [
            {
              "internalType": "bytes",
              "name": "buffer",
              "type": "bytes"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "compilerInput": {
        "language": "Solidity",
        "sources": {
          "@gnosis-guild/zodiac-core/contracts/core/Operation.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nenum Operation {\n  Call,\n  DelegateCall\n}\n"
          },
          "contracts/common/ImmutableStorage.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\ninterface ISingletonFactory {\n    function deploy(\n        bytes memory initCode,\n        bytes32 salt\n    ) external returns (address);\n}\n\nlibrary ImmutableStorage {\n    address public constant SINGLETON_FACTORY =\n        0xce0042B868300000d44A59004Da54A005ffdcf9f;\n\n    function store(bytes memory buffer) internal returns (address pointer) {\n        bytes memory bytecode = _creationBytecode(buffer);\n        pointer = _calculateAddress(bytecode);\n\n        uint256 size;\n        assembly {\n            size := extcodesize(pointer)\n        }\n\n        if (size == 0) {\n            assert(\n                pointer ==\n                    ISingletonFactory(SINGLETON_FACTORY).deploy(\n                        bytecode,\n                        bytes32(0)\n                    )\n            );\n        }\n    }\n\n    /**\n     * @notice Reads the runtime bytecode stored at a `pointer` contract, skipping the first byte.\n     *\n     * @param pointer The address of the deployed pointer contract.\n     * @return buffer The raw bytecode (minus the prepended 0x00) read from `pointer`.\n     */\n    function load(address pointer) internal view returns (bytes memory buffer) {\n        assembly {\n            let size := sub(extcodesize(pointer), 1)\n            // free memory point ought to be multiple of 32\n            let rounded := and(add(size, 31), not(31))\n\n            // Get free pointer\n            buffer := mload(0x40)\n            // Store length\n            mstore(buffer, size)\n            // Update free pointer\n            mstore(0x40, add(add(buffer, 0x20), rounded))\n\n            // Copy code starting from offset 0x01 (skip the 0x00 prefix)\n            extcodecopy(pointer, add(buffer, 0x20), 0x01, size)\n        }\n    }\n\n    /**\n     * @notice Generates creation bytecode that deploys a contract containing `data` as its runtime bytecode.\n     * @dev The generated constructor copies `data` into memory and returns it as the contract's code.\n     *      A leading `0x00` byte is prepended so the resulting contract cannot be called.\n     *\n     * Assembly layout (constructor):\n     *\n     * ```\n     * 0x00    63 <XXXXXX>   PUSH4 code_size         ; push code length (runtime size)\n     * 0x01    80             DUP1                   ; duplicate size\n     * 0x02    60 0e          PUSH1 0x0e             ; offset of actual code\n     * 0x03    60 00          PUSH1 0x00             ; destination offset\n     * 0x04    39             CODECOPY               ; copy <code_size> bytes from offset 0x0e\n     * 0x05    60 00          PUSH1 0x00             ; return offset\n     * 0x06    f3             RETURN                 ; return code as runtime bytecode\n     * <CODE>                                        ; runtime code (0x00 + data)\n     * ```\n     *\n     */\n    function _creationBytecode(\n        bytes memory data\n    ) private pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(data.length + 1),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                // Prepend 0x00 to prevent the deployed contract from being callable\n                hex\"00\",\n                data\n            );\n    }\n\n    function _calculateAddress(\n        bytes memory creationBytecode\n    ) private pure returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                SINGLETON_FACTORY,\n                bytes32(0),\n                keccak256(creationBytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}\n"
          },
          "contracts/core/serialize/ConditionPacker.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\n\n/**\n * @title  ConditionPacker\n * @notice A library that provides packing functions for conditions,\n *         transforming ConditionsFlat[] into a memory-optimized buffer.\n *\n * @dev    This library is NOT gas-sensitive since packing is intended to be\n *         called as a helper function within a view entrypoint.\n *\n * @author gnosisguild\n *\n * ╔════════════════════════════════ BUFFER ═════════════════════════════════╗\n * ║ ┌─────────────────────────────────────────────────────────────────────┐ ║\n * ║ │ HEADER (3 bytes = 24 bits)                                          │ ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤ ║\n * ║ │ • conditionNodeCount     16 bits (bytes 0-1)                        │ ║\n * ║ │ • maxPluckValue           8 bits (byte 2)                           │ ║\n * ║ └─────────────────────────────────────────────────────────────────────┘ ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐ ║\n * ║ │ NODES (nodeCount × 4 bytes each)                                    │ ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤ ║\n * ║ │ Each node (32 bits = 4 bytes):                                      │ ║\n * ║ │   • encoding              3 bits  [31-29]                           │ ║\n * ║ │   • operator              5 bits  [28-24]                           │ ║\n * ║ │   • childCount           10 bits  [23-14]                           │ ║\n * ║ │   • inlinedSize          13 bits  [13-1]                            │ ║\n * ║ │   • hasCompValue          1 bit   [0]                               │ ║\n * ║ └─────────────────────────────────────────────────────────────────────┘ ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐ ║\n * ║ │ COMPVALUES (variable length)                                        │ ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤ ║\n * ║ │ For each node with hasCompValue=true (in BFS order):                │ ║\n * ║ │   • length               16 bits  (compValue byte length)           │ ║\n * ║ │   • data                 N bytes  (actual compValue data)           │ ║\n * ║ └─────────────────────────────────────────────────────────────────────┘ ║\n * ╚═════════════════════════════════════════════════════════════════════════╝\n *\n */\nlibrary ConditionPacker {\n    uint256 private constant HEADER_BYTES = 3;\n    uint256 private constant NODE_BYTES = 4;\n\n    function pack(\n        ConditionFlat[] memory conditions\n    ) internal pure returns (bytes memory buffer) {\n        _transform(conditions);\n\n        (uint256 compValuesSize, uint256 maxPluckCount) = _count(conditions);\n\n        uint256 nodeCount = conditions.length;\n\n        buffer = new bytes(\n            HEADER_BYTES + nodeCount * NODE_BYTES + compValuesSize\n        );\n\n        uint256 header = (nodeCount << 8) | maxPluckCount;\n        assembly {\n            mstore(add(buffer, 0x20), shl(232, header))\n        }\n\n        _packNodes(conditions, buffer);\n    }\n\n    function _packNodes(\n        ConditionFlat[] memory conditions,\n        bytes memory buffer\n    ) private pure {\n        uint256 offset = HEADER_BYTES;\n        uint256 compValueOffset = HEADER_BYTES + conditions.length * NODE_BYTES;\n\n        for (uint256 i; i < conditions.length; ++i) {\n            ConditionFlat memory condition = conditions[i];\n\n            Encoding encoding = condition.paramType;\n            (, uint256 childCount) = Topology.childBounds(conditions, i);\n            uint256 inlinedSize = Topology.isInlined(conditions, i)\n                ? Topology.inlinedSize(conditions, i)\n                : 0;\n\n            bytes memory compValue = condition.compValue;\n            uint256 compValueLength = compValue.length;\n            bool hasCompValue = compValueLength > 0;\n\n            /*\n             * ┌───────────────────────────────────────────────────────────┐\n             * │ packed 32 bits, 4 bytes:                                  │\n             * │   • encoding              3 bits  [31-29]                 │\n             * │   • operator              5 bits  [28-24]                 │\n             * │   • childCount           10 bits  [23-14]                 │\n             * │   • inlinedSize          13 bits  [13-1]                  │\n             * │   • hasCompValue          1 bit   [0]                     │\n             * └───────────────────────────────────────────────────────────┘\n             */\n            uint256 packed = (uint256(encoding) << 29) |\n                (uint256(condition.operator) << 24) |\n                (childCount << 14) |\n                (inlinedSize << 1) |\n                (hasCompValue ? 1 : 0);\n\n            /*\n             * The or with mload preserves bytes 4-31 (compValues written in\n             * previous iterations) while writing our 4 bytes at positions 0-3.\n             */\n            assembly {\n                let dest := add(add(buffer, 0x20), offset)\n                mstore(dest, or(mload(dest), shl(224, packed)))\n            }\n            offset += NODE_BYTES;\n\n            // Pack compValue writes at tail, no preserving required\n            if (hasCompValue) {\n                assembly {\n                    let dest := add(add(buffer, 0x20), compValueOffset)\n                    // write 2 bytes length\n                    mstore(dest, shl(240, compValueLength))\n                    // copy compValue body\n                    mcopy(add(dest, 2), add(compValue, 0x20), compValueLength)\n                }\n                compValueOffset = compValueOffset + 2 + compValueLength;\n            }\n        }\n    }\n\n    function _count(\n        ConditionFlat[] memory conditions\n    ) private pure returns (uint256 compValuesSize, uint256 maxPluckCount) {\n        for (uint256 i; i < conditions.length; ++i) {\n            if (conditions[i].operator == Operator.Pluck) {\n                uint8 pluckIndex = uint8(conditions[i].compValue[0]);\n                if (pluckIndex + 1 > maxPluckCount) {\n                    maxPluckCount = pluckIndex + 1;\n                }\n            }\n\n            uint256 length = conditions[i].compValue.length;\n            if (length > 0) {\n                compValuesSize += 2 + length;\n            }\n        }\n    }\n\n    /**\n     * @dev Normalizes conditions in-place before packing:\n     *      1. AbiEncoded without compValue gets default leadingBytes (0x0004)\n     *      2. EqualTo at offset has 32-byte head pointer stripped\n     */\n    function _transform(ConditionFlat[] memory conditions) private pure {\n        for (uint256 i; i < conditions.length; ++i) {\n            /*\n             * Patch AbiEncoded leadingBytes\n             *\n             * AbiEncoded nodes without compValue need a default leadingBytes of 4\n             * (function selector size). Store as 2-byte big-endian value.\n             */\n            if (\n                conditions[i].paramType == Encoding.AbiEncoded &&\n                conditions[i].compValue.length == 0\n            ) {\n                conditions[i].compValue = hex\"0004\";\n            }\n\n            /*\n             * Remove Extraneous Offsets\n             *\n             * Remove unnecessary offsets from compValue fields. This ensures a\n             * consistent API where every `compValue` provided for use in\n             * `Operator.EqualTo` is obtained by calling `abi.encode` directly.\n             *\n             * By removing the leading extraneous offset this makes\n             * `abi.encode(...)` output line up with the layout produced by\n             * Decoder inspection. Without it, callers would need to patch\n             * compValues based on whether the payload is fully inline or at\n             * offset.\n             */\n            if (\n                conditions[i].operator == Operator.EqualTo &&\n                !Topology.isInlined(conditions, i)\n            ) {\n                bytes memory compValue = conditions[i].compValue;\n                assembly {\n                    let newLength := sub(mload(compValue), 32)\n                    compValue := add(compValue, 32)\n                    mstore(compValue, newLength)\n                }\n                conditions[i].compValue = compValue;\n            }\n        }\n    }\n}\n"
          },
          "contracts/core/serialize/ConditionStorer.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../common/ImmutableStorage.sol\";\n\nimport \"./ConditionPacker.sol\";\nimport \"./Integrity.sol\";\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title ConditionStorer\n * @notice Validates and stores condition trees in immutable storage.\n *\n * @author gnosisguild\n */\nlibrary ConditionStorer {\n    /**\n     * @notice Validates and packs a condition tree into bytes.\n     *\n     * @param conditions The flat condition array in BFS order.\n     * @return buffer The packed condition buffer.\n     */\n    function pack(\n        ConditionFlat[] memory conditions\n    ) external pure returns (bytes memory buffer) {\n        Integrity.enforce(conditions);\n        return ConditionPacker.pack(conditions);\n    }\n\n    /**\n     * @notice Stores a pre-packed condition buffer.\n     *\n     * @param buffer The packed condition buffer (from pack()).\n     * @param options Execution options (Send, DelegateCall, Both, None).\n     * @return scopeConfig Packed scope config (options << 160 | pointer).\n     */\n    function store(\n        bytes memory buffer,\n        ExecutionOptions options\n    ) external returns (uint256 scopeConfig) {\n        address pointer = ImmutableStorage.store(buffer);\n        return (uint256(options) << 160) | uint160(pointer);\n    }\n}\n"
          },
          "contracts/core/serialize/Integrity.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Topology.sol\";\nimport \"./TypeTree.sol\";\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title Integrity\n * @notice A library that validates input condition integrity\n *\n * @author gnosisguild\n */\nlibrary Integrity {\n    function enforce(ConditionFlat[] memory conditions) internal pure {\n        _validateBFS(conditions);\n\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            _validateOperator(conditions, i);\n            _validateEncoding(conditions, i);\n        }\n\n        _validateVariantTypes(conditions);\n        _validatePluckZipTypes(conditions);\n        _validatePluckOrder(conditions, 0, 0);\n    }\n\n    function _validateBFS(ConditionFlat[] memory conditions) private pure {\n        uint256 length = conditions.length;\n        if (length == 0 || conditions[0].parent != 0) {\n            revert IRolesError.UnsuitableRootNode();\n        }\n\n        for (uint256 i = 1; i < length; ++i) {\n            uint256 parent = conditions[i].parent;\n            if (parent == i) {\n                revert IRolesError.UnsuitableRootNode();\n            }\n            // Parent must have lower index (no forward references)\n            if (parent < conditions[i - 1].parent) {\n                revert IRolesError.NotBFS();\n            }\n            // Parent cannot be higher than self\n            if (parent >= i) {\n                revert IRolesError.NotBFS();\n            }\n        }\n    }\n\n    function _validateOperator(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        Operator op = conditions[index].operator;\n\n        if (op == Operator.Pass) {\n            _checkPass(conditions, index);\n        } else if (op == Operator.And || op == Operator.Or) {\n            _checkLogic(conditions, index);\n        } else if (op == Operator.Empty) {\n            _checkEmpty(conditions, index);\n        } else if (op == Operator.Matches) {\n            _checkMatches(conditions, index);\n        } else if (op == Operator.ArraySome || op == Operator.ArrayEvery) {\n            _checkArrayIterator(conditions, index);\n        } else if (op == Operator.ArrayTailMatches) {\n            _checkArrayTail(conditions, index);\n        } else if (op == Operator.ZipSome || op == Operator.ZipEvery) {\n            _checkZipIterator(conditions, index);\n        } else if (op == Operator.Slice) {\n            _checkSlice(conditions, index);\n        } else if (op == Operator.Pluck) {\n            _checkPluck(conditions, index);\n        } else if (op == Operator.EqualToAvatar) {\n            _checkEqualToAvatar(conditions, index);\n        } else if (op == Operator.EqualTo) {\n            _checkEqualTo(conditions, index);\n        } else if (\n            op == Operator.GreaterThan ||\n            op == Operator.LessThan ||\n            op == Operator.SignedIntGreaterThan ||\n            op == Operator.SignedIntLessThan\n        ) {\n            _checkComparison(conditions, index);\n        } else if (op == Operator.Bitmask) {\n            _checkBitmask(conditions, index);\n        } else if (op == Operator.Custom) {\n            _checkCustom(conditions, index);\n        } else if (op == Operator.WithinRatio) {\n            _checkWithinRatio(conditions, index);\n        } else if (op == Operator.WithinAllowance) {\n            _checkWithinAllowance(conditions, index);\n        } else if (op == Operator.CallWithinAllowance) {\n            _checkCallWithinAllowance(conditions, index);\n        } else {\n            revert IRolesError.UnsupportedOperator(index);\n        }\n    }\n\n    /**\n     * @notice Validates child constraints based on encoding type.\n     *\n     * @dev Encoding types determine fundamental child rules:\n     *      - Leaf types (Static, Dynamic, EtherValue): Cannot have children\n     *      - Container types (Tuple, Array): Must have structural children\n     *      - None: Operator-dependent (validated elsewhere)\n     *\n     *      Exception: Slice operator uses Static/Dynamic encoding but requires\n     *      exactly one child (validated in _checkSlice).\n     */\n    function _validateEncoding(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n\n        if (\n            (encoding == Encoding.Static ||\n                encoding == Encoding.Dynamic ||\n                encoding == Encoding.EtherValue) &&\n            (condition.operator != Operator.Slice)\n        ) {\n            // Slice is a special case: uses Static/Dynamic but requires a child\n            // Leaf types cannot have children\n            if (childCount != 0) {\n                revert IRolesError.LeafNodeCannotHaveChildren(index);\n            }\n        }\n\n        if (\n            encoding == Encoding.AbiEncoded ||\n            encoding == Encoding.Tuple ||\n            encoding == Encoding.Array\n        ) {\n            // Container types must have structural children for type tree\n            if (sChildCount == 0) {\n                revert IRolesError.UnsuitableChildCount(index);\n            }\n        }\n    }\n\n    // --- Operator Handlers ---\n\n    function _checkPass(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // Encoding: Any\n        // CompValue: Must be empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkLogic(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // And/Or\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: Must have children\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount == 0) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkEmpty(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: None\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount != 0) {\n            revert IRolesError.LeafNodeCannotHaveChildren(index);\n        }\n    }\n\n    function _checkMatches(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Tuple, Array, AbiEncoded\n        if (\n            encoding != Encoding.Tuple &&\n            encoding != Encoding.Array &&\n            encoding != Encoding.AbiEncoded\n        ) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n\n        // CompValue Validation\n        if (encoding == Encoding.AbiEncoded) {\n            uint16 leadingBytes = condition.compValue.length >= 2\n                ? uint16(bytes2(condition.compValue))\n                : 0;\n            bool valid = condition.compValue.length == 0 ||\n                condition.compValue.length == 2 ||\n                (condition.compValue.length == 2 + leadingBytes &&\n                    leadingBytes <= 32);\n            if (!valid) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n        } else {\n            if (condition.compValue.length != 0) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n        }\n\n        // All children must be structural\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n        if (sChildCount == 0 || childCount != sChildCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkArrayIterator(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ArraySome / ArrayEvery\n        // ParamType: Array\n        if (condition.paramType != Encoding.Array) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: Exactly 1 child\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n        if (sChildCount != 1 || sChildCount != childCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkArrayTail(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ArrayTailMatches\n        // ParamType: Array\n        if (condition.paramType != Encoding.Array) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: All children must be structural\n        (, uint256 childCount, uint256 sChildCount) = _sChildBounds(\n            conditions,\n            index\n        );\n        if (sChildCount == 0 || childCount != sChildCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n    }\n\n    function _checkZipIterator(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ZipSome / ZipEvery\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: at least 2 bytes (one per plucked array)\n        if (condition.compValue.length < 2) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n\n        // Children: Exactly 1 child\n        (\n            uint256 childStart,\n            uint256 childCount,\n            uint256 sChildCount\n        ) = _sChildBounds(conditions, index);\n        if (sChildCount != 1 || sChildCount != childCount) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n\n        if (conditions[childStart].paramType != Encoding.Tuple) {\n            revert IRolesError.UnsuitableChildTypeTree(index);\n        }\n\n        // Child must resolve to a Tuple\n        Layout memory layout = TypeTree.resolve(conditions, childStart);\n        assert(layout.encoding == Encoding.Tuple);\n\n        // Tuple field count must match compValue length\n        if (layout.children.length != condition.compValue.length) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n\n        // Validate pluck references: no duplicates, each must exist and be Array\n        uint256 seen;\n        for (uint256 k = 0; k < condition.compValue.length; ++k) {\n            uint8 pluckIndex = uint8(condition.compValue[k]);\n            uint256 mask = 1 << pluckIndex;\n            if ((seen & mask) != 0) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n            seen |= mask;\n\n            (bool found, uint256 pluckCondition) = _findPluckedArray(\n                conditions,\n                pluckIndex\n            );\n            if (\n                !found || conditions[pluckCondition].paramType != Encoding.Array\n            ) {\n                revert IRolesError.UnsuitableCompValue(index);\n            }\n        }\n\n        // No Pluck allowed in zip descendants\n        _validateNoPluckDescendant(conditions, childStart);\n    }\n\n    function _checkSlice(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Static / Dynamic\n        if (encoding != Encoding.Static && encoding != Encoding.Dynamic) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 3 bytes\n        if (condition.compValue.length != 3) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        uint8 size = uint8(condition.compValue[2]);\n        if (size == 0 || size > 32) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n        // Children: At most 1 child\n        if (childCount != 1) {\n            revert IRolesError.UnsuitableChildCount(index);\n        }\n\n        // If it has a structural child, it must resolve to Static\n        if (conditions[childStart].paramType != Encoding.Static) {\n            revert IRolesError.SliceChildNotStatic(index);\n        }\n    }\n\n    function _checkPluck(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Static / EtherValue / Array\n        if (encoding == Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 1 byte\n        if (\n            condition.compValue.length != 1 ||\n            uint8(condition.compValue[0]) == 255\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkEqualToAvatar(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: Static\n        if (condition.paramType != Encoding.Static) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: Empty\n        if (condition.compValue.length != 0) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkEqualTo(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding enc = condition.paramType;\n        // ParamType: Static, Dynamic, Tuple, Array, EtherValue\n        if (enc == Encoding.None || enc == Encoding.AbiEncoded) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n\n        // CompValue check\n        bool unsuitable;\n        if (enc == Encoding.Static || enc == Encoding.EtherValue) {\n            unsuitable = condition.compValue.length != 32;\n        }\n\n        if (enc == Encoding.Tuple || enc == Encoding.Array) {\n            unsuitable = condition.compValue.length < 32;\n        }\n\n        if (unsuitable) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkComparison(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: WordLike\n        if (encoding != Encoding.Static && encoding != Encoding.EtherValue) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 32 bytes\n        if (condition.compValue.length != 32) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkBitmask(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: Static / Dynamic\n        if (encoding != Encoding.Static && encoding != Encoding.Dynamic) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 2 shift + 2N\n        if (\n            condition.compValue.length < 4 ||\n            (condition.compValue.length - 2) % 2 != 0\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkCustom(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // CompValue: >= 20 bytes\n        if (condition.compValue.length < 20) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n    }\n\n    function _checkWithinRatio(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 12, 32 or 52 bytes (12 base + 0, 1, or 2 adapters)\n        if (\n            condition.compValue.length != 12 &&\n            condition.compValue.length != 32 &&\n            condition.compValue.length != 52\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Check ratio bounds\n        uint32 minRatio;\n        uint32 maxRatio;\n        bytes memory cv = condition.compValue;\n        assembly {\n            minRatio := shr(224, mload(add(cv, 0x24)))\n            maxRatio := shr(224, mload(add(cv, 0x28)))\n        }\n        if (minRatio == 0 && maxRatio == 0) {\n            revert IRolesError.WithinRatioNoRatioProvided(index);\n        }\n        // Children: None\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount != 0) {\n            revert IRolesError.LeafNodeCannotHaveChildren(index);\n        }\n    }\n\n    function _checkWithinAllowance(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        Encoding encoding = condition.paramType;\n        // ParamType: WordLike\n        if (encoding != Encoding.Static && encoding != Encoding.EtherValue) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 32, 34, 54\n        if (\n            condition.compValue.length != 32 &&\n            condition.compValue.length != 34 &&\n            condition.compValue.length != 54\n        ) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        if (condition.compValue.length > 32) {\n            if (\n                uint8(condition.compValue[32]) > 27 ||\n                uint8(condition.compValue[33]) > 27\n            ) {\n                revert IRolesError.AllowanceDecimalsExceedMax(index);\n            }\n        }\n    }\n\n    function _checkCallWithinAllowance(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        ConditionFlat memory condition = conditions[index];\n        // ParamType: None\n        if (condition.paramType != Encoding.None) {\n            revert IRolesError.UnsuitableParameterType(index);\n        }\n        // CompValue: 32 bytes\n        if (condition.compValue.length != 32) {\n            revert IRolesError.UnsuitableCompValue(index);\n        }\n        // Children: None\n        (, uint256 childCount) = Topology.childBounds(conditions, index);\n        if (childCount != 0) {\n            revert IRolesError.LeafNodeCannotHaveChildren(index);\n        }\n    }\n\n    function _validateVariantTypes(\n        ConditionFlat[] memory conditions\n    ) private pure {\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            bool isLogical = conditions[i].operator == Operator.And ||\n                conditions[i].operator == Operator.Or;\n            bool isArray = conditions[i].paramType == Encoding.Array;\n            /*\n             * Only Logical or Arrays hold variants\n             */\n            if (!isLogical && !isArray) continue;\n\n            (uint256 childStart, uint256 childCount) = Topology.childBounds(\n                conditions,\n                i\n            );\n\n            Layout memory a;\n            for (uint256 j = 0; j < childCount; ++j) {\n                Layout memory b = TypeTree.resolve(conditions, childStart + j);\n                if (TypeTree.hash(b) == 0) continue;\n\n                if (TypeTree.hash(a) == 0) a = b;\n\n                if (!_isTypeCompatible(a, b)) {\n                    revert IRolesError.UnsuitableChildTypeTree(i);\n                }\n            }\n        }\n    }\n\n    function _validatePluckZipTypes(\n        ConditionFlat[] memory conditions\n    ) private pure {\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            Operator op = conditions[i].operator;\n            if (op != Operator.ZipSome && op != Operator.ZipEvery) continue;\n\n            (uint256 childStart, ) = Topology.childBounds(conditions, i);\n\n            Layout memory tuple = TypeTree.resolve(conditions, childStart);\n\n            for (uint256 j = 0; j < tuple.children.length; ++j) {\n                (, uint256 pluckCondition) = _findPluckedArray(\n                    conditions,\n                    uint8(conditions[i].compValue[j])\n                );\n                Layout memory array = TypeTree.resolve(\n                    conditions,\n                    pluckCondition\n                );\n\n                Layout memory arrayEntry = array.children[0];\n                Layout memory tupleField = tuple.children[j];\n\n                if (!_isTypeCompatible(arrayEntry, tupleField)) {\n                    revert IRolesError.UnsuitableChildTypeTree(i);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Validates plucked variable definitions precede their usage.\n     *\n     * @dev Evaluation happens in DFS order, so this function must check that\n     *      definitions come before usages in DFS order.\n     *\n     *      While the flat `conditions` array is stored in BFS order (parents\n     *      first), this function traverses the tree in DFS order to track the\n     *      `visited` state of plucked variables. This ensures that a\n     *      `WithinRatio` check can only reference variables that have been\n     *      \"plucked\" by a preceding condition in the execution flow.\n     */\n    function _validatePluckOrder(\n        ConditionFlat[] memory conditions,\n        uint256 index,\n        uint256 visited\n    ) private pure returns (uint256) {\n        ConditionFlat memory condition = conditions[index];\n\n        if (condition.operator == Operator.Pluck) {\n            uint8 pluckIndex = uint8(condition.compValue[0]);\n            visited |= (1 << pluckIndex);\n        }\n\n        if (condition.operator == Operator.WithinRatio) {\n            uint8 referencePluckIndex = uint8(condition.compValue[0]);\n            if ((visited & (1 << referencePluckIndex)) == 0) {\n                revert IRolesError.PluckNotVisitedBeforeRef(\n                    index,\n                    referencePluckIndex\n                );\n            }\n\n            uint8 relativePluckIndex = uint8(condition.compValue[2]);\n            if ((visited & (1 << relativePluckIndex)) == 0) {\n                revert IRolesError.PluckNotVisitedBeforeRef(\n                    index,\n                    relativePluckIndex\n                );\n            }\n        }\n\n        if (\n            condition.operator == Operator.ZipSome ||\n            condition.operator == Operator.ZipEvery\n        ) {\n            for (uint256 k; k < condition.compValue.length; ++k) {\n                uint8 pluckIndex = uint8(condition.compValue[k]);\n                if ((visited & (1 << pluckIndex)) == 0) {\n                    revert IRolesError.PluckNotVisitedBeforeRef(\n                        index,\n                        pluckIndex\n                    );\n                }\n            }\n        }\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n\n        for (uint256 i = 0; i < childCount; ++i) {\n            visited = _validatePluckOrder(conditions, childStart + i, visited);\n        }\n\n        return visited;\n    }\n\n    function _validateNoPluckDescendant(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure {\n        if (conditions[index].operator == Operator.Pluck) {\n            revert IRolesError.UnsupportedOperator(index);\n        }\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n        for (uint256 i = 0; i < childCount; ++i) {\n            _validateNoPluckDescendant(conditions, childStart + i);\n        }\n    }\n\n    function _sChildBounds(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    )\n        private\n        pure\n        returns (uint256 childStart, uint256 childCount, uint256 sChildCount)\n    {\n        (childStart, childCount) = Topology.childBounds(conditions, index);\n        for (uint256 i; i < childCount; ++i) {\n            if (TypeTree.hash(conditions, childStart + i) != 0) {\n                ++sChildCount;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if two layouts are type-compatible: either exact type\n     *         hash match, or type equivalence (both resolve to Dynamic or\n     *         AbiEncoded).\n     */\n    function _isTypeCompatible(\n        Layout memory a,\n        Layout memory b\n    ) private pure returns (bool) {\n        bytes32 hashA = TypeTree.hash(a);\n        assert(hashA != 0);\n\n        bytes32 hashB = TypeTree.hash(b);\n        assert(hashB != 0);\n\n        if (hashA == hashB) {\n            return true;\n        }\n        return _isDynamicish(a) && _isDynamicish(b);\n    }\n\n    /**\n     * @notice Finds the conditions index of the Pluck condition with the given\n     *         pluck index.\n     */\n    function _findPluckedArray(\n        ConditionFlat[] memory conditions,\n        uint8 pluckIndex\n    ) private pure returns (bool found, uint256 conditionIndex) {\n        for (uint256 i = 0; i < conditions.length; ++i) {\n            if (\n                conditions[i].operator == Operator.Pluck &&\n                uint8(conditions[i].compValue[0]) == pluckIndex\n            ) {\n                return (true, i);\n            }\n        }\n    }\n\n    function _isDynamicish(Layout memory layout) private pure returns (bool) {\n        /*\n         * None on a resolved type tree means a Variant placeholder. Such\n         * fields equate to Dynamic\n         */\n        return\n            layout.encoding == Encoding.Dynamic ||\n            layout.encoding == Encoding.AbiEncoded ||\n            layout.encoding == Encoding.None;\n    }\n}\n"
          },
          "contracts/core/serialize/Topology.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../types/Types.sol\";\n\n/**\n * @title  Topology\n * @notice Utilities for navigating flat condition tree structure.\n *\n * @author gnosisguild\n */\nlibrary Topology {\n    /**\n     * @notice Gets the bounds and counts of children for a given node\n     * @param conditions The flat array of conditions\n     * @param index The index of the parent node\n     *\n     * @return childStart The index of the first child (0 if no children)\n     * @return childCount The total number of children\n     */\n    function childBounds(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (uint256 childStart, uint256 childCount) {\n        uint256 len = conditions.length;\n\n        for (uint256 i = index + 1; i < len; ++i) {\n            uint256 parent = conditions[i].parent;\n\n            if (parent == index) {\n                if (childCount == 0) childStart = i;\n                ++childCount;\n            } else if (parent > index) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if a node is inlined (all descendants are static)\n     */\n    function isInlined(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (bool) {\n        Encoding encoding = conditions[index].paramType;\n        if (\n            encoding == Encoding.Dynamic ||\n            encoding == Encoding.Array ||\n            encoding == Encoding.AbiEncoded\n        ) {\n            return false;\n        }\n\n        (uint256 childStart, uint256 childCount) = childBounds(\n            conditions,\n            index\n        );\n        for (uint256 i; i < childCount; ++i) {\n            if (!isInlined(conditions, childStart + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Computes inlined size for a node (0 if not inlined)\n     */\n    function inlinedSize(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (uint256 size) {\n        assert(isInlined(conditions, index) == true);\n\n        /*\n         * Dynamic, Array, and AbiEncoded types are never inlined, so this\n         * function is guaranteed to only process Static, Tuple, or None types\n         * (enforced by the assertion above).\n         */\n        Encoding encoding = conditions[index].paramType;\n\n        if (encoding == Encoding.Static) {\n            return 32;\n        }\n\n        /*\n         * Remaining encodings:\n         * - Tuple: sum of all children sizes\n         * - None: delegates to first structural child\n         */\n        (uint256 childStart, uint256 childCount) = childBounds(\n            conditions,\n            index\n        );\n\n        for (uint256 i; i < childCount; ++i) {\n            uint256 childSize = inlinedSize(conditions, childStart + i);\n            /*\n             * None nodes are transparent wrappers (And/Or or non-structural).\n             * Since inlined nodes can't have variants, all structural children\n             * share the same size. Return on first non-zero (structural) child.\n             */\n            if (encoding == Encoding.None && childSize > 0) return childSize;\n            size += childSize;\n        }\n    }\n}\n"
          },
          "contracts/core/serialize/TypeTree.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../../types/Types.sol\";\nimport \"./Topology.sol\";\n\n/**\n * @title  TypeTree\n * @notice Extracts type trees from flat conditions for use in decoding.\n *         Variants can appear in logical or array nodes and must be handled.\n *         See inline comments for rules\n *\n * @author gnosisguild\n */\nlibrary TypeTree {\n    /**\n     * @notice Resolves type tree for condition at an index\n     */\n    function resolve(\n        ConditionFlat[] memory conditions,\n        uint256 i\n    ) internal pure returns (Layout memory layout) {\n        bool isArray = conditions[i].paramType == Encoding.Array;\n        bool isLogical = conditions[i].operator == Operator.And ||\n            conditions[i].operator == Operator.Or;\n        bool isNonVariant = _isVariant(conditions, i) == false;\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            i\n        );\n\n        if (isLogical && isNonVariant) {\n            /*\n             * Non-variant logical nodes: first structural child defines the type tree\n             */\n            for (uint256 j; j < childCount; ++j) {\n                if (hash(conditions, childStart + j) != bytes32(0)) {\n                    return resolve(conditions, childStart + j);\n                }\n            }\n\n            /*\n             * No structural child was found.\n             */\n            Layout memory none;\n            return none;\n        }\n\n        layout.encoding = conditions[i].paramType == Encoding.EtherValue\n            ? Encoding.None\n            : conditions[i].paramType;\n\n        /*\n         * Extract leadingBytes for AbiEncoded from compValue, first 2 bytes\n         * Default is 4 (selector size) when compValue is empty\n         */\n        if (layout.encoding == Encoding.AbiEncoded) {\n            bytes memory compValue = conditions[i].compValue;\n            layout.leadingBytes = compValue.length >= 2\n                ? uint16(bytes2(compValue))\n                : 4;\n        }\n\n        layout.children = new Layout[](childCount);\n\n        uint256 length;\n        for (uint256 j; j < layout.children.length; ++j) {\n            if (hash(conditions, childStart + j) != bytes32(0)) {\n                layout.children[length++] = resolve(conditions, childStart + j);\n\n                /*\n                 * For non-variant arrays, the first child serves as a template for\n                 * all elements. For all other nodes, traverse all structural children\n                 */\n                if (isArray && isNonVariant) {\n                    break;\n                }\n            }\n        }\n        assembly {\n            // layout.children is at offset 0x20 (second field)\n            mstore(mload(add(layout, 0x20)), length)\n        }\n\n        layout.inlined = Topology.isInlined(conditions, i);\n    }\n\n    /**\n     * @notice Checks if a node is a variant (children have different type trees)\n     */\n    function _isVariant(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) private pure returns (bool) {\n        Encoding encoding = conditions[index].paramType;\n        Operator operator = conditions[index].operator;\n        if (\n            encoding != Encoding.Array &&\n            operator != Operator.And &&\n            operator != Operator.Or\n        ) {\n            return false;\n        }\n\n        (uint256 childStart, uint256 childCount) = Topology.childBounds(\n            conditions,\n            index\n        );\n\n        bytes32 baseline;\n        for (uint256 i; i < childCount; ++i) {\n            bytes32 childHash = hash(conditions, childStart + i);\n\n            if (childHash == bytes32(0)) {\n                continue;\n            }\n\n            if (baseline == bytes32(0)) {\n                baseline = childHash;\n            }\n\n            if (baseline != childHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Computes a unique hash for a type tree structure\n     */\n    function hash(\n        ConditionFlat[] memory conditions,\n        uint256 index\n    ) internal pure returns (bytes32) {\n        return hash(resolve(conditions, index));\n    }\n\n    /**\n     * @notice Computes a unique hash for a Layout tree\n     */\n    function hash(Layout memory tree) internal pure returns (bytes32 result) {\n        Encoding encoding = tree.encoding == Encoding.EtherValue\n            ? Encoding.None\n            : tree.encoding;\n\n        if (tree.children.length == 0) {\n            return bytes32(uint256(encoding));\n        }\n\n        result = bytes32(uint256(encoding));\n        for (uint256 i; i < tree.children.length; ++i) {\n            bytes32 childHash = hash(tree.children[i]);\n            if (childHash != bytes32(0)) {\n                result = keccak256(abi.encodePacked(result, childHash));\n            }\n        }\n    }\n}\n"
          },
          "contracts/types/Allowance.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\n/**\n * @notice Represents an allowance with periodic refilling capability.\n *\n * @dev The struct layout is storage-optimized: fields updated together during\n * accrual (`balance` and `timestamp`) share word2, minimizing SSTORE\n *\n * Storage Layout (2 words, 64 bytes, 512 bits):\n * ┌────────────────────────────────┬────────────────────────────────┐\n * │           maxRefill            │             refill             │\n * │            128 bits            │            128 bits            │\n * ├────────────────┬───────────────┴───────────────┬────────────────┤\n * │   timestamp    │            balance            │     period     │\n * │    64 bits     │           128 bits            │    64 bits     │\n * └────────────────┴───────────────────────────────┴────────────────┘\n *\n * @custom:member refill Amount added to balance each period.\n * @custom:member maxRefill Cap at which refilling stops.\n * @custom:member period Refill interval in seconds. Zero means one-time use.\n * @custom:member balance Current available allowance.\n * @custom:member timestamp Last refill time.\n */\nstruct Allowance {\n    uint128 refill;\n    uint128 maxRefill;\n    uint64 period;\n    uint128 balance;\n    uint64 timestamp;\n}\n\nstruct Consumption {\n    bytes32 allowanceKey;\n    uint128 balance;\n    uint128 consumed;\n    uint64 timestamp;\n}\n"
          },
          "contracts/types/Authorization.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@gnosis-guild/zodiac-core/contracts/core/Operation.sol\";\n\nimport {Consumption} from \"./Allowance.sol\";\n\nenum Status {\n    Ok,\n    /// Or conition not met\n    OrViolation,\n    /// Parameter value is not equal to allowed\n    ParameterNotAllowed,\n    /// Parameter value less than allowed\n    ParameterLessThanAllowed,\n    /// Parameter value greater than maximum allowed by role\n    ParameterGreaterThanAllowed,\n    /// Parameter value does not match\n    ParameterNotAMatch,\n    /// Array elements do not meet allowed criteria for every element\n    NotEveryArrayElementPasses,\n    /// Array elements do not meet allowed criteria for at least one element\n    NoArrayElementPasses,\n    /// Bitmask exceeded value length\n    BitmaskOverflow,\n    /// Bitmask not an allowed value\n    BitmaskNotAllowed,\n    CustomConditionViolation,\n    CustomConditionNotAContract,\n    CustomConditionReverted,\n    CustomConditionInvalidResult,\n    PricingAdapterNotAContract,\n    PricingAdapterReverted,\n    PricingAdapterInvalidResult,\n    PricingAdapterZeroPrice,\n    AllowanceExceeded,\n    /// Converted allowance value exceeds uint128 max\n    AllowanceValueOverflow,\n    CalldataOverflow,\n    RatioBelowMin,\n    RatioAboveMax,\n    /// Calldata is not empty when it should be\n    CalldataNotEmpty,\n    /// Leading bytes do not match expected value\n    LeadingBytesNotAMatch,\n    /// Zipped arrays have different lengths\n    ZippedArrayLengthMismatch,\n    /// No zipped element pair passes\n    NoZippedElementPasses,\n    /// Not every zipped element pair passes\n    NotEveryZippedElementPasses\n}\n\nstruct Transaction {\n    address to;\n    uint256 value;\n    Operation operation;\n}\n\nstruct Context {\n    address to;\n    uint256 value;\n    Operation operation;\n    bytes32[] pluckedValues;\n    uint256[] pluckedLocations;\n}\n\nstruct Result {\n    Status status;\n    uint256 violatedNodeIndex;\n    uint256 payloadLocation;\n    Consumption[] consumptions;\n}\n"
          },
          "contracts/types/Condition.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Operator} from \"./Operator.sol\";\n\nenum Encoding {\n    None,\n    Static,\n    Dynamic,\n    Tuple,\n    Array,\n    AbiEncoded,\n    /* EtherValue is a nonstructural, and an alias for None */\n    EtherValue\n}\n\nstruct Condition {\n    /// @dev BFS index from unpacking - identifies this node in the flattened tree\n    uint256 index;\n    Encoding encoding;\n    Operator operator;\n    bytes compValue;\n    Condition[] children;\n    /* meta fields */\n    bool inlined;\n    uint256 size;\n    uint256 leadingBytes;\n}\n\n// This struct is a flattened version of Condition\n// used for ABI encoding a scope config tree\n// (ABI does not support recursive types)\nstruct ConditionFlat {\n    uint16 parent;\n    Encoding paramType;\n    Operator operator;\n    bytes compValue;\n}\n\n/// @dev Layout is a type tree used for AbiDecoder and EIP712 encoding.\nstruct Layout {\n    Encoding encoding;\n    Layout[] children;\n    uint256 leadingBytes;\n    bool inlined;\n}\n\nstruct LayoutFlat {\n    uint256 parent;\n    Encoding encoding;\n}\n\n/// @dev Payload is the result of AbiDecoder.inspect() - maps parameter locations.\nstruct Payload {\n    uint256 location;\n    uint256 size;\n    Payload[] children;\n    /* meta flags */\n    bool inlined;\n    bool variant;\n    bool overflow;\n}\n"
          },
          "contracts/types/Operator.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nenum Operator {\n    // 00:    EMPTY EXPRESSION (default, always passes)\n    //          paramType: Static / Dynamic / Tuple / Array / EtherValue\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          🚫 compValue\n    /* 00: */ Pass,\n    // ------------------------------------------------------------\n    // 01-03: LOGICAL EXPRESSIONS\n    //          paramType: None\n    //          ✅ children\n    //          🚫 compValue\n    /* 01: */ And,\n    /* 02: */ Or,\n    /* 03: */ _Placeholder03,\n    // ------------------------------------------------------------\n    // 04:    EMPTY CHECK (passes if data.length == 0)\n    //          paramType: None\n    //          🚫 children\n    //          🚫 compValue\n    /* 04: */ Empty,\n    // ------------------------------------------------------------\n    // 05-12: COMPLEX EXPRESSIONS\n    //          paramType: AbiEncoded / Tuple / Array,\n    //          ✅ children\n    //          🚫 compValue (exception AbiEncoded.Matches uses compValue to define leading bytes)\n    /* 05: */ Matches,\n    /* 06: */ ArraySome,\n    /* 07: */ ArrayEvery,\n    /* 08: */ ArrayTailMatches,\n    /* 09: */ _Placeholder09,\n    /* 10: */ ZipSome, // paramType: None, compValue: at least 2 bytes, one per plucked array\n    /* 11: */ ZipEvery, // paramType: None, compValue: at least 2 bytes, one per plucked array\n    /* 12: */ _Placeholder12,\n    // ------------------------------------------------------------\n    // 13-14: EXTRACTION EXPRESSIONS\n    //          ❓ children (at most one child, must resolve to Static)\n    //          ✅ compValue\n    /* 13: */ Slice, // paramType: Static / Dynamic, compValue: 3 bytes (2 bytes shift + 1 byte size, 1-32)\n    /* 14: */ Pluck, // paramType: Static / EtherValue / Array, compValue: 1 byte (index into pluckedValues, 0-255)\n    // ------------------------------------------------------------\n    // 15:    SPECIAL COMPARISON (without compValue)\n    //          paramType: Static\n    //          🚫 children\n    //          🚫 compValue\n    /* 15: */ EqualToAvatar,\n    // ------------------------------------------------------------\n    // 16-31: COMPARISON EXPRESSIONS\n    //          paramType: Static / Dynamic / Tuple / Array / EtherValue\n    //          ❓ children (only for paramType: Tuple / Array to describe their structure)\n    //          ✅ compValue\n    /* 16: */ EqualTo, // paramType: Static / Dynamic / Tuple / Array / EtherValue\n    /* 17: */ GreaterThan, // paramType: Static / EtherValue\n    /* 18: */ LessThan, // paramType: Static / EtherValue\n    /* 19: */ SignedIntGreaterThan, // paramType: Static / EtherValue\n    /* 20: */ SignedIntLessThan, // paramType: Static / EtherValue\n    /* 21: */ Bitmask, // paramType: Static / Dynamic\n    /* 22: */ Custom, // paramType: Static / Dynamic / Tuple / Array / EtherValue\n    /* 23: */ WithinRatio, // paramType: None\n    /* 24: */ _Placeholder24,\n    /* 25: */ _Placeholder25,\n    /* 26: */ _Placeholder26,\n    /* 27: */ _Placeholder27,\n    /* 28: */ WithinAllowance, // paramType: Static / EtherValue\n    /* 29: */ _Placeholder29,\n    /* 30: */ CallWithinAllowance, // paramType: None\n    /* 31: */ _Placeholder31\n}\n"
          },
          "contracts/types/Permission.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nenum Clearance {\n    None,\n    Target,\n    Function\n}\n\nenum ExecutionOptions {\n    None,\n    Send,\n    DelegateCall,\n    Both\n}\n\nstruct Role {\n    mapping(address => uint256) members;\n    mapping(address => Clearance) clearance;\n    mapping(bytes32 => uint256) scopeConfig;\n}\n"
          },
          "contracts/types/RolesError.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {Status} from \"./Authorization.sol\";\n\n/**\n * @title IRolesError - All custom errors emitted by the Roles Mod\n *\n * @author gnosisguild\n */\ninterface IRolesError {\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTION ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Sender is allowed to make this call, but the internal transaction failed\n    error ModuleTransactionFailed();\n\n    /// Reentrant call detected\n    error Reentrancy();\n\n    /*//////////////////////////////////////////////////////////////\n                          AUTHORIZATION ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Sender is not a member of the role\n    error NoMembership();\n\n    /// Membership is not yet valid (before start timestamp)\n    error MembershipNotYetValid();\n\n    /// Membership has expired (after end timestamp)\n    error MembershipExpired();\n\n    /// Function signature too short\n    error FunctionSignatureTooShort();\n\n    /// Calldata unwrapping failed\n    error MalformedMultiEntrypoint();\n\n    /// Authorization check failed with violation information\n    error ConditionViolation(\n        Status status,\n        uint256 violatedNodeIndex,\n        uint256 location\n    );\n\n    /// Target address is not allowed for this role\n    error TargetAddressNotAllowed(address target);\n\n    /// Function selector is not allowed for this role on the target\n    error FunctionNotAllowed(address target, bytes4 selector);\n\n    /// Sending value is not allowed\n    error SendNotAllowed(address target);\n\n    /// Delegate call is not allowed\n    error DelegateCallNotAllowed(address target);\n\n    /*//////////////////////////////////////////////////////////////\n                            DECODING ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Attempted to read beyond calldata bounds\n    error CalldataOutOfBounds();\n\n    /*//////////////////////////////////////////////////////////////\n                           INTEGRITY ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Root node is invalid or missing\n    error UnsuitableRootNode();\n\n    /// Condition tree is not in BFS (breadth-first search) order\n    error NotBFS();\n\n    /// Parameter type is unsuitable for the operator at given index\n    error UnsuitableParameterType(uint256 index);\n\n    /// Comparison value is unsuitable for the operator at given index\n    error UnsuitableCompValue(uint256 index);\n\n    /// Operator is not supported at given index\n    error UnsupportedOperator(uint256 index);\n\n    /// Parent node is unsuitable for the child at given index\n    error UnsuitableParent(uint256 index);\n\n    /// Child count is unsuitable for the node at given index\n    error UnsuitableChildCount(uint256 index);\n\n    /// Leaf node cannot have children at given index\n    error LeafNodeCannotHaveChildren(uint256 index);\n\n    /// Child type tree is unsuitable for the node at given index\n    error UnsuitableChildTypeTree(uint256 index);\n\n    /// WithinRatio target must resolve to a Static type\n    error WithinRatioTargetNotStatic(uint256 index);\n\n    /// WithinRatio requires at least one ratio (min or max) to be provided\n    error WithinRatioNoRatioProvided(uint256 index);\n\n    /// Allowance decimals exceed maximum of 18\n    error AllowanceDecimalsExceedMax(uint256 index);\n\n    /// Slice child must resolve to Static type\n    error SliceChildNotStatic(uint256 index);\n\n    /// WithinRatio references a Pluck index that hasn't been visited yet in DFS order\n    error PluckNotVisitedBeforeRef(uint256 index, uint8 pluckIndex);\n}\n"
          },
          "contracts/types/RolesEvent.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ExecutionOptions} from \"./Permission.sol\";\n\n/**\n * @title IRolesEvent - All events emitted by the Roles Mod.\n *\n * @author gnosisguild\n */\ninterface IRolesEvent {\n    /*//////////////////////////////////////////////////////////////\n                             SETUP EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Emitted when the Roles Mod is initialized\n    event RolesModSetup(\n        address indexed initiator,\n        address indexed owner,\n        address indexed avatar,\n        address target,\n        string version\n    );\n\n    /// Emitted when a role is granted to a module\n    event GrantRole(\n        bytes32 roleKey,\n        address module,\n        uint64 start,\n        uint64 end,\n        uint128 usesLeft\n    );\n\n    /// Emitted when a role is revoked from a module\n    event RevokeRole(bytes32 roleKey, address module);\n\n    /// Emitted when role membership is updated (e.g., uses consumed)\n    event UpdateRole(\n        bytes32 roleKey,\n        address module,\n        uint64 start,\n        uint64 end,\n        uint128 usesLeft\n    );\n\n    /// Emitted when the default role is set for a module\n    event SetDefaultRole(address module, bytes32 defaultRoleKey);\n\n    /*//////////////////////////////////////////////////////////////\n                           PERMISSION EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Emitted when a target address is allowed for a role\n    event AllowTarget(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes conditions,\n        ExecutionOptions options\n    );\n\n    /// Emitted when a target address is revoked from a role\n    event RevokeTarget(bytes32 roleKey, address targetAddress);\n\n    /// Emitted when a target is scoped (function-level permissions enabled)\n    event ScopeTarget(bytes32 roleKey, address targetAddress);\n\n    /// Emitted when a function is allowed for a role\n    event AllowFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector,\n        bytes conditions,\n        ExecutionOptions options\n    );\n\n    /// Emitted when a function is revoked from a role\n    event RevokeFunction(\n        bytes32 roleKey,\n        address targetAddress,\n        bytes4 selector\n    );\n\n    /// Emitted when an allowance is configured\n    event SetAllowance(\n        bytes32 allowanceKey,\n        uint128 balance,\n        uint128 maxRefill,\n        uint128 refill,\n        uint64 period,\n        uint64 timestamp\n    );\n\n    /// Emitted when a transaction unwrap adapter is set\n    event SetUnwrapAdapter(address to, bytes4 selector, address adapter);\n\n    /*//////////////////////////////////////////////////////////////\n                           ALLOWANCE EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// Emitted when an allowance is consumed during execution\n    event ConsumeAllowance(\n        bytes32 allowanceKey,\n        uint128 consumed,\n        uint128 newBalance\n    );\n}\n"
          },
          "contracts/types/Types.sol": {
            "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./Allowance.sol\";\nimport \"./Authorization.sol\";\nimport \"./Condition.sol\";\nimport \"./Operator.sol\";\nimport \"./Permission.sol\";\nimport \"./RolesError.sol\";\nimport \"./RolesEvent.sol\";\n"
          }
        },
        "settings": {
          "evmVersion": "cancun",
          "optimizer": {
            "enabled": true,
            "runs": 100
          },
          "outputSelection": {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata"
              ],
              "": [
                "ast"
              ]
            }
          }
        }
      }
    }
  }
}